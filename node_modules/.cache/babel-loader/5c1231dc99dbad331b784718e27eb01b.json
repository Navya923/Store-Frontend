{"ast":null,"code":"import { __assign, __rest, __spreadArray } from \"tslib\";\nimport * as React from 'react';\nimport { ContextualMenuItemType } from './ContextualMenu.types';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { FocusZone, FocusZoneDirection, FocusZoneTabbableElements } from '../../FocusZone';\nimport { divProperties, getNativeProps, shallowCompare, assign, classNamesFunction, css, getFirstFocusable, getLastFocusable, getRTL, KeyCodes, shouldWrapFocus, isIOS, isMac, memoizeFunction, getPropsWithDefaults, getDocument } from '../../Utilities';\nimport { hasSubmenu, getIsChecked, isItemDisabled } from '../../utilities/contextualMenu/index';\nimport { Callout } from '../../Callout';\nimport { ContextualMenuItem } from './ContextualMenuItem';\nimport { ContextualMenuSplitButton, ContextualMenuButton, ContextualMenuAnchor } from './ContextualMenuItemWrapper/index';\nimport { concatStyleSetsWithProps } from '../../Styling';\nimport { getItemStyles } from './ContextualMenu.classNames';\nimport { useTarget, usePrevious, useAsync, useWarnings, useId } from '@fluentui/react-hooks';\nimport { useResponsiveMode, ResponsiveMode } from '../../ResponsiveMode';\nimport { MenuContext } from '../../utilities/MenuContext/index';\nvar getClassNames = classNamesFunction();\nvar getContextualMenuItemClassNames = classNamesFunction(); // The default ContextualMenu properties have no items and beak, the default submenu direction is right and top.\n\nvar DEFAULT_PROPS = {\n  items: [],\n  shouldFocusOnMount: true,\n  gapSpace: 0,\n  directionalHint: DirectionalHint.bottomAutoEdge,\n  beakWidth: 16\n};\nexport function getSubmenuItems(item, options) {\n  var target = options === null || options === void 0 ? void 0 : options.target; // eslint-disable-next-line deprecation/deprecation\n\n  var items = item.subMenuProps ? item.subMenuProps.items : item.items;\n\n  if (items) {\n    var overrideItems = [];\n\n    for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {\n      var subItem = items_1[_i];\n\n      if (subItem.preferMenuTargetAsEventTarget) {\n        // For sub-items which need an overridden target, intercept `onClick`\n        var onClick = subItem.onClick,\n            contextItem = __rest(subItem, [\"onClick\"]);\n\n        overrideItems.push(__assign(__assign({}, contextItem), {\n          onClick: getOnClickWithOverrideTarget(onClick, target)\n        }));\n      } else {\n        overrideItems.push(subItem);\n      }\n    }\n\n    return overrideItems;\n  }\n}\n/**\n * Returns true if a list of menu items can contain a checkbox\n */\n\nexport function canAnyMenuItemsCheck(items) {\n  return items.some(function (item) {\n    if (item.canCheck) {\n      return true;\n    } // If the item is a section, check if any of the items in the section can check.\n\n\n    if (item.sectionProps && item.sectionProps.items.some(function (submenuItem) {\n      return submenuItem.canCheck === true;\n    })) {\n      return true;\n    }\n\n    return false;\n  });\n}\nvar NavigationIdleDelay = 250;\n/* ms */\n\nvar COMPONENT_NAME = 'ContextualMenu';\n\nvar _getMenuItemStylesFunction = memoizeFunction(function () {\n  var styles = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    styles[_i] = arguments[_i];\n  }\n\n  return function (styleProps) {\n    return concatStyleSetsWithProps.apply(void 0, __spreadArray([styleProps, getItemStyles], styles));\n  };\n}); //#region Custom hooks\n\n\nfunction useVisibility(props, targetWindow) {\n  var _a = props.hidden,\n      hidden = _a === void 0 ? false : _a,\n      onMenuDismissed = props.onMenuDismissed,\n      onMenuOpened = props.onMenuOpened;\n  var previousHidden = usePrevious(hidden);\n  var onMenuOpenedRef = React.useRef(onMenuOpened);\n  var onMenuClosedRef = React.useRef(onMenuDismissed);\n  var propsRef = React.useRef(props);\n  onMenuOpenedRef.current = onMenuOpened;\n  onMenuClosedRef.current = onMenuDismissed;\n  propsRef.current = props;\n  React.useEffect(function () {\n    var _a, _b; // Don't issue dismissed callbacks on initial mount\n\n\n    if (hidden && previousHidden === false) {\n      (_a = onMenuClosedRef.current) === null || _a === void 0 ? void 0 : _a.call(onMenuClosedRef, propsRef.current);\n    } else if (!hidden && previousHidden !== false) {\n      (_b = onMenuOpenedRef.current) === null || _b === void 0 ? void 0 : _b.call(onMenuOpenedRef, propsRef.current);\n    }\n  }, [hidden, previousHidden]); // Issue onDismissedCallback on unmount\n\n  React.useEffect(function () {\n    return function () {\n      var _a;\n\n      return (_a = onMenuClosedRef.current) === null || _a === void 0 ? void 0 : _a.call(onMenuClosedRef, propsRef.current);\n    };\n  }, []);\n}\n\nfunction useSubMenuState(_a, dismiss) {\n  var hidden = _a.hidden,\n      items = _a.items,\n      theme = _a.theme,\n      className = _a.className,\n      id = _a.id,\n      menuTarget = _a.target;\n\n  var _b = React.useState(),\n      expandedMenuItemKey = _b[0],\n      setExpandedMenuItemKey = _b[1];\n\n  var _c = React.useState(),\n      submenuTarget = _c[0],\n      setSubmenuTarget = _c[1];\n  /** True if the menu was expanded by mouse click OR hover (as opposed to by keyboard) */\n\n\n  var _d = React.useState(),\n      expandedByMouseClick = _d[0],\n      setExpandedByMouseClick = _d[1];\n\n  var subMenuId = useId(COMPONENT_NAME, id);\n  var closeSubMenu = React.useCallback(function () {\n    setExpandedByMouseClick(undefined);\n    setExpandedMenuItemKey(undefined);\n    setSubmenuTarget(undefined);\n  }, []);\n  var openSubMenu = React.useCallback(function (_a, target, openedByMouseClick) {\n    var submenuItemKey = _a.key;\n\n    if (expandedMenuItemKey === submenuItemKey) {\n      return;\n    }\n\n    target.focus();\n    setExpandedByMouseClick(openedByMouseClick);\n    setExpandedMenuItemKey(submenuItemKey);\n    setSubmenuTarget(target);\n  }, [expandedMenuItemKey]);\n  React.useEffect(function () {\n    if (hidden) {\n      closeSubMenu();\n    }\n  }, [hidden, closeSubMenu]);\n  var onSubMenuDismiss = useOnSubmenuDismiss(dismiss, closeSubMenu);\n\n  var getSubmenuProps = function () {\n    var item = findItemByKeyFromItems(expandedMenuItemKey, items);\n    var submenuProps = null;\n\n    if (item) {\n      submenuProps = {\n        items: getSubmenuItems(item),\n        target: submenuTarget,\n        onDismiss: onSubMenuDismiss,\n        isSubMenu: true,\n        id: subMenuId,\n        shouldFocusOnMount: true,\n        shouldFocusOnContainer: expandedByMouseClick,\n        directionalHint: getRTL(theme) ? DirectionalHint.leftTopEdge : DirectionalHint.rightTopEdge,\n        className: className,\n        gapSpace: 0,\n        isBeakVisible: false\n      };\n\n      if (item.subMenuProps) {\n        assign(submenuProps, item.subMenuProps);\n      }\n\n      if (item.preferMenuTargetAsEventTarget) {\n        var onItemClick = item.onItemClick;\n        submenuProps.onItemClick = getOnClickWithOverrideTarget(onItemClick, menuTarget);\n      }\n    }\n\n    return submenuProps;\n  };\n\n  return [expandedMenuItemKey, openSubMenu, getSubmenuProps, onSubMenuDismiss];\n}\n\nfunction useShouldUpdateFocusOnMouseMove(_a) {\n  var delayUpdateFocusOnHover = _a.delayUpdateFocusOnHover,\n      hidden = _a.hidden;\n  var shouldUpdateFocusOnMouseEvent = React.useRef(!delayUpdateFocusOnHover);\n  var gotMouseMove = React.useRef(false);\n  React.useEffect(function () {\n    shouldUpdateFocusOnMouseEvent.current = !delayUpdateFocusOnHover;\n    gotMouseMove.current = hidden ? false : !delayUpdateFocusOnHover && gotMouseMove.current;\n  }, [delayUpdateFocusOnHover, hidden]);\n  var onMenuFocusCapture = React.useCallback(function () {\n    if (delayUpdateFocusOnHover) {\n      shouldUpdateFocusOnMouseEvent.current = true;\n    }\n  }, [delayUpdateFocusOnHover]);\n  return [shouldUpdateFocusOnMouseEvent, gotMouseMove, onMenuFocusCapture];\n}\n\nfunction usePreviousActiveElement(_a, targetWindow) {\n  var hidden = _a.hidden,\n      onRestoreFocus = _a.onRestoreFocus;\n  var previousActiveElement = React.useRef();\n  var tryFocusPreviousActiveElement = React.useCallback(function (options) {\n    var _a, _b;\n\n    if (onRestoreFocus) {\n      onRestoreFocus(options);\n    } else if (options === null || options === void 0 ? void 0 : options.documentContainsFocus) {\n      // Make sure that the focus method actually exists\n      // In some cases the object might exist but not be a real element.\n      // This is primarily for IE 11 and should be removed once IE 11 is no longer in use.\n      (_b = (_a = previousActiveElement.current) === null || _a === void 0 ? void 0 : _a.focus) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n  }, [onRestoreFocus]); // eslint-disable-next-line no-restricted-properties\n\n  React.useLayoutEffect(function () {\n    var _a;\n\n    if (!hidden) {\n      previousActiveElement.current = targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement;\n    } else if (previousActiveElement.current) {\n      tryFocusPreviousActiveElement({\n        originalElement: previousActiveElement.current,\n        containsFocus: true,\n        documentContainsFocus: ((_a = getDocument()) === null || _a === void 0 ? void 0 : _a.hasFocus()) || false\n      });\n      previousActiveElement.current = undefined;\n    }\n  }, [hidden, targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement, tryFocusPreviousActiveElement]);\n  return [tryFocusPreviousActiveElement];\n}\n\nfunction useKeyHandlers(_a, dismiss, hostElement, openSubMenu) {\n  var theme = _a.theme,\n      isSubMenu = _a.isSubMenu,\n      _b = _a.focusZoneProps,\n      _c = _b === void 0 ? {} : _b,\n      checkForNoWrap = _c.checkForNoWrap,\n      _d = _c.direction,\n      focusZoneDirection = _d === void 0 ? FocusZoneDirection.vertical : _d;\n  /** True if the most recent keydown event was for alt (option) or meta (command). */\n\n\n  var lastKeyDownWasAltOrMeta = React.useRef();\n  /**\n   * Calls `shouldHandleKey` to determine whether the keyboard event should be handled;\n   * if so, stops event propagation and dismisses menu(s).\n   * @param ev - The keyboard event.\n   * @param shouldHandleKey - Returns whether we should handle this keyboard event.\n   * @param dismissAllMenus - If true, dismiss all menus. Otherwise, dismiss only the current menu.\n   * Only does anything if `shouldHandleKey` returns true.\n   * @returns Whether the event was handled.\n   */\n\n  var keyHandler = function (ev, shouldHandleKey, dismissAllMenus) {\n    var handled = false;\n\n    if (shouldHandleKey(ev)) {\n      dismiss(ev, dismissAllMenus);\n      ev.preventDefault();\n      ev.stopPropagation();\n      handled = true;\n    }\n\n    return handled;\n  };\n  /**\n   * Checks if the submenu should be closed\n   */\n\n\n  var shouldCloseSubMenu = function (ev) {\n    var submenuCloseKey = getRTL(theme) ? KeyCodes.right : KeyCodes.left; // eslint-disable-next-line deprecation/deprecation\n\n    if (ev.which !== submenuCloseKey || !isSubMenu) {\n      return false;\n    }\n\n    return !!(focusZoneDirection === FocusZoneDirection.vertical || checkForNoWrap && !shouldWrapFocus(ev.target, 'data-no-horizontal-wrap'));\n  };\n\n  var shouldHandleKeyDown = function (ev) {\n    return (// eslint-disable-next-line deprecation/deprecation\n      ev.which === KeyCodes.escape || shouldCloseSubMenu(ev) || // eslint-disable-next-line deprecation/deprecation\n      ev.which === KeyCodes.up && (ev.altKey || ev.metaKey)\n    );\n  };\n\n  var onKeyDown = function (ev) {\n    // Take note if we are processing an alt (option) or meta (command) keydown.\n    // See comment in shouldHandleKeyUp for reasoning.\n    lastKeyDownWasAltOrMeta.current = isAltOrMeta(ev); // On Mac, pressing escape dismisses all levels of native context menus\n    // eslint-disable-next-line deprecation/deprecation\n\n    var dismissAllMenus = ev.which === KeyCodes.escape && (isMac() || isIOS());\n    return keyHandler(ev, shouldHandleKeyDown, dismissAllMenus);\n  };\n  /**\n   * We close the menu on key up only if ALL of the following are true:\n   * - Most recent key down was alt or meta (command)\n   * - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\n   *   expand/collapse the menu)\n   * - We're not on a Mac (or iOS)\n   *\n   * This is because on Windows, pressing alt moves focus to the application menu bar or similar,\n   * closing any open context menus. There is not a similar behavior on Macs.\n   */\n\n\n  var shouldHandleKeyUp = function (ev) {\n    var keyPressIsAltOrMetaAlone = lastKeyDownWasAltOrMeta.current && isAltOrMeta(ev);\n    lastKeyDownWasAltOrMeta.current = false;\n    return !!keyPressIsAltOrMetaAlone && !(isIOS() || isMac());\n  };\n\n  var onKeyUp = function (ev) {\n    return keyHandler(ev, shouldHandleKeyUp, true\n    /* dismissAllMenus */\n    );\n  };\n\n  var onMenuKeyDown = function (ev) {\n    // Mark as handled if onKeyDown returns true (for handling collapse cases)\n    // or if we are attempting to expand a submenu\n    var handled = onKeyDown(ev);\n\n    if (handled || !hostElement.current) {\n      return;\n    } // If we have a modifier key being pressed, we do not want to move focus.\n    // Otherwise, handle up and down keys.\n\n\n    var hasModifier = !!(ev.altKey || ev.metaKey); // eslint-disable-next-line deprecation/deprecation\n\n    var isUp = ev.which === KeyCodes.up; // eslint-disable-next-line deprecation/deprecation\n\n    var isDown = ev.which === KeyCodes.down;\n\n    if (!hasModifier && (isUp || isDown)) {\n      var elementToFocus = isUp ? getLastFocusable(hostElement.current, hostElement.current.lastChild, true) : getFirstFocusable(hostElement.current, hostElement.current.firstChild, true);\n\n      if (elementToFocus) {\n        elementToFocus.focus();\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n\n  var onItemKeyDown = function (item, ev) {\n    var openKey = getRTL(theme) ? KeyCodes.left : KeyCodes.right;\n\n    if (!item.disabled && ( // eslint-disable-next-line deprecation/deprecation\n    ev.which === openKey || ev.which === KeyCodes.enter || ev.which === KeyCodes.down && (ev.altKey || ev.metaKey))) {\n      openSubMenu(item, ev.currentTarget, false);\n      ev.preventDefault();\n    }\n  };\n\n  return [onKeyDown, onKeyUp, onMenuKeyDown, onItemKeyDown];\n}\n\nfunction useScrollHandler(asyncTracker) {\n  var isScrollIdle = React.useRef(true);\n  var scrollIdleTimeoutId = React.useRef();\n  /**\n   * Scroll handler for the callout to make sure the mouse events\n   * for updating focus are not interacting during scroll\n   */\n\n  var onScroll = function () {\n    if (!isScrollIdle.current && scrollIdleTimeoutId.current !== undefined) {\n      asyncTracker.clearTimeout(scrollIdleTimeoutId.current);\n      scrollIdleTimeoutId.current = undefined;\n    } else {\n      isScrollIdle.current = false;\n    }\n\n    scrollIdleTimeoutId.current = asyncTracker.setTimeout(function () {\n      isScrollIdle.current = true;\n    }, NavigationIdleDelay);\n  };\n\n  return [onScroll, isScrollIdle];\n}\n\nfunction useOnSubmenuDismiss(dismiss, closeSubMenu) {\n  var isMountedRef = React.useRef(false);\n  React.useEffect(function () {\n    isMountedRef.current = true;\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  /**\n   * This function is called ASYNCHRONOUSLY, and so there is a chance it is called\n   * after the component is unmounted. The isMountedRef is added to prevent\n   * from calling setState() after unmount. Do NOT copy this pattern in synchronous\n   * code.\n   */\n\n  var onSubMenuDismiss = function (ev, dismissAll) {\n    if (dismissAll) {\n      dismiss(ev, dismissAll);\n    } else if (isMountedRef.current) {\n      closeSubMenu();\n    }\n  };\n\n  return onSubMenuDismiss;\n}\n\nfunction useSubmenuEnterTimer(_a, asyncTracker) {\n  var _b = _a.subMenuHoverDelay,\n      subMenuHoverDelay = _b === void 0 ? NavigationIdleDelay : _b;\n  var enterTimerRef = React.useRef(undefined);\n\n  var cancelSubMenuTimer = function () {\n    if (enterTimerRef.current !== undefined) {\n      asyncTracker.clearTimeout(enterTimerRef.current);\n      enterTimerRef.current = undefined;\n    }\n  };\n\n  var startSubmenuTimer = function (onTimerExpired) {\n    enterTimerRef.current = asyncTracker.setTimeout(function () {\n      onTimerExpired();\n      cancelSubMenuTimer();\n    }, subMenuHoverDelay);\n  };\n\n  return [cancelSubMenuTimer, startSubmenuTimer, enterTimerRef];\n}\n\nfunction useMouseHandlers(props, isScrollIdle, subMenuEntryTimer, targetWindow, shouldUpdateFocusOnMouseEvent, gotMouseMove, expandedMenuItemKey, hostElement, startSubmenuTimer, cancelSubMenuTimer, openSubMenu, onSubMenuDismiss, dismiss) {\n  var menuTarget = props.target;\n\n  var onItemMouseEnterBase = function (item, ev, target) {\n    if (shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    updateFocusOnMouseEvent(item, ev, target);\n  };\n\n  var onItemMouseMoveBase = function (item, ev, target) {\n    var targetElement = ev.currentTarget; // Always do this check to make sure we record a mouseMove if needed (even if we are timed out)\n\n    if (shouldUpdateFocusOnMouseEvent.current) {\n      gotMouseMove.current = true;\n    } else {\n      return;\n    }\n\n    if (!isScrollIdle.current || subMenuEntryTimer.current !== undefined || targetElement === (targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement)) {\n      return;\n    }\n\n    updateFocusOnMouseEvent(item, ev, target);\n  };\n\n  var shouldIgnoreMouseEvent = function () {\n    return !isScrollIdle.current || !gotMouseMove.current;\n  };\n\n  var onMouseItemLeave = function (item, ev) {\n    var _a;\n\n    if (shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    cancelSubMenuTimer();\n\n    if (expandedMenuItemKey !== undefined) {\n      return;\n    }\n    /**\n     * IE11 focus() method forces parents to scroll to top of element.\n     * Edge and IE expose a setActive() function for focusable divs that\n     * sets the page focus but does not scroll the parent element.\n     */\n\n\n    if (hostElement.current.setActive) {\n      try {\n        hostElement.current.setActive();\n      } catch (e) {\n        /* no-op */\n      }\n    } else {\n      (_a = hostElement.current) === null || _a === void 0 ? void 0 : _a.focus();\n    }\n  };\n  /**\n   * Handles updating focus when mouseEnter or mouseMove fire.\n   * As part of updating focus, This function will also update\n   * the expand/collapse state accordingly.\n   */\n\n\n  var updateFocusOnMouseEvent = function (item, ev, target) {\n    var targetElement = target ? target : ev.currentTarget;\n\n    if (item.key === expandedMenuItemKey) {\n      return;\n    }\n\n    cancelSubMenuTimer(); // If the menu is not expanded we can update focus without any delay\n\n    if (expandedMenuItemKey === undefined) {\n      targetElement.focus();\n    } // Delay updating expanding/dismissing the submenu\n    // and only set focus if we have not already done so\n\n\n    if (hasSubmenu(item)) {\n      ev.stopPropagation();\n      startSubmenuTimer(function () {\n        targetElement.focus();\n        openSubMenu(item, targetElement, true);\n      });\n    } else {\n      startSubmenuTimer(function () {\n        onSubMenuDismiss(ev);\n        targetElement.focus();\n      });\n    }\n  };\n\n  var onItemClick = function (item, ev) {\n    onItemClickBase(item, ev, ev.currentTarget);\n  };\n\n  var onItemClickBase = function (item, ev, target) {\n    var items = getSubmenuItems(item); // Cancel an async menu item hover timeout action from being taken and instead\n    // just trigger the click event instead.\n\n    cancelSubMenuTimer();\n\n    if (!hasSubmenu(item) && (!items || !items.length)) {\n      // This is an item without a menu. Click it.\n      executeItemClick(item, ev);\n    } else {\n      if (item.key !== expandedMenuItemKey) {\n        // This has a collapsed sub menu. Expand it.\n        openSubMenu(item, target, // When Edge + Narrator are used together (regardless of if the button is in a form or not), pressing\n        // \"Enter\" fires this method and not _onMenuKeyDown. Checking ev.nativeEvent.detail differentiates\n        // between a real click event and a keypress event (detail should be the number of mouse clicks).\n        // ...Plot twist! For a real click event in IE 11, detail is always 0 (Edge sets it properly to 1).\n        // So we also check the pointerType property, which both Edge and IE set to \"mouse\" for real clicks\n        // and \"\" for pressing \"Enter\" with Narrator on.\n        ev.nativeEvent.detail !== 0 || ev.nativeEvent.pointerType === 'mouse');\n      }\n    }\n\n    ev.stopPropagation();\n    ev.preventDefault();\n  };\n\n  var onAnchorClick = function (item, ev) {\n    executeItemClick(item, ev);\n    ev.stopPropagation();\n  };\n\n  var executeItemClick = function (item, ev) {\n    if (item.disabled || item.isDisabled) {\n      return;\n    }\n\n    if (item.preferMenuTargetAsEventTarget) {\n      overrideTarget(ev, menuTarget);\n    }\n\n    var shouldDismiss = false;\n\n    if (item.onClick) {\n      shouldDismiss = !!item.onClick(ev, item);\n    } else if (props.onItemClick) {\n      shouldDismiss = !!props.onItemClick(ev, item);\n    }\n\n    if (shouldDismiss || !ev.defaultPrevented) {\n      dismiss(ev, true);\n    }\n  };\n\n  return [onItemMouseEnterBase, onItemMouseMoveBase, onMouseItemLeave, onItemClick, onAnchorClick, executeItemClick, onItemClickBase];\n} //#endregion\n\n\nexport var ContextualMenuBase = React.memo(React.forwardRef(function (propsWithoutDefaults, forwardedRef) {\n  var _a;\n\n  var _b = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults),\n      ref = _b.ref,\n      props = __rest(_b, [\"ref\"]);\n\n  var hostElement = React.useRef(null);\n  var asyncTracker = useAsync();\n  var menuId = useId(COMPONENT_NAME, props.id);\n  useWarnings({\n    name: COMPONENT_NAME,\n    props: props,\n    deprecations: {\n      getMenuClassNames: 'styles'\n    }\n  });\n\n  var dismiss = function (ev, dismissAll) {\n    var _a;\n\n    return (_a = props.onDismiss) === null || _a === void 0 ? void 0 : _a.call(props, ev, dismissAll);\n  };\n\n  var _c = useTarget(props.target, hostElement),\n      targetRef = _c[0],\n      targetWindow = _c[1];\n\n  var tryFocusPreviousActiveElement = usePreviousActiveElement(props, targetWindow)[0];\n\n  var _d = useSubMenuState(props, dismiss),\n      expandedMenuItemKey = _d[0],\n      openSubMenu = _d[1],\n      getSubmenuProps = _d[2],\n      onSubMenuDismiss = _d[3];\n\n  var _e = useShouldUpdateFocusOnMouseMove(props),\n      shouldUpdateFocusOnMouseEvent = _e[0],\n      gotMouseMove = _e[1],\n      onMenuFocusCapture = _e[2];\n\n  var _f = useScrollHandler(asyncTracker),\n      onScroll = _f[0],\n      isScrollIdle = _f[1];\n\n  var _g = useSubmenuEnterTimer(props, asyncTracker),\n      cancelSubMenuTimer = _g[0],\n      startSubmenuTimer = _g[1],\n      subMenuEntryTimer = _g[2];\n\n  var responsiveMode = useResponsiveMode(hostElement, props.responsiveMode);\n  useVisibility(props, targetWindow);\n\n  var _h = useKeyHandlers(props, dismiss, hostElement, openSubMenu),\n      onKeyDown = _h[0],\n      onKeyUp = _h[1],\n      onMenuKeyDown = _h[2],\n      onItemKeyDown = _h[3];\n\n  var _j = useMouseHandlers(props, isScrollIdle, subMenuEntryTimer, targetWindow, shouldUpdateFocusOnMouseEvent, gotMouseMove, expandedMenuItemKey, hostElement, startSubmenuTimer, cancelSubMenuTimer, openSubMenu, onSubMenuDismiss, dismiss),\n      onItemMouseEnterBase = _j[0],\n      onItemMouseMoveBase = _j[1],\n      onMouseItemLeave = _j[2],\n      onItemClick = _j[3],\n      onAnchorClick = _j[4],\n      executeItemClick = _j[5],\n      onItemClickBase = _j[6]; //#region Render helpers\n\n\n  var onDefaultRenderMenuList = function (menuListProps, // eslint-disable-next-line deprecation/deprecation\n  menuClassNames, defaultRender) {\n    var indexCorrection = 0;\n    var items = menuListProps.items,\n        totalItemCount = menuListProps.totalItemCount,\n        hasCheckmarks = menuListProps.hasCheckmarks,\n        hasIcons = menuListProps.hasIcons;\n    return React.createElement(\"ul\", {\n      className: menuClassNames.list,\n      onKeyDown: onKeyDown,\n      onKeyUp: onKeyUp,\n      role: 'presentation'\n    }, items.map(function (item, index) {\n      var menuItem = renderMenuItem(item, index, indexCorrection, totalItemCount, hasCheckmarks, hasIcons, menuClassNames);\n\n      if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n        var indexIncrease = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n        indexCorrection += indexIncrease;\n      }\n\n      return menuItem;\n    }));\n  };\n\n  var renderFocusZone = function (children, adjustedFocusZoneProps) {\n    var _a = props.focusZoneAs,\n        ChildrenRenderer = _a === void 0 ? FocusZone : _a;\n    return React.createElement(ChildrenRenderer, __assign({}, adjustedFocusZoneProps), children);\n  };\n  /**\n   * !!!IMPORTANT!!! Avoid mutating `item: IContextualMenuItem` argument. It will\n   * cause the menu items to always re-render because the component update is based on shallow comparison.\n   */\n\n\n  var renderMenuItem = function (item, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons, // eslint-disable-next-line deprecation/deprecation\n  menuClassNames) {\n    var _a;\n\n    var renderedItems = [];\n    var iconProps = item.iconProps || {\n      iconName: 'None'\n    };\n    var getItemClassNames = item.getItemClassNames,\n        // eslint-disable-line deprecation/deprecation\n    itemProps = item.itemProps;\n    var styles = itemProps ? itemProps.styles : undefined; // We only send a dividerClassName when the item to be rendered is a divider.\n    // For all other cases, the default divider style is used.\n\n    var dividerClassName = item.itemType === ContextualMenuItemType.Divider ? item.className : undefined;\n    var subMenuIconClassName = item.submenuIconProps ? item.submenuIconProps.className : ''; // eslint-disable-next-line deprecation/deprecation\n\n    var itemClassNames; // IContextualMenuItem#getItemClassNames for backwards compatibility\n    // otherwise uses mergeStyles for class names.\n\n    if (getItemClassNames) {\n      itemClassNames = getItemClassNames(props.theme, isItemDisabled(item), expandedMenuItemKey === item.key, !!getIsChecked(item), !!item.href, iconProps.iconName !== 'None', item.className, dividerClassName, iconProps.className, subMenuIconClassName, item.primaryDisabled);\n    } else {\n      var itemStyleProps = {\n        theme: props.theme,\n        disabled: isItemDisabled(item),\n        expanded: expandedMenuItemKey === item.key,\n        checked: !!getIsChecked(item),\n        isAnchorLink: !!item.href,\n        knownIcon: iconProps.iconName !== 'None',\n        itemClassName: item.className,\n        dividerClassName: dividerClassName,\n        iconClassName: iconProps.className,\n        subMenuClassName: subMenuIconClassName,\n        primaryDisabled: item.primaryDisabled\n      }; // We need to generate default styles then override if styles are provided\n      // since the ContextualMenu currently handles item classNames.\n\n      itemClassNames = getContextualMenuItemClassNames(_getMenuItemStylesFunction((_a = menuClassNames.subComponentStyles) === null || _a === void 0 ? void 0 : _a.menuItem, styles), itemStyleProps);\n    } // eslint-disable-next-line deprecation/deprecation\n\n\n    if (item.text === '-' || item.name === '-') {\n      item.itemType = ContextualMenuItemType.Divider;\n    }\n\n    switch (item.itemType) {\n      case ContextualMenuItemType.Divider:\n        renderedItems.push(renderSeparator(index, itemClassNames));\n        break;\n\n      case ContextualMenuItemType.Header:\n        renderedItems.push(renderSeparator(index, itemClassNames));\n        var headerItem = renderHeaderMenuItem(item, itemClassNames, menuClassNames, index, hasCheckmarks, hasIcons);\n        renderedItems.push(renderListItem(headerItem, item.key || index, itemClassNames, item.title));\n        break;\n\n      case ContextualMenuItemType.Section:\n        renderedItems.push(renderSectionItem(item, itemClassNames, menuClassNames, index, hasCheckmarks, hasIcons));\n        break;\n\n      default:\n        var menuItem = renderNormalItem(item, itemClassNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n        renderedItems.push(renderListItem(menuItem, item.key || index, itemClassNames, item.title));\n        break;\n    } // Since multiple nodes *could* be rendered, wrap them all in a fragment with this item's key.\n    // This ensures the reconciler handles multi-item output per-node correctly and does not re-mount content.\n\n\n    return React.createElement(React.Fragment, {\n      key: item.key\n    }, renderedItems);\n  };\n\n  var defaultMenuItemRenderer = function (item, // eslint-disable-next-line deprecation/deprecation\n  menuClassNames) {\n    var index = item.index,\n        focusableElementIndex = item.focusableElementIndex,\n        totalItemCount = item.totalItemCount,\n        hasCheckmarks = item.hasCheckmarks,\n        hasIcons = item.hasIcons;\n    return renderMenuItem(item, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons, menuClassNames);\n  };\n\n  var renderSectionItem = function (sectionItem, // eslint-disable-next-line deprecation/deprecation\n  itemClassNames, // eslint-disable-next-line deprecation/deprecation\n  menuClassNames, index, hasCheckmarks, hasIcons) {\n    var sectionProps = sectionItem.sectionProps;\n\n    if (!sectionProps) {\n      return;\n    }\n\n    var headerItem;\n    var groupProps;\n\n    if (sectionProps.title) {\n      var headerContextualMenuItem = undefined;\n      var ariaLabelledby = '';\n\n      if (typeof sectionProps.title === 'string') {\n        // Since title is a user-facing string, it needs to be stripped\n        // of whitespace in order to build a valid element ID\n        var id_1 = menuId + sectionProps.title.replace(/\\s/g, '');\n        headerContextualMenuItem = {\n          key: \"section-\" + sectionProps.title + \"-title\",\n          itemType: ContextualMenuItemType.Header,\n          text: sectionProps.title,\n          id: id_1\n        };\n        ariaLabelledby = id_1;\n      } else {\n        var id_2 = sectionProps.title.id || menuId + sectionProps.title.key.replace(/\\s/g, '');\n        headerContextualMenuItem = __assign(__assign({}, sectionProps.title), {\n          id: id_2\n        });\n        ariaLabelledby = id_2;\n      }\n\n      if (headerContextualMenuItem) {\n        groupProps = {\n          role: 'group',\n          'aria-labelledby': ariaLabelledby\n        };\n        headerItem = renderHeaderMenuItem(headerContextualMenuItem, itemClassNames, menuClassNames, index, hasCheckmarks, hasIcons);\n      }\n    }\n\n    if (sectionProps.items && sectionProps.items.length > 0) {\n      return React.createElement(\"li\", {\n        role: \"presentation\",\n        key: sectionProps.key || sectionItem.key || \"section-\" + index\n      }, React.createElement(\"div\", __assign({}, groupProps), React.createElement(\"ul\", {\n        className: menuClassNames.list,\n        role: \"presentation\"\n      }, sectionProps.topDivider && renderSeparator(index, itemClassNames, true, true), headerItem && renderListItem(headerItem, sectionItem.key || index, itemClassNames, sectionItem.title), sectionProps.items.map(function (contextualMenuItem, itemsIndex) {\n        return renderMenuItem(contextualMenuItem, itemsIndex, itemsIndex, sectionProps.items.length, hasCheckmarks, hasIcons, menuClassNames);\n      }), sectionProps.bottomDivider && renderSeparator(index, itemClassNames, false, true))));\n    }\n  };\n\n  var renderListItem = function (content, key, classNames, // eslint-disable-line deprecation/deprecation\n  title) {\n    return React.createElement(\"li\", {\n      role: \"presentation\",\n      title: title,\n      key: key,\n      className: classNames.item\n    }, content);\n  };\n\n  var renderSeparator = function (index, classNames, // eslint-disable-line deprecation/deprecation\n  top, fromSection) {\n    if (fromSection || index > 0) {\n      return React.createElement(\"li\", {\n        role: \"separator\",\n        key: 'separator-' + index + (top === undefined ? '' : top ? '-top' : '-bottom'),\n        className: classNames.divider,\n        \"aria-hidden\": \"true\"\n      });\n    }\n\n    return null;\n  };\n\n  var renderNormalItem = function (item, classNames, // eslint-disable-line deprecation/deprecation\n  index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n    if (item.onRender) {\n      return item.onRender(__assign({\n        'aria-posinset': focusableElementIndex + 1,\n        'aria-setsize': totalItemCount\n      }, item), dismiss);\n    }\n\n    var contextualMenuItemAs = props.contextualMenuItemAs;\n    var commonProps = {\n      item: item,\n      classNames: classNames,\n      index: index,\n      focusableElementIndex: focusableElementIndex,\n      totalItemCount: totalItemCount,\n      hasCheckmarks: hasCheckmarks,\n      hasIcons: hasIcons,\n      contextualMenuItemAs: contextualMenuItemAs,\n      onItemMouseEnter: onItemMouseEnterBase,\n      onItemMouseLeave: onMouseItemLeave,\n      onItemMouseMove: onItemMouseMoveBase,\n      onItemMouseDown: onItemMouseDown,\n      executeItemClick: executeItemClick,\n      onItemKeyDown: onItemKeyDown,\n      expandedMenuItemKey: expandedMenuItemKey,\n      openSubMenu: openSubMenu,\n      dismissSubMenu: onSubMenuDismiss,\n      dismissMenu: dismiss\n    };\n\n    if (item.href) {\n      return React.createElement(ContextualMenuAnchor, __assign({}, commonProps, {\n        onItemClick: onAnchorClick\n      }));\n    }\n\n    if (item.split && hasSubmenu(item)) {\n      return React.createElement(ContextualMenuSplitButton, __assign({}, commonProps, {\n        onItemClick: onItemClick,\n        onItemClickBase: onItemClickBase,\n        onTap: cancelSubMenuTimer\n      }));\n    }\n\n    return React.createElement(ContextualMenuButton, __assign({}, commonProps, {\n      onItemClick: onItemClick,\n      onItemClickBase: onItemClickBase\n    }));\n  };\n\n  var renderHeaderMenuItem = function (item, // eslint-disable-next-line deprecation/deprecation\n  itemClassNames, // eslint-disable-next-line deprecation/deprecation\n  menuClassNames, index, hasCheckmarks, hasIcons) {\n    var _a = props.contextualMenuItemAs,\n        ChildrenRenderer = _a === void 0 ? ContextualMenuItem : _a;\n    var itemProps = item.itemProps,\n        id = item.id;\n    var divHtmlProperties = itemProps && getNativeProps(itemProps, divProperties);\n    return (// eslint-disable-next-line deprecation/deprecation\n      React.createElement(\"div\", __assign({\n        id: id,\n        className: menuClassNames.header\n      }, divHtmlProperties, {\n        style: item.style\n      }), React.createElement(ChildrenRenderer, __assign({\n        item: item,\n        classNames: itemClassNames,\n        index: index,\n        onCheckmarkClick: hasCheckmarks ? onItemClick : undefined,\n        hasIcons: hasIcons\n      }, itemProps)))\n    );\n  }; //#endregion\n  //#region Main render\n\n\n  var isBeakVisible = props.isBeakVisible;\n  var items = props.items,\n      labelElementId = props.labelElementId,\n      id = props.id,\n      className = props.className,\n      beakWidth = props.beakWidth,\n      directionalHint = props.directionalHint,\n      directionalHintForRTL = props.directionalHintForRTL,\n      alignTargetEdge = props.alignTargetEdge,\n      gapSpace = props.gapSpace,\n      coverTarget = props.coverTarget,\n      ariaLabel = props.ariaLabel,\n      doNotLayer = props.doNotLayer,\n      target = props.target,\n      bounds = props.bounds,\n      useTargetWidth = props.useTargetWidth,\n      useTargetAsMinWidth = props.useTargetAsMinWidth,\n      directionalHintFixed = props.directionalHintFixed,\n      shouldFocusOnMount = props.shouldFocusOnMount,\n      shouldFocusOnContainer = props.shouldFocusOnContainer,\n      title = props.title,\n      styles = props.styles,\n      theme = props.theme,\n      calloutProps = props.calloutProps,\n      _k = props.onRenderSubMenu,\n      onRenderSubMenu = _k === void 0 ? onDefaultRenderSubMenu : _k,\n      _l = props.onRenderMenuList,\n      onRenderMenuList = _l === void 0 ? function (menuListProps, defaultRender) {\n    return onDefaultRenderMenuList(menuListProps, classNames, defaultRender);\n  } : _l,\n      focusZoneProps = props.focusZoneProps,\n      // eslint-disable-next-line deprecation/deprecation\n  getMenuClassNames = props.getMenuClassNames;\n  var classNames = getMenuClassNames ? getMenuClassNames(theme, className) : getClassNames(styles, {\n    theme: theme,\n    className: className\n  });\n  var hasIcons = itemsHaveIcons(items);\n\n  function itemsHaveIcons(contextualMenuItems) {\n    for (var _i = 0, contextualMenuItems_1 = contextualMenuItems; _i < contextualMenuItems_1.length; _i++) {\n      var item = contextualMenuItems_1[_i];\n\n      if (item.iconProps) {\n        return true;\n      }\n\n      if (item.itemType === ContextualMenuItemType.Section && item.sectionProps && itemsHaveIcons(item.sectionProps.items)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var adjustedFocusZoneProps = __assign(__assign({\n    direction: FocusZoneDirection.vertical,\n    handleTabKey: FocusZoneTabbableElements.all,\n    isCircularNavigation: true\n  }, focusZoneProps), {\n    className: css(classNames.root, (_a = props.focusZoneProps) === null || _a === void 0 ? void 0 : _a.className)\n  });\n\n  var hasCheckmarks = canAnyMenuItemsCheck(items);\n  var submenuProps = expandedMenuItemKey && props.hidden !== true ? getSubmenuProps() : null;\n  isBeakVisible = isBeakVisible === undefined ? responsiveMode <= ResponsiveMode.medium : isBeakVisible;\n  /**\n   * When useTargetWidth is true, get the width of the target element and apply it for the context menu container\n   */\n\n  var contextMenuStyle;\n  var targetAsHtmlElement = targetRef.current;\n\n  if ((useTargetWidth || useTargetAsMinWidth) && targetAsHtmlElement && targetAsHtmlElement.offsetWidth) {\n    var targetBoundingRect = targetAsHtmlElement.getBoundingClientRect();\n    var targetWidth = targetBoundingRect.width - 2;\n    /* Accounts for 1px border */\n\n    if (useTargetWidth) {\n      contextMenuStyle = {\n        width: targetWidth\n      };\n    } else if (useTargetAsMinWidth) {\n      contextMenuStyle = {\n        minWidth: targetWidth\n      };\n    }\n  } // The menu should only return if items were provided, if no items were provided then it should not appear.\n\n\n  if (items && items.length > 0) {\n    var totalItemCount_1 = 0;\n\n    for (var _i = 0, items_2 = items; _i < items_2.length; _i++) {\n      var item = items_2[_i];\n\n      if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n        var itemCount = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n        totalItemCount_1 += itemCount;\n      }\n    }\n\n    var calloutStyles_1 = classNames.subComponentStyles ? classNames.subComponentStyles.callout : undefined;\n    return React.createElement(MenuContext.Consumer, null, function (menuContext) {\n      return React.createElement(Callout, __assign({\n        styles: calloutStyles_1,\n        onRestoreFocus: tryFocusPreviousActiveElement\n      }, calloutProps, {\n        target: target || menuContext.target,\n        isBeakVisible: isBeakVisible,\n        beakWidth: beakWidth,\n        directionalHint: directionalHint,\n        directionalHintForRTL: directionalHintForRTL,\n        gapSpace: gapSpace,\n        coverTarget: coverTarget,\n        doNotLayer: doNotLayer,\n        className: css('ms-ContextualMenu-Callout', calloutProps && calloutProps.className),\n        setInitialFocus: shouldFocusOnMount,\n        onDismiss: props.onDismiss || menuContext.onDismiss,\n        onScroll: onScroll,\n        bounds: bounds,\n        directionalHintFixed: directionalHintFixed,\n        alignTargetEdge: alignTargetEdge,\n        hidden: props.hidden || menuContext.hidden,\n        ref: forwardedRef\n      }), React.createElement(\"div\", {\n        style: contextMenuStyle,\n        ref: hostElement,\n        id: id,\n        className: classNames.container,\n        tabIndex: shouldFocusOnContainer ? 0 : -1,\n        onKeyDown: onMenuKeyDown,\n        onKeyUp: onKeyUp,\n        onFocusCapture: onMenuFocusCapture,\n        \"aria-label\": ariaLabel,\n        \"aria-labelledby\": labelElementId,\n        role: 'menu'\n      }, title && React.createElement(\"div\", {\n        className: classNames.title\n      }, \" \", title, \" \"), items && items.length ? renderFocusZone(onRenderMenuList({\n        ariaLabel: ariaLabel,\n        items: items,\n        totalItemCount: totalItemCount_1,\n        hasCheckmarks: hasCheckmarks,\n        hasIcons: hasIcons,\n        defaultMenuItemRenderer: function (item) {\n          return defaultMenuItemRenderer(item, classNames);\n        },\n        labelElementId: labelElementId\n      }, function (menuListProps, defaultRender) {\n        return onDefaultRenderMenuList(menuListProps, classNames, defaultRender);\n      }), adjustedFocusZoneProps) : null, submenuProps && onRenderSubMenu(submenuProps, onDefaultRenderSubMenu)));\n    });\n  } else {\n    return null;\n  } //#endregion\n\n}), function (prevProps, newProps) {\n  if (!newProps.shouldUpdateWhenHidden && prevProps.hidden && newProps.hidden) {\n    // Do not update when hidden.\n    return true;\n  }\n\n  return shallowCompare(prevProps, newProps);\n});\nContextualMenuBase.displayName = 'ContextualMenuBase';\n/**\n * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\n */\n\nfunction isAltOrMeta(ev) {\n  // eslint-disable-next-line deprecation/deprecation\n  return ev.which === KeyCodes.alt || ev.key === 'Meta';\n}\n\nfunction onItemMouseDown(item, ev) {\n  var _a;\n\n  (_a = item.onMouseDown) === null || _a === void 0 ? void 0 : _a.call(item, item, ev);\n}\n\nfunction onDefaultRenderSubMenu(subMenuProps, defaultRender) {\n  throw Error('ContextualMenuBase: onRenderSubMenu callback is null or undefined. ' + 'Please ensure to set `onRenderSubMenu` property either manually or with `styled` helper.');\n}\n/**\n * Returns the item that matches a given key if any.\n * @param key - The key of the item to match\n * @param items - The items to look for the key\n */\n\n\nfunction findItemByKeyFromItems(key, items) {\n  for (var _i = 0, items_3 = items; _i < items_3.length; _i++) {\n    var item = items_3[_i];\n\n    if (item.itemType === ContextualMenuItemType.Section && item.sectionProps) {\n      var match = findItemByKeyFromItems(key, item.sectionProps.items);\n\n      if (match) {\n        return match;\n      }\n    } else if (item.key && item.key === key) {\n      return item;\n    }\n  }\n}\n\nfunction getOnClickWithOverrideTarget(onClick, target) {\n  return onClick ? function (ev, item) {\n    overrideTarget(ev, target);\n    return onClick(ev, item);\n  } : onClick;\n}\n\nfunction overrideTarget(ev, target) {\n  if (ev && target) {\n    ev.persist();\n\n    if (target instanceof Event) {\n      ev.target = target.target;\n    } else if (target instanceof Element) {\n      ev.target = target;\n    }\n  }\n}","map":{"version":3,"sources":["/home/npr/Downloads/Final FrontEnd (2)/node_modules/@fluentui/react/lib/components/src/components/ContextualMenu/ContextualMenu.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { ContextualMenuItemType } from './ContextualMenu.types';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { FocusZone, FocusZoneDirection, FocusZoneTabbableElements } from '../../FocusZone';\nimport {\n  divProperties,\n  getNativeProps,\n  shallowCompare,\n  Async,\n  assign,\n  classNamesFunction,\n  css,\n  getFirstFocusable,\n  getLastFocusable,\n  getRTL,\n  KeyCodes,\n  shouldWrapFocus,\n  isIOS,\n  isMac,\n  memoizeFunction,\n  getPropsWithDefaults,\n  getDocument,\n} from '../../Utilities';\nimport { hasSubmenu, getIsChecked, isItemDisabled } from '../../utilities/contextualMenu/index';\nimport { Callout } from '../../Callout';\nimport { ContextualMenuItem } from './ContextualMenuItem';\nimport {\n  ContextualMenuSplitButton,\n  ContextualMenuButton,\n  ContextualMenuAnchor,\n} from './ContextualMenuItemWrapper/index';\nimport { concatStyleSetsWithProps } from '../../Styling';\nimport { getItemStyles } from './ContextualMenu.classNames';\nimport { useTarget, usePrevious, useAsync, useWarnings, useId, Target } from '@fluentui/react-hooks';\nimport { useResponsiveMode, ResponsiveMode } from '../../ResponsiveMode';\nimport { MenuContext } from '../../utilities/MenuContext/index';\nimport type {\n  IContextualMenuProps,\n  IContextualMenuItem,\n  IContextualMenuListProps,\n  IContextualMenuStyleProps,\n  IContextualMenuStyles,\n  IContextualMenuItemRenderProps,\n} from './ContextualMenu.types';\nimport type { IFocusZoneProps } from '../../FocusZone';\nimport type { IMenuItemClassNames, IContextualMenuClassNames } from './ContextualMenu.classNames';\nimport type { IRenderFunction, IStyleFunctionOrObject } from '../../Utilities';\nimport type { ICalloutContentStyleProps, ICalloutContentStyles } from '../../Callout';\nimport type { IProcessedStyleSet } from '../../Styling';\nimport type { IContextualMenuItemStyleProps, IContextualMenuItemStyles } from './ContextualMenuItem.types';\nimport type { IPopupRestoreFocusParams } from '../../Popup';\n\nconst getClassNames = classNamesFunction<IContextualMenuStyleProps, IContextualMenuStyles>();\nconst getContextualMenuItemClassNames = classNamesFunction<IContextualMenuItemStyleProps, IContextualMenuItemStyles>();\n\n// The default ContextualMenu properties have no items and beak, the default submenu direction is right and top.\nconst DEFAULT_PROPS: Partial<IContextualMenuProps> = {\n  items: [],\n  shouldFocusOnMount: true,\n  gapSpace: 0,\n  directionalHint: DirectionalHint.bottomAutoEdge,\n  beakWidth: 16,\n};\n\nexport function getSubmenuItems(\n  item: IContextualMenuItem,\n  options?: {\n    target?: Target;\n  },\n): IContextualMenuItem[] | undefined {\n  const target = options?.target;\n\n  // eslint-disable-next-line deprecation/deprecation\n  const items = item.subMenuProps ? item.subMenuProps.items : item.items;\n\n  if (items) {\n    const overrideItems: typeof items = [];\n\n    for (const subItem of items) {\n      if (subItem.preferMenuTargetAsEventTarget) {\n        // For sub-items which need an overridden target, intercept `onClick`\n        const { onClick, ...contextItem } = subItem;\n\n        overrideItems.push({\n          ...contextItem,\n          onClick: getOnClickWithOverrideTarget(onClick, target),\n        });\n      } else {\n        overrideItems.push(subItem);\n      }\n    }\n\n    return overrideItems;\n  }\n}\n\n/**\n * Returns true if a list of menu items can contain a checkbox\n */\nexport function canAnyMenuItemsCheck(items: IContextualMenuItem[]): boolean {\n  return items.some(item => {\n    if (item.canCheck) {\n      return true;\n    }\n\n    // If the item is a section, check if any of the items in the section can check.\n    if (item.sectionProps && item.sectionProps.items.some(submenuItem => submenuItem.canCheck === true)) {\n      return true;\n    }\n\n    return false;\n  });\n}\n\nconst NavigationIdleDelay = 250; /* ms */\n\nconst COMPONENT_NAME = 'ContextualMenu';\n\nconst _getMenuItemStylesFunction = memoizeFunction(\n  (\n    ...styles: (IStyleFunctionOrObject<IContextualMenuItemStyleProps, IContextualMenuItemStyles> | undefined)[]\n  ): IStyleFunctionOrObject<IContextualMenuItemStyleProps, IContextualMenuItemStyles> => {\n    return (styleProps: IContextualMenuItemStyleProps) =>\n      concatStyleSetsWithProps(styleProps, getItemStyles, ...styles);\n  },\n);\n\n//#region Custom hooks\nfunction useVisibility(props: IContextualMenuProps, targetWindow: Window | undefined) {\n  const { hidden = false, onMenuDismissed, onMenuOpened } = props;\n  const previousHidden = usePrevious(hidden);\n\n  const onMenuOpenedRef = React.useRef(onMenuOpened);\n  const onMenuClosedRef = React.useRef(onMenuDismissed);\n  const propsRef = React.useRef(props);\n\n  onMenuOpenedRef.current = onMenuOpened;\n  onMenuClosedRef.current = onMenuDismissed;\n  propsRef.current = props;\n\n  React.useEffect(() => {\n    // Don't issue dismissed callbacks on initial mount\n    if (hidden && previousHidden === false) {\n      onMenuClosedRef.current?.(propsRef.current);\n    } else if (!hidden && previousHidden !== false) {\n      onMenuOpenedRef.current?.(propsRef.current);\n    }\n  }, [hidden, previousHidden]);\n\n  // Issue onDismissedCallback on unmount\n  React.useEffect(() => () => onMenuClosedRef.current?.(propsRef.current), []);\n}\n\nfunction useSubMenuState(\n  { hidden, items, theme, className, id, target: menuTarget }: IContextualMenuProps,\n  dismiss: () => void,\n) {\n  const [expandedMenuItemKey, setExpandedMenuItemKey] = React.useState<string>();\n  const [submenuTarget, setSubmenuTarget] = React.useState<HTMLElement>();\n  /** True if the menu was expanded by mouse click OR hover (as opposed to by keyboard) */\n  const [expandedByMouseClick, setExpandedByMouseClick] = React.useState<boolean>();\n  const subMenuId = useId(COMPONENT_NAME, id);\n\n  const closeSubMenu = React.useCallback(() => {\n    setExpandedByMouseClick(undefined);\n    setExpandedMenuItemKey(undefined);\n    setSubmenuTarget(undefined);\n  }, []);\n\n  const openSubMenu = React.useCallback(\n    ({ key: submenuItemKey }: IContextualMenuItem, target: HTMLElement, openedByMouseClick?: boolean) => {\n      if (expandedMenuItemKey === submenuItemKey) {\n        return;\n      }\n\n      target.focus();\n\n      setExpandedByMouseClick(openedByMouseClick);\n      setExpandedMenuItemKey(submenuItemKey);\n      setSubmenuTarget(target);\n    },\n    [expandedMenuItemKey],\n  );\n\n  React.useEffect(() => {\n    if (hidden) {\n      closeSubMenu();\n    }\n  }, [hidden, closeSubMenu]);\n\n  const onSubMenuDismiss = useOnSubmenuDismiss(dismiss, closeSubMenu);\n\n  const getSubmenuProps = (): IContextualMenuProps | null => {\n    const item = findItemByKeyFromItems(expandedMenuItemKey!, items);\n    let submenuProps: IContextualMenuProps | null = null;\n\n    if (item) {\n      submenuProps = {\n        items: getSubmenuItems(item)!,\n        target: submenuTarget,\n        onDismiss: onSubMenuDismiss,\n        isSubMenu: true,\n        id: subMenuId,\n        shouldFocusOnMount: true,\n        shouldFocusOnContainer: expandedByMouseClick,\n        directionalHint: getRTL(theme) ? DirectionalHint.leftTopEdge : DirectionalHint.rightTopEdge,\n        className,\n        gapSpace: 0,\n        isBeakVisible: false,\n      };\n\n      if (item.subMenuProps) {\n        assign(submenuProps, item.subMenuProps);\n      }\n\n      if (item.preferMenuTargetAsEventTarget) {\n        const { onItemClick } = item;\n\n        submenuProps.onItemClick = getOnClickWithOverrideTarget(onItemClick, menuTarget);\n      }\n    }\n    return submenuProps;\n  };\n\n  return [expandedMenuItemKey, openSubMenu, getSubmenuProps, onSubMenuDismiss] as const;\n}\n\nfunction useShouldUpdateFocusOnMouseMove({ delayUpdateFocusOnHover, hidden }: IContextualMenuProps) {\n  const shouldUpdateFocusOnMouseEvent = React.useRef<boolean>(!delayUpdateFocusOnHover);\n  const gotMouseMove = React.useRef<boolean>(false);\n\n  React.useEffect(() => {\n    shouldUpdateFocusOnMouseEvent.current = !delayUpdateFocusOnHover;\n    gotMouseMove.current = hidden ? false : !delayUpdateFocusOnHover && gotMouseMove.current;\n  }, [delayUpdateFocusOnHover, hidden]);\n\n  const onMenuFocusCapture = React.useCallback(() => {\n    if (delayUpdateFocusOnHover) {\n      shouldUpdateFocusOnMouseEvent.current = true;\n    }\n  }, [delayUpdateFocusOnHover]);\n\n  return [shouldUpdateFocusOnMouseEvent, gotMouseMove, onMenuFocusCapture] as const;\n}\n\nfunction usePreviousActiveElement({ hidden, onRestoreFocus }: IContextualMenuProps, targetWindow: Window | undefined) {\n  const previousActiveElement = React.useRef<undefined | HTMLElement>();\n\n  const tryFocusPreviousActiveElement = React.useCallback(\n    (options: IPopupRestoreFocusParams) => {\n      if (onRestoreFocus) {\n        onRestoreFocus(options);\n      } else if (options?.documentContainsFocus) {\n        // Make sure that the focus method actually exists\n        // In some cases the object might exist but not be a real element.\n        // This is primarily for IE 11 and should be removed once IE 11 is no longer in use.\n        previousActiveElement.current?.focus?.();\n      }\n    },\n    [onRestoreFocus],\n  );\n\n  // eslint-disable-next-line no-restricted-properties\n  React.useLayoutEffect(() => {\n    if (!hidden) {\n      previousActiveElement.current = targetWindow?.document.activeElement as HTMLElement;\n    } else if (previousActiveElement.current) {\n      tryFocusPreviousActiveElement({\n        originalElement: previousActiveElement.current,\n        containsFocus: true,\n        documentContainsFocus: getDocument()?.hasFocus() || false,\n      });\n\n      previousActiveElement.current = undefined;\n    }\n  }, [hidden, targetWindow?.document.activeElement, tryFocusPreviousActiveElement]);\n\n  return [tryFocusPreviousActiveElement] as const;\n}\n\nfunction useKeyHandlers(\n  {\n    theme,\n    isSubMenu,\n    focusZoneProps: { checkForNoWrap, direction: focusZoneDirection = FocusZoneDirection.vertical } = {},\n  }: IContextualMenuProps,\n  dismiss: (ev?: any, dismissAll?: boolean | undefined) => void | undefined,\n  hostElement: React.RefObject<HTMLDivElement>,\n  openSubMenu: (submenuItemKey: IContextualMenuItem, target: HTMLElement, openedByMouseClick?: boolean) => void,\n) {\n  /** True if the most recent keydown event was for alt (option) or meta (command). */\n  const lastKeyDownWasAltOrMeta = React.useRef<boolean | undefined>();\n\n  /**\n   * Calls `shouldHandleKey` to determine whether the keyboard event should be handled;\n   * if so, stops event propagation and dismisses menu(s).\n   * @param ev - The keyboard event.\n   * @param shouldHandleKey - Returns whether we should handle this keyboard event.\n   * @param dismissAllMenus - If true, dismiss all menus. Otherwise, dismiss only the current menu.\n   * Only does anything if `shouldHandleKey` returns true.\n   * @returns Whether the event was handled.\n   */\n  const keyHandler = (\n    ev: React.KeyboardEvent<HTMLElement>,\n    shouldHandleKey: (ev: React.KeyboardEvent<HTMLElement>) => boolean,\n    dismissAllMenus?: boolean,\n  ): boolean => {\n    let handled = false;\n\n    if (shouldHandleKey(ev)) {\n      dismiss(ev, dismissAllMenus);\n      ev.preventDefault();\n      ev.stopPropagation();\n      handled = true;\n    }\n\n    return handled;\n  };\n\n  /**\n   * Checks if the submenu should be closed\n   */\n  const shouldCloseSubMenu = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    const submenuCloseKey = getRTL(theme) ? KeyCodes.right : KeyCodes.left;\n\n    // eslint-disable-next-line deprecation/deprecation\n    if (ev.which !== submenuCloseKey || !isSubMenu) {\n      return false;\n    }\n\n    return !!(\n      focusZoneDirection === FocusZoneDirection.vertical ||\n      (checkForNoWrap && !shouldWrapFocus(ev.target as HTMLElement, 'data-no-horizontal-wrap'))\n    );\n  };\n\n  const shouldHandleKeyDown = (ev: React.KeyboardEvent<HTMLElement>) => {\n    return (\n      // eslint-disable-next-line deprecation/deprecation\n      ev.which === KeyCodes.escape ||\n      shouldCloseSubMenu(ev) ||\n      // eslint-disable-next-line deprecation/deprecation\n      (ev.which === KeyCodes.up && (ev.altKey || ev.metaKey))\n    );\n  };\n\n  const onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    // Take note if we are processing an alt (option) or meta (command) keydown.\n    // See comment in shouldHandleKeyUp for reasoning.\n    lastKeyDownWasAltOrMeta.current = isAltOrMeta(ev);\n\n    // On Mac, pressing escape dismisses all levels of native context menus\n    // eslint-disable-next-line deprecation/deprecation\n    const dismissAllMenus = ev.which === KeyCodes.escape && (isMac() || isIOS());\n\n    return keyHandler(ev, shouldHandleKeyDown, dismissAllMenus);\n  };\n\n  /**\n   * We close the menu on key up only if ALL of the following are true:\n   * - Most recent key down was alt or meta (command)\n   * - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\n   *   expand/collapse the menu)\n   * - We're not on a Mac (or iOS)\n   *\n   * This is because on Windows, pressing alt moves focus to the application menu bar or similar,\n   * closing any open context menus. There is not a similar behavior on Macs.\n   */\n  const shouldHandleKeyUp = (ev: React.KeyboardEvent<HTMLElement>) => {\n    const keyPressIsAltOrMetaAlone = lastKeyDownWasAltOrMeta.current && isAltOrMeta(ev);\n    lastKeyDownWasAltOrMeta.current = false;\n    return !!keyPressIsAltOrMetaAlone && !(isIOS() || isMac());\n  };\n\n  const onKeyUp = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    return keyHandler(ev, shouldHandleKeyUp, true /* dismissAllMenus */);\n  };\n\n  const onMenuKeyDown = (ev: React.KeyboardEvent<HTMLElement>) => {\n    // Mark as handled if onKeyDown returns true (for handling collapse cases)\n    // or if we are attempting to expand a submenu\n    const handled = onKeyDown(ev);\n\n    if (handled || !hostElement.current) {\n      return;\n    }\n\n    // If we have a modifier key being pressed, we do not want to move focus.\n    // Otherwise, handle up and down keys.\n    const hasModifier = !!(ev.altKey || ev.metaKey);\n    // eslint-disable-next-line deprecation/deprecation\n    const isUp = ev.which === KeyCodes.up;\n    // eslint-disable-next-line deprecation/deprecation\n    const isDown = ev.which === KeyCodes.down;\n    if (!hasModifier && (isUp || isDown)) {\n      const elementToFocus = isUp\n        ? getLastFocusable(hostElement.current, hostElement.current.lastChild as HTMLElement, true)\n        : getFirstFocusable(hostElement.current, hostElement.current.firstChild as HTMLElement, true);\n\n      if (elementToFocus) {\n        elementToFocus.focus();\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n\n  const onItemKeyDown = (item: any, ev: React.KeyboardEvent<HTMLElement>): void => {\n    const openKey = getRTL(theme) ? KeyCodes.left : KeyCodes.right;\n\n    if (\n      !item.disabled &&\n      // eslint-disable-next-line deprecation/deprecation\n      (ev.which === openKey || ev.which === KeyCodes.enter || (ev.which === KeyCodes.down && (ev.altKey || ev.metaKey)))\n    ) {\n      openSubMenu(item, ev.currentTarget as HTMLElement, false);\n      ev.preventDefault();\n    }\n  };\n\n  return [onKeyDown, onKeyUp, onMenuKeyDown, onItemKeyDown] as const;\n}\n\nfunction useScrollHandler(asyncTracker: Async) {\n  const isScrollIdle = React.useRef<boolean>(true);\n  const scrollIdleTimeoutId = React.useRef<number | undefined>();\n\n  /**\n   * Scroll handler for the callout to make sure the mouse events\n   * for updating focus are not interacting during scroll\n   */\n  const onScroll = (): void => {\n    if (!isScrollIdle.current && scrollIdleTimeoutId.current !== undefined) {\n      asyncTracker.clearTimeout(scrollIdleTimeoutId.current);\n      scrollIdleTimeoutId.current = undefined;\n    } else {\n      isScrollIdle.current = false;\n    }\n\n    scrollIdleTimeoutId.current = asyncTracker.setTimeout(() => {\n      isScrollIdle.current = true;\n    }, NavigationIdleDelay);\n  };\n\n  return [onScroll, isScrollIdle] as const;\n}\n\nfunction useOnSubmenuDismiss(dismiss: (ev?: any, dismissAll?: boolean) => void, closeSubMenu: () => void) {\n  const isMountedRef = React.useRef(false);\n  React.useEffect(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n\n  /**\n   * This function is called ASYNCHRONOUSLY, and so there is a chance it is called\n   * after the component is unmounted. The isMountedRef is added to prevent\n   * from calling setState() after unmount. Do NOT copy this pattern in synchronous\n   * code.\n   */\n  const onSubMenuDismiss = (ev?: any, dismissAll?: boolean): void => {\n    if (dismissAll) {\n      dismiss(ev, dismissAll);\n    } else if (isMountedRef.current) {\n      closeSubMenu();\n    }\n  };\n\n  return onSubMenuDismiss;\n}\n\nfunction useSubmenuEnterTimer({ subMenuHoverDelay = NavigationIdleDelay }: IContextualMenuProps, asyncTracker: Async) {\n  const enterTimerRef = React.useRef<number | undefined>(undefined);\n\n  const cancelSubMenuTimer = () => {\n    if (enterTimerRef.current !== undefined) {\n      asyncTracker.clearTimeout(enterTimerRef.current);\n      enterTimerRef.current = undefined;\n    }\n  };\n\n  const startSubmenuTimer = (onTimerExpired: () => void) => {\n    enterTimerRef.current = asyncTracker.setTimeout(() => {\n      onTimerExpired();\n      cancelSubMenuTimer();\n    }, subMenuHoverDelay);\n  };\n\n  return [cancelSubMenuTimer, startSubmenuTimer, enterTimerRef as React.RefObject<number | undefined>] as const;\n}\n\nfunction useMouseHandlers(\n  props: IContextualMenuProps,\n  isScrollIdle: React.MutableRefObject<boolean>,\n  subMenuEntryTimer: React.RefObject<number | undefined>,\n  targetWindow: Window | undefined,\n  shouldUpdateFocusOnMouseEvent: React.MutableRefObject<boolean>,\n  gotMouseMove: React.MutableRefObject<boolean>,\n  expandedMenuItemKey: string | undefined,\n  hostElement: React.RefObject<HTMLDivElement>,\n  startSubmenuTimer: (onTimerExpired: () => void) => void,\n  cancelSubMenuTimer: () => void,\n  openSubMenu: (submenuItemKey: IContextualMenuItem, target: HTMLElement, openedByMouseClick?: boolean) => void,\n  onSubMenuDismiss: (ev?: any, dismissAll?: boolean) => void,\n  dismiss: (ev?: any, dismissAll?: boolean) => void,\n) {\n  const { target: menuTarget } = props;\n\n  const onItemMouseEnterBase = (item: any, ev: React.MouseEvent<HTMLElement>, target?: HTMLElement): void => {\n    if (shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    updateFocusOnMouseEvent(item, ev, target);\n  };\n\n  const onItemMouseMoveBase = (item: any, ev: React.MouseEvent<HTMLElement>, target: HTMLElement): void => {\n    const targetElement = ev.currentTarget as HTMLElement;\n\n    // Always do this check to make sure we record a mouseMove if needed (even if we are timed out)\n    if (shouldUpdateFocusOnMouseEvent.current) {\n      gotMouseMove.current = true;\n    } else {\n      return;\n    }\n\n    if (\n      !isScrollIdle.current ||\n      subMenuEntryTimer.current !== undefined ||\n      targetElement === (targetWindow?.document.activeElement as HTMLElement)\n    ) {\n      return;\n    }\n\n    updateFocusOnMouseEvent(item, ev, target);\n  };\n\n  const shouldIgnoreMouseEvent = (): boolean => {\n    return !isScrollIdle.current || !gotMouseMove.current;\n  };\n\n  const onMouseItemLeave = (item: any, ev: React.MouseEvent<HTMLElement>): void => {\n    if (shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    cancelSubMenuTimer();\n\n    if (expandedMenuItemKey !== undefined) {\n      return;\n    }\n\n    /**\n     * IE11 focus() method forces parents to scroll to top of element.\n     * Edge and IE expose a setActive() function for focusable divs that\n     * sets the page focus but does not scroll the parent element.\n     */\n    if ((hostElement.current as any).setActive) {\n      try {\n        (hostElement.current as any).setActive();\n      } catch (e) {\n        /* no-op */\n      }\n    } else {\n      hostElement.current?.focus();\n    }\n  };\n\n  /**\n   * Handles updating focus when mouseEnter or mouseMove fire.\n   * As part of updating focus, This function will also update\n   * the expand/collapse state accordingly.\n   */\n  const updateFocusOnMouseEvent = (\n    item: IContextualMenuItem,\n    ev: React.MouseEvent<HTMLElement>,\n    target?: HTMLElement,\n  ) => {\n    const targetElement = target ? target : (ev.currentTarget as HTMLElement);\n\n    if (item.key === expandedMenuItemKey) {\n      return;\n    }\n\n    cancelSubMenuTimer();\n\n    // If the menu is not expanded we can update focus without any delay\n    if (expandedMenuItemKey === undefined) {\n      targetElement.focus();\n    }\n\n    // Delay updating expanding/dismissing the submenu\n    // and only set focus if we have not already done so\n    if (hasSubmenu(item)) {\n      ev.stopPropagation();\n      startSubmenuTimer(() => {\n        targetElement.focus();\n        openSubMenu(item, targetElement, true);\n      });\n    } else {\n      startSubmenuTimer(() => {\n        onSubMenuDismiss(ev);\n        targetElement.focus();\n      });\n    }\n  };\n\n  const onItemClick = (\n    item: IContextualMenuItem,\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ): void => {\n    onItemClickBase(item, ev, ev.currentTarget as HTMLElement);\n  };\n\n  const onItemClickBase = (\n    item: IContextualMenuItem,\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n    target: HTMLElement,\n  ): void => {\n    const items = getSubmenuItems(item);\n\n    // Cancel an async menu item hover timeout action from being taken and instead\n    // just trigger the click event instead.\n    cancelSubMenuTimer();\n\n    if (!hasSubmenu(item) && (!items || !items.length)) {\n      // This is an item without a menu. Click it.\n      executeItemClick(item, ev);\n    } else {\n      if (item.key !== expandedMenuItemKey) {\n        // This has a collapsed sub menu. Expand it.\n        openSubMenu(\n          item,\n          target,\n          // When Edge + Narrator are used together (regardless of if the button is in a form or not), pressing\n          // \"Enter\" fires this method and not _onMenuKeyDown. Checking ev.nativeEvent.detail differentiates\n          // between a real click event and a keypress event (detail should be the number of mouse clicks).\n          // ...Plot twist! For a real click event in IE 11, detail is always 0 (Edge sets it properly to 1).\n          // So we also check the pointerType property, which both Edge and IE set to \"mouse\" for real clicks\n          // and \"\" for pressing \"Enter\" with Narrator on.\n          ev.nativeEvent.detail !== 0 || (ev.nativeEvent as PointerEvent).pointerType === 'mouse',\n        );\n      }\n    }\n\n    ev.stopPropagation();\n    ev.preventDefault();\n  };\n\n  const onAnchorClick = (item: IContextualMenuItem, ev: React.MouseEvent<HTMLElement>) => {\n    executeItemClick(item, ev);\n    ev.stopPropagation();\n  };\n\n  const executeItemClick = (\n    item: IContextualMenuItem,\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ): void => {\n    if (item.disabled || item.isDisabled) {\n      return;\n    }\n\n    if (item.preferMenuTargetAsEventTarget) {\n      overrideTarget(ev, menuTarget);\n    }\n\n    let shouldDismiss = false;\n    if (item.onClick) {\n      shouldDismiss = !!item.onClick(ev, item);\n    } else if (props.onItemClick) {\n      shouldDismiss = !!props.onItemClick(ev, item);\n    }\n\n    if (shouldDismiss || !ev.defaultPrevented) {\n      dismiss(ev, true);\n    }\n  };\n\n  return [\n    onItemMouseEnterBase,\n    onItemMouseMoveBase,\n    onMouseItemLeave,\n    onItemClick,\n    onAnchorClick,\n    executeItemClick,\n    onItemClickBase,\n  ] as const;\n}\n//#endregion\n\nexport const ContextualMenuBase: React.FunctionComponent<IContextualMenuProps> = React.memo(\n  React.forwardRef<HTMLDivElement, IContextualMenuProps>((propsWithoutDefaults, forwardedRef) => {\n    const { ref, ...props } = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n    const hostElement = React.useRef<HTMLDivElement>(null);\n    const asyncTracker = useAsync();\n    const menuId = useId(COMPONENT_NAME, props.id);\n\n    useWarnings({\n      name: COMPONENT_NAME,\n      props,\n      deprecations: {\n        getMenuClassNames: 'styles',\n      },\n    });\n\n    const dismiss = (ev?: any, dismissAll?: boolean) => props.onDismiss?.(ev, dismissAll);\n    const [targetRef, targetWindow] = useTarget(props.target, hostElement);\n    const [tryFocusPreviousActiveElement] = usePreviousActiveElement(props, targetWindow);\n    const [expandedMenuItemKey, openSubMenu, getSubmenuProps, onSubMenuDismiss] = useSubMenuState(props, dismiss);\n    const [shouldUpdateFocusOnMouseEvent, gotMouseMove, onMenuFocusCapture] = useShouldUpdateFocusOnMouseMove(props);\n    const [onScroll, isScrollIdle] = useScrollHandler(asyncTracker);\n    const [cancelSubMenuTimer, startSubmenuTimer, subMenuEntryTimer] = useSubmenuEnterTimer(props, asyncTracker);\n\n    const responsiveMode = useResponsiveMode(hostElement, props.responsiveMode);\n\n    useVisibility(props, targetWindow);\n\n    const [onKeyDown, onKeyUp, onMenuKeyDown, onItemKeyDown] = useKeyHandlers(props, dismiss, hostElement, openSubMenu);\n    const [\n      onItemMouseEnterBase,\n      onItemMouseMoveBase,\n      onMouseItemLeave,\n      onItemClick,\n      onAnchorClick,\n      executeItemClick,\n      onItemClickBase,\n    ] = useMouseHandlers(\n      props,\n      isScrollIdle,\n      subMenuEntryTimer,\n      targetWindow,\n      shouldUpdateFocusOnMouseEvent,\n      gotMouseMove,\n      expandedMenuItemKey,\n      hostElement,\n      startSubmenuTimer,\n      cancelSubMenuTimer,\n      openSubMenu,\n      onSubMenuDismiss,\n      dismiss,\n    );\n\n    //#region Render helpers\n\n    const onDefaultRenderMenuList = (\n      menuListProps: IContextualMenuListProps,\n      // eslint-disable-next-line deprecation/deprecation\n      menuClassNames: IProcessedStyleSet<IContextualMenuStyles> | IContextualMenuClassNames,\n      defaultRender?: IRenderFunction<IContextualMenuListProps>,\n    ): JSX.Element => {\n      let indexCorrection = 0;\n      const { items, totalItemCount, hasCheckmarks, hasIcons } = menuListProps;\n\n      return (\n        <ul className={menuClassNames.list} onKeyDown={onKeyDown} onKeyUp={onKeyUp} role={'presentation'}>\n          {items.map((item, index) => {\n            const menuItem = renderMenuItem(\n              item,\n              index,\n              indexCorrection,\n              totalItemCount,\n              hasCheckmarks,\n              hasIcons,\n              menuClassNames,\n            );\n            if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n              const indexIncrease = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n              indexCorrection += indexIncrease;\n            }\n            return menuItem;\n          })}\n        </ul>\n      );\n    };\n\n    const renderFocusZone = (children: JSX.Element | null, adjustedFocusZoneProps: IFocusZoneProps): JSX.Element => {\n      const { focusZoneAs: ChildrenRenderer = FocusZone } = props;\n      return <ChildrenRenderer {...adjustedFocusZoneProps}>{children}</ChildrenRenderer>;\n    };\n\n    /**\n     * !!!IMPORTANT!!! Avoid mutating `item: IContextualMenuItem` argument. It will\n     * cause the menu items to always re-render because the component update is based on shallow comparison.\n     */\n    const renderMenuItem = (\n      item: IContextualMenuItem,\n      index: number,\n      focusableElementIndex: number,\n      totalItemCount: number,\n      hasCheckmarks: boolean,\n      hasIcons: boolean,\n      // eslint-disable-next-line deprecation/deprecation\n      menuClassNames: IProcessedStyleSet<IContextualMenuStyles> | IContextualMenuClassNames,\n    ): JSX.Element => {\n      const renderedItems: React.ReactNode[] = [];\n      const iconProps = item.iconProps || { iconName: 'None' };\n      const {\n        getItemClassNames, // eslint-disable-line deprecation/deprecation\n        itemProps,\n      } = item;\n      const styles = itemProps ? itemProps.styles : undefined;\n\n      // We only send a dividerClassName when the item to be rendered is a divider.\n      // For all other cases, the default divider style is used.\n      const dividerClassName = item.itemType === ContextualMenuItemType.Divider ? item.className : undefined;\n      const subMenuIconClassName = item.submenuIconProps ? item.submenuIconProps.className : '';\n\n      // eslint-disable-next-line deprecation/deprecation\n      let itemClassNames: IMenuItemClassNames;\n\n      // IContextualMenuItem#getItemClassNames for backwards compatibility\n      // otherwise uses mergeStyles for class names.\n      if (getItemClassNames) {\n        itemClassNames = getItemClassNames(\n          props.theme!,\n          isItemDisabled(item),\n          expandedMenuItemKey === item.key,\n          !!getIsChecked(item),\n          !!item.href,\n          iconProps.iconName !== 'None',\n          item.className,\n          dividerClassName,\n          iconProps.className,\n          subMenuIconClassName,\n          item.primaryDisabled,\n        );\n      } else {\n        const itemStyleProps: IContextualMenuItemStyleProps = {\n          theme: props.theme!,\n          disabled: isItemDisabled(item),\n          expanded: expandedMenuItemKey === item.key,\n          checked: !!getIsChecked(item),\n          isAnchorLink: !!item.href,\n          knownIcon: iconProps.iconName !== 'None',\n          itemClassName: item.className,\n          dividerClassName,\n          iconClassName: iconProps.className,\n          subMenuClassName: subMenuIconClassName,\n          primaryDisabled: item.primaryDisabled,\n        };\n\n        // We need to generate default styles then override if styles are provided\n        // since the ContextualMenu currently handles item classNames.\n        itemClassNames = getContextualMenuItemClassNames(\n          _getMenuItemStylesFunction(menuClassNames.subComponentStyles?.menuItem, styles),\n          itemStyleProps,\n        );\n      }\n\n      // eslint-disable-next-line deprecation/deprecation\n      if (item.text === '-' || item.name === '-') {\n        item.itemType = ContextualMenuItemType.Divider;\n      }\n      switch (item.itemType) {\n        case ContextualMenuItemType.Divider:\n          renderedItems.push(renderSeparator(index, itemClassNames));\n          break;\n        case ContextualMenuItemType.Header:\n          renderedItems.push(renderSeparator(index, itemClassNames));\n          const headerItem = renderHeaderMenuItem(item, itemClassNames, menuClassNames, index, hasCheckmarks, hasIcons);\n          renderedItems.push(renderListItem(headerItem, item.key || index, itemClassNames, item.title));\n          break;\n        case ContextualMenuItemType.Section:\n          renderedItems.push(renderSectionItem(item, itemClassNames, menuClassNames, index, hasCheckmarks, hasIcons));\n          break;\n        default:\n          const menuItem = renderNormalItem(\n            item,\n            itemClassNames,\n            index,\n            focusableElementIndex,\n            totalItemCount,\n            hasCheckmarks,\n            hasIcons,\n          );\n          renderedItems.push(renderListItem(menuItem, item.key || index, itemClassNames, item.title));\n          break;\n      }\n\n      // Since multiple nodes *could* be rendered, wrap them all in a fragment with this item's key.\n      // This ensures the reconciler handles multi-item output per-node correctly and does not re-mount content.\n      return <React.Fragment key={item.key}>{renderedItems}</React.Fragment>;\n    };\n\n    const defaultMenuItemRenderer = (\n      item: IContextualMenuItemRenderProps,\n      // eslint-disable-next-line deprecation/deprecation\n      menuClassNames: IProcessedStyleSet<IContextualMenuStyles> | IContextualMenuClassNames,\n    ): React.ReactNode => {\n      const { index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons } = item;\n      return renderMenuItem(\n        item,\n        index,\n        focusableElementIndex,\n        totalItemCount,\n        hasCheckmarks,\n        hasIcons,\n        menuClassNames,\n      );\n    };\n\n    const renderSectionItem = (\n      sectionItem: IContextualMenuItem,\n      // eslint-disable-next-line deprecation/deprecation\n      itemClassNames: IMenuItemClassNames,\n      // eslint-disable-next-line deprecation/deprecation\n      menuClassNames: IProcessedStyleSet<IContextualMenuStyles> | IContextualMenuClassNames,\n      index: number,\n      hasCheckmarks: boolean,\n      hasIcons: boolean,\n    ) => {\n      const sectionProps = sectionItem.sectionProps;\n      if (!sectionProps) {\n        return;\n      }\n\n      let headerItem;\n      let groupProps;\n      if (sectionProps.title) {\n        let headerContextualMenuItem: IContextualMenuItem | undefined = undefined;\n        let ariaLabelledby = '';\n        if (typeof sectionProps.title === 'string') {\n          // Since title is a user-facing string, it needs to be stripped\n          // of whitespace in order to build a valid element ID\n          const id = menuId + sectionProps.title.replace(/\\s/g, '');\n          headerContextualMenuItem = {\n            key: `section-${sectionProps.title}-title`,\n            itemType: ContextualMenuItemType.Header,\n            text: sectionProps.title,\n            id: id,\n          };\n          ariaLabelledby = id;\n        } else {\n          const id = sectionProps.title.id || menuId + sectionProps.title.key.replace(/\\s/g, '');\n          headerContextualMenuItem = { ...sectionProps.title, id };\n          ariaLabelledby = id;\n        }\n\n        if (headerContextualMenuItem) {\n          groupProps = {\n            role: 'group',\n            'aria-labelledby': ariaLabelledby,\n          };\n          headerItem = renderHeaderMenuItem(\n            headerContextualMenuItem,\n            itemClassNames,\n            menuClassNames,\n            index,\n            hasCheckmarks,\n            hasIcons,\n          );\n        }\n      }\n\n      if (sectionProps.items && sectionProps.items.length > 0) {\n        return (\n          <li role=\"presentation\" key={sectionProps.key || sectionItem.key || `section-${index}`}>\n            <div {...groupProps}>\n              <ul className={menuClassNames.list} role=\"presentation\">\n                {sectionProps.topDivider && renderSeparator(index, itemClassNames, true, true)}\n                {headerItem && renderListItem(headerItem, sectionItem.key || index, itemClassNames, sectionItem.title)}\n                {sectionProps.items.map((contextualMenuItem, itemsIndex) =>\n                  renderMenuItem(\n                    contextualMenuItem,\n                    itemsIndex,\n                    itemsIndex,\n                    sectionProps.items.length,\n                    hasCheckmarks,\n                    hasIcons,\n                    menuClassNames,\n                  ),\n                )}\n                {sectionProps.bottomDivider && renderSeparator(index, itemClassNames, false, true)}\n              </ul>\n            </div>\n          </li>\n        );\n      }\n    };\n\n    const renderListItem = (\n      content: React.ReactNode,\n      key: string | number,\n      classNames: IMenuItemClassNames, // eslint-disable-line deprecation/deprecation\n      title?: string,\n    ) => {\n      return (\n        <li role=\"presentation\" title={title} key={key} className={classNames.item}>\n          {content}\n        </li>\n      );\n    };\n\n    const renderSeparator = (\n      index: number,\n      classNames: IMenuItemClassNames, // eslint-disable-line deprecation/deprecation\n      top?: boolean,\n      fromSection?: boolean,\n    ): React.ReactNode => {\n      if (fromSection || index > 0) {\n        return (\n          <li\n            role=\"separator\"\n            key={'separator-' + index + (top === undefined ? '' : top ? '-top' : '-bottom')}\n            className={classNames.divider}\n            aria-hidden=\"true\"\n          />\n        );\n      }\n      return null;\n    };\n\n    const renderNormalItem = (\n      item: IContextualMenuItem,\n      classNames: IMenuItemClassNames, // eslint-disable-line deprecation/deprecation\n      index: number,\n      focusableElementIndex: number,\n      totalItemCount: number,\n      hasCheckmarks: boolean,\n      hasIcons: boolean,\n    ): React.ReactNode => {\n      if (item.onRender) {\n        return item.onRender(\n          { 'aria-posinset': focusableElementIndex + 1, 'aria-setsize': totalItemCount, ...item },\n          dismiss,\n        );\n      }\n\n      const { contextualMenuItemAs } = props;\n\n      const commonProps = {\n        item,\n        classNames,\n        index,\n        focusableElementIndex,\n        totalItemCount,\n        hasCheckmarks,\n        hasIcons,\n        contextualMenuItemAs,\n        onItemMouseEnter: onItemMouseEnterBase,\n        onItemMouseLeave: onMouseItemLeave,\n        onItemMouseMove: onItemMouseMoveBase,\n        onItemMouseDown: onItemMouseDown,\n        executeItemClick: executeItemClick,\n        onItemKeyDown: onItemKeyDown,\n        expandedMenuItemKey,\n        openSubMenu,\n        dismissSubMenu: onSubMenuDismiss,\n        dismissMenu: dismiss,\n      } as const;\n\n      if (item.href) {\n        return <ContextualMenuAnchor {...commonProps} onItemClick={onAnchorClick} />;\n      }\n\n      if (item.split && hasSubmenu(item)) {\n        return (\n          <ContextualMenuSplitButton\n            {...commonProps}\n            onItemClick={onItemClick}\n            onItemClickBase={onItemClickBase}\n            onTap={cancelSubMenuTimer}\n          />\n        );\n      }\n\n      return <ContextualMenuButton {...commonProps} onItemClick={onItemClick} onItemClickBase={onItemClickBase} />;\n    };\n\n    const renderHeaderMenuItem = (\n      item: IContextualMenuItem,\n      // eslint-disable-next-line deprecation/deprecation\n      itemClassNames: IMenuItemClassNames,\n      // eslint-disable-next-line deprecation/deprecation\n      menuClassNames: IProcessedStyleSet<IContextualMenuStyles> | IContextualMenuClassNames,\n      index: number,\n      hasCheckmarks: boolean,\n      hasIcons: boolean,\n    ): React.ReactNode => {\n      const { contextualMenuItemAs: ChildrenRenderer = ContextualMenuItem } = props;\n      const { itemProps, id } = item;\n      const divHtmlProperties =\n        itemProps && getNativeProps<React.HTMLAttributes<HTMLDivElement>>(itemProps, divProperties);\n      return (\n        // eslint-disable-next-line deprecation/deprecation\n        <div id={id} className={menuClassNames.header} {...divHtmlProperties} style={item.style}>\n          <ChildrenRenderer\n            item={item}\n            classNames={itemClassNames}\n            index={index}\n            onCheckmarkClick={hasCheckmarks ? onItemClick : undefined}\n            hasIcons={hasIcons}\n            {...itemProps}\n          />\n        </div>\n      );\n    };\n    //#endregion\n\n    //#region Main render\n    let { isBeakVisible } = props;\n\n    const {\n      items,\n      labelElementId,\n      id,\n      className,\n      beakWidth,\n      directionalHint,\n      directionalHintForRTL,\n      alignTargetEdge,\n      gapSpace,\n      coverTarget,\n      ariaLabel,\n      doNotLayer,\n      target,\n      bounds,\n      useTargetWidth,\n      useTargetAsMinWidth,\n      directionalHintFixed,\n      shouldFocusOnMount,\n      shouldFocusOnContainer,\n      title,\n      styles,\n      theme,\n      calloutProps,\n      onRenderSubMenu = onDefaultRenderSubMenu,\n      onRenderMenuList = (\n        menuListProps: IContextualMenuListProps,\n        defaultRender?: IRenderFunction<IContextualMenuListProps>,\n      ) => onDefaultRenderMenuList(menuListProps, classNames, defaultRender),\n      focusZoneProps,\n      // eslint-disable-next-line deprecation/deprecation\n      getMenuClassNames,\n    } = props;\n\n    const classNames = getMenuClassNames\n      ? getMenuClassNames(theme!, className)\n      : getClassNames(styles, {\n          theme: theme!,\n          className: className,\n        });\n\n    const hasIcons = itemsHaveIcons(items);\n\n    function itemsHaveIcons(contextualMenuItems: IContextualMenuItem[]): boolean {\n      for (const item of contextualMenuItems) {\n        if (item.iconProps) {\n          return true;\n        }\n\n        if (\n          item.itemType === ContextualMenuItemType.Section &&\n          item.sectionProps &&\n          itemsHaveIcons(item.sectionProps.items)\n        ) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    const adjustedFocusZoneProps = {\n      direction: FocusZoneDirection.vertical,\n      handleTabKey: FocusZoneTabbableElements.all,\n      isCircularNavigation: true,\n      ...focusZoneProps,\n      className: css(classNames.root, props.focusZoneProps?.className),\n    };\n\n    const hasCheckmarks = canAnyMenuItemsCheck(items);\n    const submenuProps = expandedMenuItemKey && props.hidden !== true ? getSubmenuProps() : null;\n\n    isBeakVisible = isBeakVisible === undefined ? responsiveMode! <= ResponsiveMode.medium : isBeakVisible;\n    /**\n     * When useTargetWidth is true, get the width of the target element and apply it for the context menu container\n     */\n    let contextMenuStyle: React.CSSProperties;\n    const targetAsHtmlElement = targetRef.current as HTMLElement;\n    if ((useTargetWidth || useTargetAsMinWidth) && targetAsHtmlElement && targetAsHtmlElement.offsetWidth) {\n      const targetBoundingRect = targetAsHtmlElement.getBoundingClientRect();\n      const targetWidth = targetBoundingRect.width - 2; /* Accounts for 1px border */\n\n      if (useTargetWidth) {\n        contextMenuStyle = {\n          width: targetWidth,\n        };\n      } else if (useTargetAsMinWidth) {\n        contextMenuStyle = {\n          minWidth: targetWidth,\n        };\n      }\n    }\n\n    // The menu should only return if items were provided, if no items were provided then it should not appear.\n    if (items && items.length > 0) {\n      let totalItemCount = 0;\n      for (const item of items) {\n        if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n          const itemCount = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n          totalItemCount += itemCount;\n        }\n      }\n\n      const calloutStyles = classNames.subComponentStyles\n        ? (classNames.subComponentStyles.callout as IStyleFunctionOrObject<\n            ICalloutContentStyleProps,\n            ICalloutContentStyles\n          >)\n        : undefined;\n\n      return (\n        <MenuContext.Consumer>\n          {menuContext => (\n            <Callout\n              styles={calloutStyles}\n              onRestoreFocus={tryFocusPreviousActiveElement}\n              {...calloutProps}\n              target={target || (menuContext.target as IContextualMenuProps['target'])}\n              isBeakVisible={isBeakVisible}\n              beakWidth={beakWidth}\n              directionalHint={directionalHint}\n              directionalHintForRTL={directionalHintForRTL}\n              gapSpace={gapSpace}\n              coverTarget={coverTarget}\n              doNotLayer={doNotLayer}\n              className={css('ms-ContextualMenu-Callout', calloutProps && calloutProps.className)}\n              setInitialFocus={shouldFocusOnMount}\n              onDismiss={props.onDismiss || menuContext.onDismiss}\n              onScroll={onScroll}\n              bounds={bounds}\n              directionalHintFixed={directionalHintFixed}\n              alignTargetEdge={alignTargetEdge}\n              hidden={props.hidden || menuContext.hidden}\n              ref={forwardedRef}\n            >\n              <div\n                style={contextMenuStyle}\n                ref={hostElement}\n                id={id}\n                className={classNames.container}\n                tabIndex={shouldFocusOnContainer ? 0 : -1}\n                onKeyDown={onMenuKeyDown}\n                onKeyUp={onKeyUp}\n                onFocusCapture={onMenuFocusCapture}\n                aria-label={ariaLabel}\n                aria-labelledby={labelElementId}\n                role={'menu'}\n              >\n                {title && <div className={classNames.title}> {title} </div>}\n                {items && items.length\n                  ? renderFocusZone(\n                      onRenderMenuList(\n                        {\n                          ariaLabel,\n                          items,\n                          totalItemCount,\n                          hasCheckmarks,\n                          hasIcons,\n                          defaultMenuItemRenderer: (item: IContextualMenuItemRenderProps) =>\n                            defaultMenuItemRenderer(item, classNames),\n                          labelElementId,\n                        },\n                        (\n                          menuListProps: IContextualMenuListProps,\n                          defaultRender?: IRenderFunction<IContextualMenuListProps>,\n                        ) => onDefaultRenderMenuList(menuListProps, classNames, defaultRender),\n                      ),\n                      adjustedFocusZoneProps,\n                    )\n                  : null}\n                {submenuProps && onRenderSubMenu(submenuProps, onDefaultRenderSubMenu)}\n              </div>\n            </Callout>\n          )}\n        </MenuContext.Consumer>\n      );\n    } else {\n      return null;\n    }\n    //#endregion\n  }),\n  (prevProps, newProps) => {\n    if (!newProps.shouldUpdateWhenHidden && prevProps.hidden && newProps.hidden) {\n      // Do not update when hidden.\n      return true;\n    }\n\n    return shallowCompare(prevProps, newProps);\n  },\n);\nContextualMenuBase.displayName = 'ContextualMenuBase';\n\n/**\n * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\n */\nfunction isAltOrMeta(ev: React.KeyboardEvent<HTMLElement>): boolean {\n  // eslint-disable-next-line deprecation/deprecation\n  return ev.which === KeyCodes.alt || ev.key === 'Meta';\n}\n\nfunction onItemMouseDown(item: IContextualMenuItem, ev: React.MouseEvent<HTMLElement>): void {\n  item.onMouseDown?.(item, ev);\n}\n\nfunction onDefaultRenderSubMenu(\n  subMenuProps: IContextualMenuProps,\n  defaultRender?: IRenderFunction<IContextualMenuProps>,\n): JSX.Element {\n  throw Error(\n    'ContextualMenuBase: onRenderSubMenu callback is null or undefined. ' +\n      'Please ensure to set `onRenderSubMenu` property either manually or with `styled` helper.',\n  );\n}\n\n/**\n * Returns the item that matches a given key if any.\n * @param key - The key of the item to match\n * @param items - The items to look for the key\n */\nfunction findItemByKeyFromItems(key: string, items: IContextualMenuItem[]): IContextualMenuItem | undefined {\n  for (const item of items) {\n    if (item.itemType === ContextualMenuItemType.Section && item.sectionProps) {\n      const match = findItemByKeyFromItems(key, item.sectionProps.items);\n      if (match) {\n        return match;\n      }\n    } else if (item.key && item.key === key) {\n      return item;\n    }\n  }\n}\n\nfunction getOnClickWithOverrideTarget(\n  onClick:\n    | ((\n        ev?: React.MouseEvent<HTMLElement, MouseEvent> | React.KeyboardEvent<HTMLElement> | undefined,\n        item?: IContextualMenuItem | undefined,\n      ) => boolean | void)\n    | undefined,\n  target: Target | undefined,\n) {\n  return onClick\n    ? (\n        ev?: React.MouseEvent<HTMLElement, MouseEvent> | React.KeyboardEvent<HTMLElement> | undefined,\n        item?: IContextualMenuItem | undefined,\n      ) => {\n        overrideTarget(ev, target);\n\n        return onClick(ev, item);\n      }\n    : onClick;\n}\n\nfunction overrideTarget(\n  ev?: React.MouseEvent<HTMLElement, MouseEvent> | React.KeyboardEvent<HTMLElement> | undefined,\n  target?: Target,\n): void {\n  if (ev && target) {\n    ev.persist();\n\n    if (target instanceof Event) {\n      ev.target = target.target as HTMLElement;\n    } else if (target instanceof Element) {\n      ev.target = target;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}