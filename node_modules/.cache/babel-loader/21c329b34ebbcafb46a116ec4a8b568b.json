{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { hiddenContentStyle } from '../../Styling';\nimport { initializeComponentRef, Async, divProperties, getNativeProps, getId, assign, hasOverflow, portalContainsElement, classNamesFunction, KeyCodes } from '../../Utilities';\nimport { TooltipOverflowMode } from './TooltipHost.types';\nimport { Tooltip } from './Tooltip';\nimport { TooltipDelay } from './Tooltip.types';\nvar getClassNames = classNamesFunction();\n\nvar TooltipHostBase =\n/** @class */\nfunction (_super) {\n  __extends(TooltipHostBase, _super); // Constructor\n\n\n  function TooltipHostBase(props) {\n    var _this = _super.call(this, props) || this; // The wrapping div that gets the hover events\n\n\n    _this._tooltipHost = React.createRef();\n    _this._defaultTooltipId = getId('tooltip');\n\n    _this.show = function () {\n      _this._toggleTooltip(true);\n    };\n\n    _this.dismiss = function () {\n      _this._hideTooltip();\n    };\n\n    _this._getTargetElement = function () {\n      if (!_this._tooltipHost.current) {\n        return undefined;\n      }\n\n      var overflowMode = _this.props.overflowMode; // Select target element based on overflow mode. For parent mode, you want to position the tooltip relative\n      // to the parent element, otherwise it might look off.\n\n      if (overflowMode !== undefined) {\n        switch (overflowMode) {\n          case TooltipOverflowMode.Parent:\n            return _this._tooltipHost.current.parentElement;\n\n          case TooltipOverflowMode.Self:\n            return _this._tooltipHost.current;\n        }\n      }\n\n      return _this._tooltipHost.current;\n    };\n\n    _this._onTooltipFocus = function (ev) {\n      if (_this._ignoreNextFocusEvent) {\n        _this._ignoreNextFocusEvent = false;\n        return;\n      }\n\n      _this._onTooltipMouseEnter(ev);\n    };\n\n    _this._onTooltipBlur = function (ev) {\n      // The focused element gets a blur event when the document loses focus\n      // (e.g. switching tabs in the browser), but we don't want to show the\n      // tooltip again when the document gets focus back. Handle this case by\n      // checking if the blurred element is still the document's activeElement,\n      // and ignoring when it next gets focus back.\n      // See https://github.com/microsoft/fluentui/issues/13541\n      _this._ignoreNextFocusEvent = (document === null || document === void 0 ? void 0 : document.activeElement) === ev.target;\n\n      _this._hideTooltip();\n    }; // Show Tooltip\n\n\n    _this._onTooltipMouseEnter = function (ev) {\n      var _a = _this.props,\n          overflowMode = _a.overflowMode,\n          delay = _a.delay;\n\n      if (TooltipHostBase._currentVisibleTooltip && TooltipHostBase._currentVisibleTooltip !== _this) {\n        TooltipHostBase._currentVisibleTooltip.dismiss();\n      }\n\n      TooltipHostBase._currentVisibleTooltip = _this;\n\n      if (overflowMode !== undefined) {\n        var overflowElement = _this._getTargetElement();\n\n        if (overflowElement && !hasOverflow(overflowElement)) {\n          return;\n        }\n      }\n\n      if (ev.target && portalContainsElement(ev.target, _this._getTargetElement())) {\n        // Do not show tooltip when target is inside a portal relative to TooltipHost.\n        return;\n      }\n\n      _this._clearDismissTimer();\n\n      _this._clearOpenTimer();\n\n      if (delay !== TooltipDelay.zero) {\n        _this.setState({\n          isAriaPlaceholderRendered: true\n        });\n\n        var delayTime = _this._getDelayTime(delay); // non-null assertion because we set it in `defaultProps`\n\n\n        _this._openTimerId = _this._async.setTimeout(function () {\n          _this._toggleTooltip(true);\n        }, delayTime);\n      } else {\n        _this._toggleTooltip(true);\n      }\n    }; // Hide Tooltip\n\n\n    _this._onTooltipMouseLeave = function (ev) {\n      var closeDelay = _this.props.closeDelay;\n\n      _this._clearDismissTimer();\n\n      _this._clearOpenTimer();\n\n      if (closeDelay) {\n        _this._dismissTimerId = _this._async.setTimeout(function () {\n          _this._toggleTooltip(false);\n        }, closeDelay);\n      } else {\n        _this._toggleTooltip(false);\n      }\n\n      if (TooltipHostBase._currentVisibleTooltip === _this) {\n        TooltipHostBase._currentVisibleTooltip = undefined;\n      }\n    };\n\n    _this._onTooltipKeyDown = function (ev) {\n      // eslint-disable-next-line deprecation/deprecation\n      if ((ev.which === KeyCodes.escape || ev.ctrlKey) && _this.state.isTooltipVisible) {\n        _this._hideTooltip();\n\n        ev.stopPropagation();\n      }\n    };\n\n    _this._clearDismissTimer = function () {\n      _this._async.clearTimeout(_this._dismissTimerId);\n    };\n\n    _this._clearOpenTimer = function () {\n      _this._async.clearTimeout(_this._openTimerId);\n    }; // Hide Tooltip\n\n\n    _this._hideTooltip = function () {\n      _this._clearOpenTimer();\n\n      _this._clearDismissTimer();\n\n      _this._toggleTooltip(false);\n    };\n\n    _this._toggleTooltip = function (isTooltipVisible) {\n      if (_this.state.isAriaPlaceholderRendered) {\n        _this.setState({\n          isAriaPlaceholderRendered: false\n        });\n      }\n\n      if (_this.state.isTooltipVisible !== isTooltipVisible) {\n        _this.setState({\n          isTooltipVisible: isTooltipVisible\n        }, function () {\n          return _this.props.onTooltipToggle && _this.props.onTooltipToggle(isTooltipVisible);\n        });\n      }\n    };\n\n    _this._getDelayTime = function (delay) {\n      switch (delay) {\n        case TooltipDelay.medium:\n          return 300;\n\n        case TooltipDelay.long:\n          return 500;\n\n        default:\n          return 0;\n      }\n    };\n\n    initializeComponentRef(_this);\n    _this.state = {\n      isAriaPlaceholderRendered: false,\n      isTooltipVisible: false\n    };\n    _this._async = new Async(_this);\n    return _this;\n  } // Render\n\n\n  TooltipHostBase.prototype.render = function () {\n    var _a = this.props,\n        calloutProps = _a.calloutProps,\n        children = _a.children,\n        content = _a.content,\n        directionalHint = _a.directionalHint,\n        directionalHintForRTL = _a.directionalHintForRTL,\n        className = _a.hostClassName,\n        id = _a.id,\n        // eslint-disable-next-line deprecation/deprecation\n    _b = _a.setAriaDescribedBy,\n        // eslint-disable-next-line deprecation/deprecation\n    setAriaDescribedBy = _b === void 0 ? true : _b,\n        tooltipProps = _a.tooltipProps,\n        styles = _a.styles,\n        theme = _a.theme;\n    this._classNames = getClassNames(styles, {\n      theme: theme,\n      className: className\n    });\n    var _c = this.state,\n        isAriaPlaceholderRendered = _c.isAriaPlaceholderRendered,\n        isTooltipVisible = _c.isTooltipVisible;\n    var tooltipId = id || this._defaultTooltipId;\n    var isContentPresent = !!(content || tooltipProps && tooltipProps.onRenderContent && tooltipProps.onRenderContent());\n    var showTooltip = isTooltipVisible && isContentPresent;\n    var ariaDescribedBy = setAriaDescribedBy && isTooltipVisible && isContentPresent ? tooltipId : undefined;\n    return React.createElement(\"div\", __assign({\n      className: this._classNames.root,\n      ref: this._tooltipHost\n    }, {\n      onFocusCapture: this._onTooltipFocus\n    }, {\n      onBlurCapture: this._onTooltipBlur\n    }, {\n      onMouseEnter: this._onTooltipMouseEnter,\n      onMouseLeave: this._onTooltipMouseLeave,\n      onKeyDown: this._onTooltipKeyDown,\n      role: \"none\",\n      \"aria-describedby\": ariaDescribedBy\n    }), children, showTooltip && React.createElement(Tooltip, __assign({\n      id: tooltipId,\n      content: content,\n      targetElement: this._getTargetElement(),\n      directionalHint: directionalHint,\n      directionalHintForRTL: directionalHintForRTL,\n      calloutProps: assign({}, calloutProps, {\n        onDismiss: this._hideTooltip,\n        onMouseEnter: this._onTooltipMouseEnter,\n        onMouseLeave: this._onTooltipMouseLeave\n      }),\n      onMouseEnter: this._onTooltipMouseEnter,\n      onMouseLeave: this._onTooltipMouseLeave\n    }, getNativeProps(this.props, divProperties), tooltipProps)), isAriaPlaceholderRendered && React.createElement(\"div\", {\n      id: tooltipId,\n      role: \"none\",\n      style: hiddenContentStyle\n    }, content));\n  };\n\n  TooltipHostBase.prototype.componentWillUnmount = function () {\n    if (TooltipHostBase._currentVisibleTooltip && TooltipHostBase._currentVisibleTooltip === this) {\n      TooltipHostBase._currentVisibleTooltip = undefined;\n    }\n\n    this._async.dispose();\n  };\n\n  TooltipHostBase.defaultProps = {\n    delay: TooltipDelay.medium\n  };\n  return TooltipHostBase;\n}(React.Component);\n\nexport { TooltipHostBase };","map":{"version":3,"mappings":"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","names":["React","hiddenContentStyle","initializeComponentRef","Async","divProperties","getNativeProps","getId","assign","hasOverflow","portalContainsElement","classNamesFunction","KeyCodes","TooltipOverflowMode","Tooltip","TooltipDelay","getClassNames","__extends","props","_super","_this","createRef","_toggleTooltip","_hideTooltip","_tooltipHost","current","undefined","overflowMode","Parent","parentElement","Self","ev","_ignoreNextFocusEvent","_onTooltipMouseEnter","activeElement","target","delay","TooltipHostBase","_currentVisibleTooltip","dismiss","overflowElement","_getTargetElement","_clearDismissTimer","_clearOpenTimer","zero","setState","isAriaPlaceholderRendered","delayTime","_getDelayTime","_openTimerId","_async","setTimeout","closeDelay","_dismissTimerId","which","escape","ctrlKey","state","isTooltipVisible","stopPropagation","clearTimeout","onTooltipToggle","medium","long","calloutProps","children","content","directionalHint","directionalHintForRTL","className","id","_b","setAriaDescribedBy","tooltipProps","styles","theme","_classNames","tooltipId","_defaultTooltipId","isContentPresent","onRenderContent","showTooltip","ariaDescribedBy","root","ref","onFocusCapture","_onTooltipFocus","onBlurCapture","_onTooltipBlur","onMouseEnter","onMouseLeave","_onTooltipMouseLeave","onKeyDown","_onTooltipKeyDown","role","__assign","targetElement","onDismiss","style","dispose","Component"],"sources":["/home/npr/Downloads/Final FrontEnd (2)/node_modules/@fluentui/react/lib/components/src/components/Tooltip/TooltipHost.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport { hiddenContentStyle } from '../../Styling';\nimport {\n  initializeComponentRef,\n  Async,\n  divProperties,\n  getNativeProps,\n  getId,\n  assign,\n  hasOverflow,\n  portalContainsElement,\n  classNamesFunction,\n  KeyCodes,\n} from '../../Utilities';\nimport { TooltipOverflowMode } from './TooltipHost.types';\nimport { Tooltip } from './Tooltip';\nimport { TooltipDelay } from './Tooltip.types';\nimport type { ITooltipHostProps, ITooltipHostStyles, ITooltipHostStyleProps, ITooltipHost } from './TooltipHost.types';\n\nexport interface ITooltipHostState {\n  isAriaPlaceholderRendered: boolean;\n  isTooltipVisible: boolean;\n}\n\nconst getClassNames = classNamesFunction<ITooltipHostStyleProps, ITooltipHostStyles>();\n\nexport class TooltipHostBase extends React.Component<ITooltipHostProps, ITooltipHostState> implements ITooltipHost {\n  public static defaultProps = {\n    delay: TooltipDelay.medium,\n  };\n\n  private static _currentVisibleTooltip: ITooltipHost | undefined;\n\n  // The wrapping div that gets the hover events\n  private _tooltipHost = React.createRef<HTMLDivElement>();\n\n  private _classNames: { [key in keyof ITooltipHostStyles]: string };\n  private _async: Async;\n  private _dismissTimerId: number;\n  private _openTimerId: number;\n  private _defaultTooltipId = getId('tooltip');\n  private _ignoreNextFocusEvent: boolean;\n\n  // Constructor\n  constructor(props: ITooltipHostProps) {\n    super(props);\n\n    initializeComponentRef(this);\n\n    this.state = {\n      isAriaPlaceholderRendered: false,\n      isTooltipVisible: false,\n    };\n\n    this._async = new Async(this);\n  }\n\n  // Render\n  public render(): JSX.Element {\n    const {\n      calloutProps,\n      children,\n      content,\n      directionalHint,\n      directionalHintForRTL,\n      hostClassName: className,\n      id,\n      // eslint-disable-next-line deprecation/deprecation\n      setAriaDescribedBy = true,\n      tooltipProps,\n      styles,\n      theme,\n    } = this.props;\n\n    this._classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n    });\n\n    const { isAriaPlaceholderRendered, isTooltipVisible } = this.state;\n    const tooltipId = id || this._defaultTooltipId;\n    const isContentPresent = !!(\n      content ||\n      (tooltipProps && tooltipProps.onRenderContent && tooltipProps.onRenderContent())\n    );\n    const showTooltip = isTooltipVisible && isContentPresent;\n    const ariaDescribedBy = setAriaDescribedBy && isTooltipVisible && isContentPresent ? tooltipId : undefined;\n\n    return (\n      <div\n        className={this._classNames.root}\n        ref={this._tooltipHost}\n        {...{ onFocusCapture: this._onTooltipFocus }}\n        {...{ onBlurCapture: this._onTooltipBlur }}\n        onMouseEnter={this._onTooltipMouseEnter}\n        onMouseLeave={this._onTooltipMouseLeave}\n        onKeyDown={this._onTooltipKeyDown}\n        role=\"none\"\n        // WARNING: aria-describedby on this node provides no value, since it isn't allowed generic elements\n        aria-describedby={ariaDescribedBy}\n      >\n        {children}\n        {showTooltip && (\n          <Tooltip\n            id={tooltipId}\n            content={content}\n            targetElement={this._getTargetElement()}\n            directionalHint={directionalHint}\n            directionalHintForRTL={directionalHintForRTL}\n            calloutProps={assign({}, calloutProps, {\n              onDismiss: this._hideTooltip,\n              onMouseEnter: this._onTooltipMouseEnter,\n              onMouseLeave: this._onTooltipMouseLeave,\n            })}\n            onMouseEnter={this._onTooltipMouseEnter}\n            onMouseLeave={this._onTooltipMouseLeave}\n            {...getNativeProps(this.props, divProperties)}\n            {...tooltipProps}\n          />\n        )}\n        {isAriaPlaceholderRendered && (\n          <div id={tooltipId} role=\"none\" style={hiddenContentStyle as React.CSSProperties}>\n            {content}\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  public componentWillUnmount(): void {\n    if (TooltipHostBase._currentVisibleTooltip && TooltipHostBase._currentVisibleTooltip === this) {\n      TooltipHostBase._currentVisibleTooltip = undefined;\n    }\n\n    this._async.dispose();\n  }\n\n  public show = (): void => {\n    this._toggleTooltip(true);\n  };\n\n  public dismiss = (): void => {\n    this._hideTooltip();\n  };\n\n  private _getTargetElement = (): HTMLElement | undefined => {\n    if (!this._tooltipHost.current) {\n      return undefined;\n    }\n\n    const { overflowMode } = this.props;\n\n    // Select target element based on overflow mode. For parent mode, you want to position the tooltip relative\n    // to the parent element, otherwise it might look off.\n    if (overflowMode !== undefined) {\n      switch (overflowMode) {\n        case TooltipOverflowMode.Parent:\n          return this._tooltipHost.current.parentElement!;\n\n        case TooltipOverflowMode.Self:\n          return this._tooltipHost.current;\n      }\n    }\n\n    return this._tooltipHost.current;\n  };\n\n  private _onTooltipFocus = (ev: React.FocusEvent<HTMLElement>) => {\n    if (this._ignoreNextFocusEvent) {\n      this._ignoreNextFocusEvent = false;\n      return;\n    }\n\n    this._onTooltipMouseEnter(ev);\n  };\n\n  private _onTooltipBlur = (ev: React.FocusEvent<HTMLElement>) => {\n    // The focused element gets a blur event when the document loses focus\n    // (e.g. switching tabs in the browser), but we don't want to show the\n    // tooltip again when the document gets focus back. Handle this case by\n    // checking if the blurred element is still the document's activeElement,\n    // and ignoring when it next gets focus back.\n    // See https://github.com/microsoft/fluentui/issues/13541\n    this._ignoreNextFocusEvent = document?.activeElement === ev.target;\n\n    this._hideTooltip();\n  };\n\n  // Show Tooltip\n  private _onTooltipMouseEnter = (ev: any): void => {\n    const { overflowMode, delay } = this.props;\n\n    if (TooltipHostBase._currentVisibleTooltip && TooltipHostBase._currentVisibleTooltip !== this) {\n      TooltipHostBase._currentVisibleTooltip.dismiss();\n    }\n    TooltipHostBase._currentVisibleTooltip = this;\n\n    if (overflowMode !== undefined) {\n      const overflowElement = this._getTargetElement();\n      if (overflowElement && !hasOverflow(overflowElement)) {\n        return;\n      }\n    }\n\n    if (ev.target && portalContainsElement(ev.target as HTMLElement, this._getTargetElement())) {\n      // Do not show tooltip when target is inside a portal relative to TooltipHost.\n      return;\n    }\n\n    this._clearDismissTimer();\n    this._clearOpenTimer();\n\n    if (delay !== TooltipDelay.zero) {\n      this.setState({ isAriaPlaceholderRendered: true });\n      const delayTime = this._getDelayTime(delay!); // non-null assertion because we set it in `defaultProps`\n\n      this._openTimerId = this._async.setTimeout(() => {\n        this._toggleTooltip(true);\n      }, delayTime);\n    } else {\n      this._toggleTooltip(true);\n    }\n  };\n\n  // Hide Tooltip\n  private _onTooltipMouseLeave = (ev: any): void => {\n    const { closeDelay } = this.props;\n\n    this._clearDismissTimer();\n    this._clearOpenTimer();\n\n    if (closeDelay) {\n      this._dismissTimerId = this._async.setTimeout(() => {\n        this._toggleTooltip(false);\n      }, closeDelay);\n    } else {\n      this._toggleTooltip(false);\n    }\n\n    if (TooltipHostBase._currentVisibleTooltip === this) {\n      TooltipHostBase._currentVisibleTooltip = undefined;\n    }\n  };\n\n  private _onTooltipKeyDown = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    // eslint-disable-next-line deprecation/deprecation\n    if ((ev.which === KeyCodes.escape || ev.ctrlKey) && this.state.isTooltipVisible) {\n      this._hideTooltip();\n      ev.stopPropagation();\n    }\n  };\n\n  private _clearDismissTimer = (): void => {\n    this._async.clearTimeout(this._dismissTimerId);\n  };\n\n  private _clearOpenTimer = (): void => {\n    this._async.clearTimeout(this._openTimerId);\n  };\n\n  // Hide Tooltip\n  private _hideTooltip = (): void => {\n    this._clearOpenTimer();\n    this._clearDismissTimer();\n    this._toggleTooltip(false);\n  };\n\n  private _toggleTooltip = (isTooltipVisible: boolean): void => {\n    if (this.state.isAriaPlaceholderRendered) {\n      this.setState({\n        isAriaPlaceholderRendered: false,\n      });\n    }\n\n    if (this.state.isTooltipVisible !== isTooltipVisible) {\n      this.setState(\n        { isTooltipVisible },\n        () => this.props.onTooltipToggle && this.props.onTooltipToggle(isTooltipVisible),\n      );\n    }\n  };\n\n  private _getDelayTime = (delay: TooltipDelay): number => {\n    switch (delay) {\n      case TooltipDelay.medium:\n        return 300;\n      case TooltipDelay.long:\n        return 500;\n      default:\n        return 0;\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}