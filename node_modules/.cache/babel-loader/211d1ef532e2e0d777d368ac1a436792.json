{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { FocusZoneDirection, FocusZoneTabbableElements } from './FocusZone.types';\nimport { KeyCodes, css, elementContains, getDocument, getElementIndexPath, getFocusableByIndexPath, getId, getNativeProps, getNextElement, getParent, getPreviousElement, getRTL, htmlElementProperties, initializeComponentRef, isElementFocusSubZone, isElementFocusZone, isElementTabbable, shouldWrapFocus, warnDeprecations, portalContainsElement, getWindow, findScrollableParent, createMergedRef } from '@fluentui/utilities';\nimport { mergeStyles } from '@fluentui/merge-styles';\nimport { getTheme } from '@fluentui/style-utilities';\nvar IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';\nvar IS_ENTER_DISABLED_ATTRIBUTE = 'data-disable-click-on-enter';\nvar FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';\nvar TABINDEX = 'tabindex';\nvar NO_VERTICAL_WRAP = 'data-no-vertical-wrap';\nvar NO_HORIZONTAL_WRAP = 'data-no-horizontal-wrap';\nvar LARGE_DISTANCE_FROM_CENTER = 999999999;\nvar LARGE_NEGATIVE_DISTANCE_FROM_CENTER = -999999999;\nvar focusZoneStyles;\nvar focusZoneClass = 'ms-FocusZone';\n/**\n * Raises a click on a target element based on a keyboard event.\n */\n\nfunction raiseClickFromKeyboardEvent(target, ev) {\n  var event;\n\n  if (typeof MouseEvent === 'function') {\n    event = new MouseEvent('click', {\n      ctrlKey: ev === null || ev === void 0 ? void 0 : ev.ctrlKey,\n      metaKey: ev === null || ev === void 0 ? void 0 : ev.metaKey,\n      shiftKey: ev === null || ev === void 0 ? void 0 : ev.shiftKey,\n      altKey: ev === null || ev === void 0 ? void 0 : ev.altKey,\n      bubbles: ev === null || ev === void 0 ? void 0 : ev.bubbles,\n      cancelable: ev === null || ev === void 0 ? void 0 : ev.cancelable\n    });\n  } else {\n    event = document.createEvent('MouseEvents');\n    event.initMouseEvent('click', ev ? ev.bubbles : false, ev ? ev.cancelable : false, window, // not using getWindow() since this can only be run client side\n    0, // detail\n    0, // screen x\n    0, // screen y\n    0, // client x\n    0, // client y\n    ev ? ev.ctrlKey : false, ev ? ev.altKey : false, ev ? ev.shiftKey : false, ev ? ev.metaKey : false, 0, // button\n    null);\n  }\n\n  target.dispatchEvent(event);\n} // Helper function that will return a class for when the root is focused\n\n\nfunction getRootClass() {\n  if (!focusZoneStyles) {\n    focusZoneStyles = mergeStyles({\n      selectors: {\n        ':focus': {\n          outline: 'none'\n        }\n      }\n    }, focusZoneClass);\n  }\n\n  return focusZoneStyles;\n}\n\nvar _allInstances = {};\n\nvar _outerZones = new Set();\n\nvar ALLOWED_INPUT_TYPES = ['text', 'number', 'password', 'email', 'tel', 'url', 'search'];\nvar ALLOW_VIRTUAL_ELEMENTS = false;\n\nvar FocusZone =\n/** @class */\nfunction (_super) {\n  __extends(FocusZone, _super);\n\n  function FocusZone(props) {\n    var _a, _b, _c, _d;\n\n    var _this = _super.call(this, props) || this;\n\n    _this._root = React.createRef();\n    _this._mergedRef = createMergedRef();\n\n    _this._onFocus = function (ev) {\n      if (_this._portalContainsElement(ev.target)) {\n        // If the event target is inside a portal do not process the event.\n        return;\n      }\n\n      var _a = _this.props,\n          onActiveElementChanged = _a.onActiveElementChanged,\n          // eslint-disable-next-line deprecation/deprecation\n      doNotAllowFocusEventToPropagate = _a.doNotAllowFocusEventToPropagate,\n          stopFocusPropagation = _a.stopFocusPropagation,\n          // eslint-disable-next-line deprecation/deprecation\n      onFocusNotification = _a.onFocusNotification,\n          onFocus = _a.onFocus,\n          shouldFocusInnerElementWhenReceivedFocus = _a.shouldFocusInnerElementWhenReceivedFocus,\n          defaultTabbableElement = _a.defaultTabbableElement;\n\n      var isImmediateDescendant = _this._isImmediateDescendantOfZone(ev.target);\n\n      var newActiveElement;\n\n      if (isImmediateDescendant) {\n        newActiveElement = ev.target;\n      } else {\n        var parentElement = ev.target;\n\n        while (parentElement && parentElement !== _this._root.current) {\n          if (isElementTabbable(parentElement) && _this._isImmediateDescendantOfZone(parentElement)) {\n            newActiveElement = parentElement;\n            break;\n          }\n\n          parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n        }\n      } // If an inner focusable element should be focused when FocusZone container receives focus\n\n\n      if (shouldFocusInnerElementWhenReceivedFocus && ev.target === _this._root.current) {\n        var maybeElementToFocus = defaultTabbableElement && typeof defaultTabbableElement === 'function' && _this._root.current && defaultTabbableElement(_this._root.current); // try to focus defaultTabbable element\n\n        if (maybeElementToFocus && isElementTabbable(maybeElementToFocus)) {\n          newActiveElement = maybeElementToFocus;\n          maybeElementToFocus.focus();\n        } else {\n          // force focus on first focusable element\n          _this.focus(true);\n\n          if (_this._activeElement) {\n            // set to null as new active element was handled in method above\n            newActiveElement = null;\n          }\n        }\n      }\n\n      var initialElementFocused = !_this._activeElement; // If the new active element is a child of this zone and received focus,\n      // update alignment an immediate descendant\n\n      if (newActiveElement && newActiveElement !== _this._activeElement) {\n        if (isImmediateDescendant || initialElementFocused) {\n          _this._setFocusAlignment(newActiveElement, true, true);\n        }\n\n        _this._activeElement = newActiveElement;\n\n        if (initialElementFocused) {\n          _this._updateTabIndexes();\n        }\n      }\n\n      if (onActiveElementChanged) {\n        onActiveElementChanged(_this._activeElement, ev);\n      }\n\n      if (stopFocusPropagation || doNotAllowFocusEventToPropagate) {\n        ev.stopPropagation();\n      }\n\n      if (onFocus) {\n        onFocus(ev);\n      } else if (onFocusNotification) {\n        onFocusNotification();\n      }\n    };\n\n    _this._onBlur = function () {\n      _this._setParkedFocus(false);\n    };\n\n    _this._onMouseDown = function (ev) {\n      if (_this._portalContainsElement(ev.target)) {\n        // If the event target is inside a portal do not process the event.\n        return;\n      }\n\n      var disabled = _this.props.disabled;\n\n      if (disabled) {\n        return;\n      }\n\n      var target = ev.target;\n      var path = [];\n\n      while (target && target !== _this._root.current) {\n        path.push(target);\n        target = getParent(target, ALLOW_VIRTUAL_ELEMENTS);\n      }\n\n      while (path.length) {\n        target = path.pop();\n\n        if (target && isElementTabbable(target)) {\n          _this._setActiveElement(target, true);\n        }\n\n        if (isElementFocusZone(target)) {\n          // Stop here since the focus zone will take care of its own children.\n          break;\n        }\n      }\n    };\n    /**\n     * Handle the keystrokes.\n     */\n\n\n    _this._onKeyDown = function (ev, theme) {\n      if (_this._portalContainsElement(ev.target)) {\n        // If the event target is inside a portal do not process the event.\n        return;\n      } // eslint-disable-next-line deprecation/deprecation\n\n\n      var _a = _this.props,\n          direction = _a.direction,\n          disabled = _a.disabled,\n          isInnerZoneKeystroke = _a.isInnerZoneKeystroke,\n          pagingSupportDisabled = _a.pagingSupportDisabled,\n          shouldEnterInnerZone = _a.shouldEnterInnerZone;\n\n      if (disabled) {\n        return;\n      }\n\n      if (_this.props.onKeyDown) {\n        _this.props.onKeyDown(ev);\n      } // If the default has been prevented, do not process keyboard events.\n\n\n      if (ev.isDefaultPrevented()) {\n        return;\n      }\n\n      if (_this._getDocument().activeElement === _this._root.current && _this._isInnerZone) {\n        // If this element has focus, it is being controlled by a parent.\n        // Ignore the keystroke.\n        return;\n      }\n\n      if ((shouldEnterInnerZone && shouldEnterInnerZone(ev) || isInnerZoneKeystroke && isInnerZoneKeystroke(ev)) && _this._isImmediateDescendantOfZone(ev.target)) {\n        // Try to focus\n        var innerZone = _this._getFirstInnerZone();\n\n        if (innerZone) {\n          if (!innerZone.focus(true)) {\n            return;\n          }\n        } else if (isElementFocusSubZone(ev.target)) {\n          if (!_this.focusElement(getNextElement(ev.target, ev.target.firstChild, true))) {\n            return;\n          }\n        } else {\n          return;\n        }\n      } else if (ev.altKey) {\n        return;\n      } else {\n        // eslint-disable-next-line @fluentui/deprecated-keyboard-event-props, deprecation/deprecation\n        switch (ev.which) {\n          case KeyCodes.space:\n            if (_this._shouldRaiseClicksOnSpace && _this._tryInvokeClickForFocusable(ev.target, ev)) {\n              break;\n            }\n\n            return;\n\n          case KeyCodes.left:\n            if (direction !== FocusZoneDirection.vertical) {\n              _this._preventDefaultWhenHandled(ev);\n\n              if (_this._moveFocusLeft(theme)) {\n                break;\n              }\n            }\n\n            return;\n\n          case KeyCodes.right:\n            if (direction !== FocusZoneDirection.vertical) {\n              _this._preventDefaultWhenHandled(ev);\n\n              if (_this._moveFocusRight(theme)) {\n                break;\n              }\n            }\n\n            return;\n\n          case KeyCodes.up:\n            if (direction !== FocusZoneDirection.horizontal) {\n              _this._preventDefaultWhenHandled(ev);\n\n              if (_this._moveFocusUp()) {\n                break;\n              }\n            }\n\n            return;\n\n          case KeyCodes.down:\n            if (direction !== FocusZoneDirection.horizontal) {\n              _this._preventDefaultWhenHandled(ev);\n\n              if (_this._moveFocusDown()) {\n                break;\n              }\n            }\n\n            return;\n\n          case KeyCodes.pageDown:\n            if (!pagingSupportDisabled && _this._moveFocusPaging(true)) {\n              break;\n            }\n\n            return;\n\n          case KeyCodes.pageUp:\n            if (!pagingSupportDisabled && _this._moveFocusPaging(false)) {\n              break;\n            }\n\n            return;\n\n          case KeyCodes.tab:\n            if ( // eslint-disable-next-line deprecation/deprecation\n            _this.props.allowTabKey || _this.props.handleTabKey === FocusZoneTabbableElements.all || _this.props.handleTabKey === FocusZoneTabbableElements.inputOnly && _this._isElementInput(ev.target)) {\n              var focusChanged = false;\n              _this._processingTabKey = true;\n\n              if (direction === FocusZoneDirection.vertical || !_this._shouldWrapFocus(_this._activeElement, NO_HORIZONTAL_WRAP)) {\n                focusChanged = ev.shiftKey ? _this._moveFocusUp() : _this._moveFocusDown();\n              } else {\n                var tabWithDirection = getRTL(theme) ? !ev.shiftKey : ev.shiftKey;\n                focusChanged = tabWithDirection ? _this._moveFocusLeft(theme) : _this._moveFocusRight(theme);\n              }\n\n              _this._processingTabKey = false;\n\n              if (focusChanged) {\n                break;\n              } else if (_this.props.shouldResetActiveElementWhenTabFromZone) {\n                _this._activeElement = null;\n              }\n            }\n\n            return;\n\n          case KeyCodes.home:\n            if (_this._isContentEditableElement(ev.target) || _this._isElementInput(ev.target) && !_this._shouldInputLoseFocus(ev.target, false)) {\n              return false;\n            }\n\n            var firstChild = _this._root.current && _this._root.current.firstChild;\n\n            if (_this._root.current && firstChild && _this.focusElement(getNextElement(_this._root.current, firstChild, true))) {\n              break;\n            }\n\n            return;\n\n          case KeyCodes.end:\n            if (_this._isContentEditableElement(ev.target) || _this._isElementInput(ev.target) && !_this._shouldInputLoseFocus(ev.target, true)) {\n              return false;\n            }\n\n            var lastChild = _this._root.current && _this._root.current.lastChild;\n\n            if (_this._root.current && _this.focusElement(getPreviousElement(_this._root.current, lastChild, true, true, true))) {\n              break;\n            }\n\n            return;\n\n          case KeyCodes.enter:\n            if (_this._shouldRaiseClicksOnEnter && _this._tryInvokeClickForFocusable(ev.target, ev)) {\n              break;\n            }\n\n            return;\n\n          default:\n            return;\n        }\n      }\n\n      ev.preventDefault();\n      ev.stopPropagation();\n    };\n\n    _this._getHorizontalDistanceFromCenter = function (isForward, activeRect, targetRect) {\n      // eslint-disable-next-line deprecation/deprecation\n      var leftAlignment = _this._focusAlignment.left || _this._focusAlignment.x || 0; // ClientRect values can be floats that differ by very small fractions of a decimal.\n      // If the difference between top and bottom are within a pixel then we should treat\n      // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n      // but without Math.Floor they will be handled incorrectly.\n\n      var targetRectTop = Math.floor(targetRect.top);\n      var activeRectBottom = Math.floor(activeRect.bottom);\n      var targetRectBottom = Math.floor(targetRect.bottom);\n      var activeRectTop = Math.floor(activeRect.top);\n      var isValidCandidateOnpagingDown = isForward && targetRectTop > activeRectBottom;\n      var isValidCandidateOnpagingUp = !isForward && targetRectBottom < activeRectTop;\n\n      if (isValidCandidateOnpagingDown || isValidCandidateOnpagingUp) {\n        if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n          return 0;\n        }\n\n        return Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n      }\n\n      if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {\n        return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n      }\n\n      return LARGE_DISTANCE_FROM_CENTER;\n    }; // Manage componentRef resolution.\n\n\n    initializeComponentRef(_this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      warnDeprecations('FocusZone', props, {\n        rootProps: undefined,\n        allowTabKey: 'handleTabKey',\n        elementType: 'as',\n        ariaDescribedBy: 'aria-describedby',\n        ariaLabelledBy: 'aria-labelledby'\n      });\n    }\n\n    _this._id = getId('FocusZone');\n    _this._focusAlignment = {\n      left: 0,\n      top: 0\n    };\n    _this._processingTabKey = false;\n    var shouldRaiseClicksFallback = (_b = (_a = props.shouldRaiseClicks) !== null && _a !== void 0 ? _a : FocusZone.defaultProps.shouldRaiseClicks) !== null && _b !== void 0 ? _b : true;\n    _this._shouldRaiseClicksOnEnter = (_c = props.shouldRaiseClicksOnEnter) !== null && _c !== void 0 ? _c : shouldRaiseClicksFallback;\n    _this._shouldRaiseClicksOnSpace = (_d = props.shouldRaiseClicksOnSpace) !== null && _d !== void 0 ? _d : shouldRaiseClicksFallback;\n    return _this;\n  }\n  /** Used for testing purposes only. */\n\n\n  FocusZone.getOuterZones = function () {\n    return _outerZones.size;\n  };\n  /**\n   * Handle global tab presses so that we can patch tabindexes on the fly.\n   * HEADS UP: This must not be an arrow function in order to be referentially equal among instances\n   * for ref counting to work correctly!\n   */\n\n\n  FocusZone._onKeyDownCapture = function (ev) {\n    // eslint-disable-next-line deprecation/deprecation, @fluentui/deprecated-keyboard-event-props\n    if (ev.which === KeyCodes.tab) {\n      _outerZones.forEach(function (zone) {\n        return zone._updateTabIndexes();\n      });\n    }\n  };\n\n  FocusZone.prototype.componentDidMount = function () {\n    var root = this._root.current;\n    _allInstances[this._id] = this;\n\n    if (root) {\n      this._windowElement = getWindow(root);\n      var parentElement = getParent(root, ALLOW_VIRTUAL_ELEMENTS);\n\n      while (parentElement && parentElement !== this._getDocument().body && parentElement.nodeType === 1) {\n        if (isElementFocusZone(parentElement)) {\n          this._isInnerZone = true;\n          break;\n        }\n\n        parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n      }\n\n      if (!this._isInnerZone) {\n        _outerZones.add(this);\n\n        if (this._windowElement && _outerZones.size === 1) {\n          this._windowElement.addEventListener('keydown', FocusZone._onKeyDownCapture, true);\n        }\n      }\n\n      this._root.current && this._root.current.addEventListener('blur', this._onBlur, true); // Assign initial tab indexes so that we can set initial focus as appropriate.\n\n      this._updateTabIndexes();\n\n      if (this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === 'string') {\n        this._activeElement = this._getDocument().querySelector(this.props.defaultTabbableElement); // eslint-disable-next-line deprecation/deprecation\n      } else if (this.props.defaultActiveElement) {\n        // eslint-disable-next-line deprecation/deprecation\n        this._activeElement = this._getDocument().querySelector(this.props.defaultActiveElement);\n      }\n\n      if (this.props.shouldFocusOnMount) {\n        this.focus();\n      }\n    }\n  };\n\n  FocusZone.prototype.componentDidUpdate = function () {\n    var root = this._root.current;\n\n    var doc = this._getDocument();\n\n    if (!this.props.preventFocusRestoration && doc && this._lastIndexPath && (doc.activeElement === doc.body || doc.activeElement === null || doc.activeElement === root)) {\n      // The element has been removed after the render, attempt to restore focus.\n      var elementToFocus = getFocusableByIndexPath(root, this._lastIndexPath);\n\n      if (elementToFocus) {\n        this._setActiveElement(elementToFocus, true);\n\n        elementToFocus.focus();\n\n        this._setParkedFocus(false);\n      } else {\n        // We had a focus path to restore, but now that path is unresolvable. Park focus\n        // on the container until we can try again.\n        this._setParkedFocus(true);\n      }\n    }\n  };\n\n  FocusZone.prototype.componentWillUnmount = function () {\n    delete _allInstances[this._id];\n\n    if (!this._isInnerZone) {\n      _outerZones.delete(this); // If this is the last outer zone, remove the keydown listener.\n\n\n      if (this._windowElement && _outerZones.size === 0) {\n        this._windowElement.removeEventListener('keydown', FocusZone._onKeyDownCapture, true);\n      }\n    }\n\n    if (this._root.current) {\n      this._root.current.removeEventListener('blur', this._onBlur, true);\n    }\n\n    this._activeElement = null;\n    this._defaultFocusElement = null;\n  };\n\n  FocusZone.prototype.render = function () {\n    var _this = this; // eslint-disable-next-line deprecation/deprecation\n\n\n    var _a = this.props,\n        tag = _a.as,\n        elementType = _a.elementType,\n        rootProps = _a.rootProps,\n        ariaDescribedBy = _a.ariaDescribedBy,\n        ariaLabelledBy = _a.ariaLabelledBy,\n        className = _a.className;\n    var divProps = getNativeProps(this.props, htmlElementProperties);\n    var Tag = tag || elementType || 'div'; // Note, right before rendering/reconciling proceeds, we need to record if focus\n    // was in the zone before the update. This helper will track this and, if focus\n    // was actually in the zone, what the index path to the element is at this time.\n    // Then, later in componentDidUpdate, we can evaluate if we need to restore it in\n    // the case the element was removed.\n\n    this._evaluateFocusBeforeRender(); // Only support RTL defined in global theme, not contextual theme/RTL.\n\n\n    var theme = getTheme();\n    return React.createElement(Tag, __assign({\n      \"aria-labelledby\": ariaLabelledBy,\n      \"aria-describedby\": ariaDescribedBy\n    }, divProps, rootProps, {\n      // Once the getClassName correctly memoizes inputs this should\n      // be replaced so that className is passed to getRootClass and is included there so\n      // the class names will always be in the same order.\n      className: css(getRootClass(), className),\n      // eslint-disable-next-line deprecation/deprecation\n      ref: this._mergedRef(this.props.elementRef, this._root),\n      \"data-focuszone-id\": this._id,\n      // eslint-disable-next-line react/jsx-no-bind\n      onKeyDown: function (ev) {\n        return _this._onKeyDown(ev, theme);\n      },\n      onFocus: this._onFocus,\n      onMouseDownCapture: this._onMouseDown\n    }), this.props.children);\n  };\n  /**\n   * Sets focus to the first tabbable item in the zone.\n   * @param forceIntoFirstElement - If true, focus will be forced into the first element, even\n   * if focus is already in the focus zone.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n\n\n  FocusZone.prototype.focus = function (forceIntoFirstElement) {\n    if (forceIntoFirstElement === void 0) {\n      forceIntoFirstElement = false;\n    }\n\n    if (this._root.current) {\n      if (!forceIntoFirstElement && this._root.current.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' && this._isInnerZone) {\n        var ownerZoneElement = this._getOwnerZone(this._root.current);\n\n        if (ownerZoneElement !== this._root.current) {\n          var ownerZone = _allInstances[ownerZoneElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];\n\n          return !!ownerZone && ownerZone.focusElement(this._root.current);\n        }\n\n        return false;\n      } else if (!forceIntoFirstElement && this._activeElement && elementContains(this._root.current, this._activeElement) && isElementTabbable(this._activeElement)) {\n        this._activeElement.focus();\n\n        return true;\n      } else {\n        var firstChild = this._root.current.firstChild;\n        return this.focusElement(getNextElement(this._root.current, firstChild, true));\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Sets focus to the last tabbable item in the zone.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n\n\n  FocusZone.prototype.focusLast = function () {\n    if (this._root.current) {\n      var lastChild = this._root.current && this._root.current.lastChild;\n      return this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true));\n    }\n\n    return false;\n  };\n  /**\n   * Sets focus to a specific child element within the zone. This can be used in conjunction with\n   * shouldReceiveFocus to create delayed focus scenarios (like animate the scroll position to the correct\n   * location and then focus.)\n   * @param element - The child element within the zone to focus.\n   * @param forceAlignment - If true, focus alignment will be set according to the element provided.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n\n\n  FocusZone.prototype.focusElement = function (element, forceAlignment) {\n    // eslint-disable-next-line deprecation/deprecation\n    var _a = this.props,\n        onBeforeFocus = _a.onBeforeFocus,\n        shouldReceiveFocus = _a.shouldReceiveFocus;\n\n    if (shouldReceiveFocus && !shouldReceiveFocus(element) || onBeforeFocus && !onBeforeFocus(element)) {\n      return false;\n    }\n\n    if (element) {\n      // when we set focus to a specific child, we should recalculate the alignment depending on its position.\n      this._setActiveElement(element, forceAlignment);\n\n      if (this._activeElement) {\n        this._activeElement.focus();\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Forces horizontal alignment in the context of vertical arrowing to use specific point as the reference,\n   * rather than a center based on the last horizontal motion.\n   * @param point - the new reference point.\n   */\n\n\n  FocusZone.prototype.setFocusAlignment = function (point) {\n    this._focusAlignment = point;\n  };\n\n  FocusZone.prototype._evaluateFocusBeforeRender = function () {\n    var root = this._root.current;\n\n    var doc = this._getDocument();\n\n    if (doc) {\n      var focusedElement = doc.activeElement; // Only update the index path if we are not parked on the root.\n\n      if (focusedElement !== root) {\n        var shouldRestoreFocus = elementContains(root, focusedElement, false);\n        this._lastIndexPath = shouldRestoreFocus ? getElementIndexPath(root, focusedElement) : undefined;\n      }\n    }\n  };\n  /**\n   * When focus is in the zone at render time but then all focusable elements are removed,\n   * we \"park\" focus temporarily on the root. Once we update with focusable children, we restore\n   * focus to the closest path from previous. If the user tabs away from the parked container,\n   * we restore focusability to the pre-parked state.\n   */\n\n\n  FocusZone.prototype._setParkedFocus = function (isParked) {\n    var root = this._root.current;\n\n    if (root && this._isParked !== isParked) {\n      this._isParked = isParked;\n\n      if (isParked) {\n        if (!this.props.allowFocusRoot) {\n          this._parkedTabIndex = root.getAttribute('tabindex');\n          root.setAttribute('tabindex', '-1');\n        }\n\n        root.focus();\n      } else if (!this.props.allowFocusRoot) {\n        if (this._parkedTabIndex) {\n          root.setAttribute('tabindex', this._parkedTabIndex);\n          this._parkedTabIndex = undefined;\n        } else {\n          root.removeAttribute('tabindex');\n        }\n      }\n    }\n  };\n\n  FocusZone.prototype._setActiveElement = function (element, forceAlignment) {\n    var previousActiveElement = this._activeElement;\n    this._activeElement = element;\n\n    if (previousActiveElement) {\n      if (isElementFocusZone(previousActiveElement)) {\n        this._updateTabIndexes(previousActiveElement);\n      }\n\n      previousActiveElement.tabIndex = -1;\n    }\n\n    if (this._activeElement) {\n      if (!this._focusAlignment || forceAlignment) {\n        this._setFocusAlignment(element, true, true);\n      }\n\n      this._activeElement.tabIndex = 0;\n    }\n  };\n\n  FocusZone.prototype._preventDefaultWhenHandled = function (ev) {\n    this.props.preventDefaultWhenHandled && ev.preventDefault();\n  };\n  /**\n   * Walk up the dom try to find a focusable element.\n   */\n\n\n  FocusZone.prototype._tryInvokeClickForFocusable = function (targetElement, ev) {\n    var target = targetElement;\n\n    if (target === this._root.current) {\n      return false;\n    }\n\n    do {\n      if (target.tagName === 'BUTTON' || target.tagName === 'A' || target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {\n        return false;\n      }\n\n      if (this._isImmediateDescendantOfZone(target) && target.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' && target.getAttribute(IS_ENTER_DISABLED_ATTRIBUTE) !== 'true') {\n        raiseClickFromKeyboardEvent(target, ev);\n        return true;\n      }\n\n      target = getParent(target, ALLOW_VIRTUAL_ELEMENTS);\n    } while (target !== this._root.current);\n\n    return false;\n  };\n  /**\n   * Traverse to find first child zone.\n   */\n\n\n  FocusZone.prototype._getFirstInnerZone = function (rootElement) {\n    rootElement = rootElement || this._activeElement || this._root.current;\n\n    if (!rootElement) {\n      return null;\n    }\n\n    if (isElementFocusZone(rootElement)) {\n      return _allInstances[rootElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];\n    }\n\n    var child = rootElement.firstElementChild;\n\n    while (child) {\n      if (isElementFocusZone(child)) {\n        return _allInstances[child.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];\n      }\n\n      var match = this._getFirstInnerZone(child);\n\n      if (match) {\n        return match;\n      }\n\n      child = child.nextElementSibling;\n    }\n\n    return null;\n  };\n\n  FocusZone.prototype._moveFocus = function (isForward, getDistanceFromCenter, ev, useDefaultWrap) {\n    if (useDefaultWrap === void 0) {\n      useDefaultWrap = true;\n    }\n\n    var element = this._activeElement;\n    var candidateDistance = -1;\n    var candidateElement = undefined;\n    var changedFocus = false;\n    var isBidirectional = this.props.direction === FocusZoneDirection.bidirectional;\n\n    if (!element || !this._root.current) {\n      return false;\n    }\n\n    if (this._isElementInput(element)) {\n      if (!this._shouldInputLoseFocus(element, isForward)) {\n        return false;\n      }\n    }\n\n    var activeRect = isBidirectional ? element.getBoundingClientRect() : null;\n\n    do {\n      element = isForward ? getNextElement(this._root.current, element) : getPreviousElement(this._root.current, element);\n\n      if (isBidirectional) {\n        if (element) {\n          var targetRect = element.getBoundingClientRect();\n          var elementDistance = getDistanceFromCenter(activeRect, targetRect);\n\n          if (elementDistance === -1 && candidateDistance === -1) {\n            candidateElement = element;\n            break;\n          }\n\n          if (elementDistance > -1 && (candidateDistance === -1 || elementDistance < candidateDistance)) {\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          }\n\n          if (candidateDistance >= 0 && elementDistance < 0) {\n            break;\n          }\n        }\n      } else {\n        candidateElement = element;\n        break;\n      }\n    } while (element); // Focus the closest candidate\n\n\n    if (candidateElement && candidateElement !== this._activeElement) {\n      changedFocus = true;\n      this.focusElement(candidateElement);\n    } else if (this.props.isCircularNavigation && useDefaultWrap) {\n      if (isForward) {\n        return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));\n      } else {\n        return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));\n      }\n    }\n\n    return changedFocus;\n  };\n\n  FocusZone.prototype._moveFocusDown = function () {\n    var _this = this;\n\n    var targetTop = -1; // eslint-disable-next-line deprecation/deprecation\n\n    var leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;\n\n    if (this._moveFocus(true, function (activeRect, targetRect) {\n      var distance = -1; // ClientRect values can be floats that differ by very small fractions of a decimal.\n      // If the difference between top and bottom are within a pixel then we should treat\n      // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n      // but without Math.Floor they will be handled incorrectly.\n\n      var targetRectTop = Math.floor(targetRect.top);\n      var activeRectBottom = Math.floor(activeRect.bottom);\n\n      if (targetRectTop < activeRectBottom) {\n        if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {\n          return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n        }\n\n        return LARGE_DISTANCE_FROM_CENTER;\n      }\n\n      if (targetTop === -1 && targetRectTop >= activeRectBottom || targetRectTop === targetTop) {\n        targetTop = targetRectTop;\n\n        if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n          distance = 0;\n        } else {\n          distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n        }\n      }\n\n      return distance;\n    })) {\n      this._setFocusAlignment(this._activeElement, false, true);\n\n      return true;\n    }\n\n    return false;\n  };\n\n  FocusZone.prototype._moveFocusUp = function () {\n    var _this = this;\n\n    var targetTop = -1; // eslint-disable-next-line deprecation/deprecation\n\n    var leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;\n\n    if (this._moveFocus(false, function (activeRect, targetRect) {\n      var distance = -1; // ClientRect values can be floats that differ by very small fractions of a decimal.\n      // If the difference between top and bottom are within a pixel then we should treat\n      // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n      // but without Math.Floor they will be handled incorrectly.\n\n      var targetRectBottom = Math.floor(targetRect.bottom);\n      var targetRectTop = Math.floor(targetRect.top);\n      var activeRectTop = Math.floor(activeRect.top);\n\n      if (targetRectBottom > activeRectTop) {\n        if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {\n          return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n        }\n\n        return LARGE_DISTANCE_FROM_CENTER;\n      }\n\n      if (targetTop === -1 && targetRectBottom <= activeRectTop || targetRectTop === targetTop) {\n        targetTop = targetRectTop;\n\n        if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n          distance = 0;\n        } else {\n          distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n        }\n      }\n\n      return distance;\n    })) {\n      this._setFocusAlignment(this._activeElement, false, true);\n\n      return true;\n    }\n\n    return false;\n  };\n\n  FocusZone.prototype._moveFocusLeft = function (theme) {\n    var _this = this;\n\n    var shouldWrap = this._shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);\n\n    if (this._moveFocus(getRTL(theme), function (activeRect, targetRect) {\n      var distance = -1;\n      var topBottomComparison;\n\n      if (getRTL(theme)) {\n        // When in RTL, this comparison should be the same as the one in _moveFocusRight for LTR.\n        // Going left at a leftmost rectangle will go down a line instead of up a line like in LTR.\n        // This is important, because we want to be comparing the top of the target rect\n        // with the bottom of the active rect.\n        topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));\n      } else {\n        topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));\n      }\n\n      if (topBottomComparison && targetRect.right <= activeRect.right && _this.props.direction !== FocusZoneDirection.vertical) {\n        distance = activeRect.right - targetRect.right;\n      } else if (!shouldWrap) {\n        distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n      }\n\n      return distance;\n    }, undefined\n    /*ev*/\n    , shouldWrap)) {\n      this._setFocusAlignment(this._activeElement, true, false);\n\n      return true;\n    }\n\n    return false;\n  };\n\n  FocusZone.prototype._moveFocusRight = function (theme) {\n    var _this = this;\n\n    var shouldWrap = this._shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);\n\n    if (this._moveFocus(!getRTL(theme), function (activeRect, targetRect) {\n      var distance = -1;\n      var topBottomComparison;\n\n      if (getRTL(theme)) {\n        // When in RTL, this comparison should be the same as the one in _moveFocusLeft for LTR.\n        // Going right at a rightmost rectangle will go up a line instead of down a line like in LTR.\n        // This is important, because we want to be comparing the bottom of the target rect\n        // with the top of the active rect.\n        topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));\n      } else {\n        topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));\n      }\n\n      if (topBottomComparison && targetRect.left >= activeRect.left && _this.props.direction !== FocusZoneDirection.vertical) {\n        distance = targetRect.left - activeRect.left;\n      } else if (!shouldWrap) {\n        distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n      }\n\n      return distance;\n    }, undefined\n    /*ev*/\n    , shouldWrap)) {\n      this._setFocusAlignment(this._activeElement, true, false);\n\n      return true;\n    }\n\n    return false;\n  };\n\n  FocusZone.prototype._moveFocusPaging = function (isForward, useDefaultWrap) {\n    if (useDefaultWrap === void 0) {\n      useDefaultWrap = true;\n    }\n\n    var element = this._activeElement;\n\n    if (!element || !this._root.current) {\n      return false;\n    }\n\n    if (this._isElementInput(element)) {\n      if (!this._shouldInputLoseFocus(element, isForward)) {\n        return false;\n      }\n    }\n\n    var scrollableParent = findScrollableParent(element);\n\n    if (!scrollableParent) {\n      return false;\n    }\n\n    var candidateDistance = -1;\n    var candidateElement = undefined;\n    var targetTop = -1;\n    var targetBottom = -1;\n    var pagesize = scrollableParent.clientHeight;\n    var activeRect = element.getBoundingClientRect();\n\n    do {\n      element = isForward ? getNextElement(this._root.current, element) : getPreviousElement(this._root.current, element);\n\n      if (element) {\n        var targetRect = element.getBoundingClientRect();\n        var targetRectTop = Math.floor(targetRect.top);\n        var activeRectBottom = Math.floor(activeRect.bottom);\n        var targetRectBottom = Math.floor(targetRect.bottom);\n        var activeRectTop = Math.floor(activeRect.top);\n\n        var elementDistance = this._getHorizontalDistanceFromCenter(isForward, activeRect, targetRect);\n\n        var isElementPassedPageSizeOnPagingDown = isForward && targetRectTop > activeRectBottom + pagesize;\n        var isElementPassedPageSizeOnPagingUp = !isForward && targetRectBottom < activeRectTop - pagesize;\n\n        if (isElementPassedPageSizeOnPagingDown || isElementPassedPageSizeOnPagingUp) {\n          break;\n        }\n\n        if (elementDistance > -1) {\n          // for paging down\n          if (isForward && targetRectTop > targetTop) {\n            targetTop = targetRectTop;\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          } else if (!isForward && targetRectBottom < targetBottom) {\n            // for paging up\n            targetBottom = targetRectBottom;\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          } else if (candidateDistance === -1 || elementDistance <= candidateDistance) {\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          }\n        }\n      }\n    } while (element);\n\n    var changedFocus = false; // Focus the closest candidate\n\n    if (candidateElement && candidateElement !== this._activeElement) {\n      changedFocus = true;\n      this.focusElement(candidateElement);\n\n      this._setFocusAlignment(candidateElement, false, true);\n    } else if (this.props.isCircularNavigation && useDefaultWrap) {\n      if (isForward) {\n        return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));\n      }\n\n      return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));\n    }\n\n    return changedFocus;\n  };\n\n  FocusZone.prototype._setFocusAlignment = function (element, isHorizontal, isVertical) {\n    if (this.props.direction === FocusZoneDirection.bidirectional && (!this._focusAlignment || isHorizontal || isVertical)) {\n      var rect = element.getBoundingClientRect();\n      var left = rect.left + rect.width / 2;\n      var top_1 = rect.top + rect.height / 2;\n\n      if (!this._focusAlignment) {\n        this._focusAlignment = {\n          left: left,\n          top: top_1\n        };\n      }\n\n      if (isHorizontal) {\n        this._focusAlignment.left = left;\n      }\n\n      if (isVertical) {\n        this._focusAlignment.top = top_1;\n      }\n    }\n  };\n\n  FocusZone.prototype._isImmediateDescendantOfZone = function (element) {\n    return this._getOwnerZone(element) === this._root.current;\n  };\n\n  FocusZone.prototype._getOwnerZone = function (element) {\n    var parentElement = getParent(element, ALLOW_VIRTUAL_ELEMENTS);\n\n    while (parentElement && parentElement !== this._root.current && parentElement !== this._getDocument().body) {\n      if (isElementFocusZone(parentElement)) {\n        return parentElement;\n      }\n\n      parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n    }\n\n    return parentElement;\n  };\n\n  FocusZone.prototype._updateTabIndexes = function (element) {\n    if (!this._activeElement && this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === 'function') {\n      this._activeElement = this.props.defaultTabbableElement(this._root.current);\n    }\n\n    if (!element && this._root.current) {\n      this._defaultFocusElement = null;\n      element = this._root.current;\n\n      if (this._activeElement && !elementContains(element, this._activeElement)) {\n        this._activeElement = null;\n      }\n    } // If active element changes state to disabled, set it to null.\n    // Otherwise, we lose keyboard accessibility to other elements in focus zone.\n\n\n    if (this._activeElement && !isElementTabbable(this._activeElement)) {\n      this._activeElement = null;\n    }\n\n    var childNodes = element && element.children;\n\n    for (var childIndex = 0; childNodes && childIndex < childNodes.length; childIndex++) {\n      var child = childNodes[childIndex];\n\n      if (!isElementFocusZone(child)) {\n        // If the item is explicitly set to not be focusable then TABINDEX needs to be set to -1.\n        if (child.getAttribute && child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'false') {\n          child.setAttribute(TABINDEX, '-1');\n        }\n\n        if (isElementTabbable(child)) {\n          if (this.props.disabled) {\n            child.setAttribute(TABINDEX, '-1');\n          } else if (!this._isInnerZone && (!this._activeElement && !this._defaultFocusElement || this._activeElement === child)) {\n            this._defaultFocusElement = child;\n\n            if (child.getAttribute(TABINDEX) !== '0') {\n              child.setAttribute(TABINDEX, '0');\n            }\n          } else if (child.getAttribute(TABINDEX) !== '-1') {\n            child.setAttribute(TABINDEX, '-1');\n          }\n        } else if (child.tagName === 'svg' && child.getAttribute('focusable') !== 'false') {\n          // Disgusting IE hack. Sad face.\n          child.setAttribute('focusable', 'false');\n        }\n      } else if (child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true') {\n        if (!this._isInnerZone && (!this._activeElement && !this._defaultFocusElement || this._activeElement === child)) {\n          this._defaultFocusElement = child;\n\n          if (child.getAttribute(TABINDEX) !== '0') {\n            child.setAttribute(TABINDEX, '0');\n          }\n        } else if (child.getAttribute(TABINDEX) !== '-1') {\n          child.setAttribute(TABINDEX, '-1');\n        }\n      }\n\n      this._updateTabIndexes(child);\n    }\n  };\n\n  FocusZone.prototype._isContentEditableElement = function (element) {\n    return element && element.getAttribute('contenteditable') === 'true';\n  };\n\n  FocusZone.prototype._isElementInput = function (element) {\n    if (element && element.tagName && (element.tagName.toLowerCase() === 'input' || element.tagName.toLowerCase() === 'textarea')) {\n      return true;\n    }\n\n    return false;\n  };\n\n  FocusZone.prototype._shouldInputLoseFocus = function (element, isForward) {\n    // If a tab was used, we want to focus on the next element.\n    if (!this._processingTabKey && element && element.type && ALLOWED_INPUT_TYPES.indexOf(element.type.toLowerCase()) > -1) {\n      var selectionStart = element.selectionStart;\n      var selectionEnd = element.selectionEnd;\n      var isRangeSelected = selectionStart !== selectionEnd;\n      var inputValue = element.value;\n      var isReadonly = element.readOnly; // We shouldn't lose focus in the following cases:\n      // 1. There is range selected.\n      // 2. When selection start is larger than 0 and it is backward and not readOnly.\n      // 3. when selection start is not the end of length, it is forward and not readOnly.\n      // 4. We press any of the arrow keys when our handleTabKey isn't none or undefined (only losing focus if we hit\n      // tab) and if shouldInputLoseFocusOnArrowKey is defined, if scenario prefers to not loose the focus which is\n      // determined by calling the callback shouldInputLoseFocusOnArrowKey\n\n      if (isRangeSelected || selectionStart > 0 && !isForward && !isReadonly || selectionStart !== inputValue.length && isForward && !isReadonly || !!this.props.handleTabKey && !(this.props.shouldInputLoseFocusOnArrowKey && this.props.shouldInputLoseFocusOnArrowKey(element))) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  FocusZone.prototype._shouldWrapFocus = function (element, noWrapDataAttribute) {\n    return this.props.checkForNoWrap ? shouldWrapFocus(element, noWrapDataAttribute) : true;\n  };\n  /**\n   * Returns true if the element is a descendant of the FocusZone through a React portal.\n   */\n\n\n  FocusZone.prototype._portalContainsElement = function (element) {\n    return element && !!this._root.current && portalContainsElement(element, this._root.current);\n  };\n\n  FocusZone.prototype._getDocument = function () {\n    return getDocument(this._root.current);\n  };\n\n  FocusZone.defaultProps = {\n    isCircularNavigation: false,\n    direction: FocusZoneDirection.bidirectional,\n    shouldRaiseClicks: true\n  };\n  return FocusZone;\n}(React.Component);\n\nexport { FocusZone };","map":{"version":3,"mappings":";AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,kBAAT,EAA6BC,yBAA7B,QAA8D,mBAA9D;AACA,SACEC,QADF,EAEEC,GAFF,EAGEC,eAHF,EAIEC,WAJF,EAKEC,mBALF,EAMEC,uBANF,EAOEC,KAPF,EAQEC,cARF,EASEC,cATF,EAUEC,SAVF,EAWEC,kBAXF,EAYEC,MAZF,EAaEC,qBAbF,EAcEC,sBAdF,EAeEC,qBAfF,EAgBEC,kBAhBF,EAiBEC,iBAjBF,EAkBEC,eAlBF,EAmBEC,gBAnBF,EAoBEC,qBApBF,EAqBEC,SArBF,EAsBEC,oBAtBF,EAuBEC,eAvBF,QAwBO,qBAxBP;AAyBA,SAASC,WAAT,QAA4B,wBAA5B;AACA,SAASC,QAAT,QAAyB,2BAAzB;AAKA,IAAMC,sBAAsB,GAAG,mBAA/B;AACA,IAAMC,2BAA2B,GAAG,6BAApC;AACA,IAAMC,sBAAsB,GAAG,mBAA/B;AACA,IAAMC,QAAQ,GAAG,UAAjB;AACA,IAAMC,gBAAgB,GAAG,uBAAzB;AACA,IAAMC,kBAAkB,GAAG,yBAA3B;AACA,IAAMC,0BAA0B,GAAG,SAAnC;AACA,IAAMC,mCAAmC,GAAG,CAAC,SAA7C;AAEA,IAAIC,eAAJ;AAEA,IAAMC,cAAc,GAAW,cAA/B;AAEA;;;;AAGA,SAASC,2BAAT,CAAqCC,MAArC,EAAsDC,EAAtD,EAA2F;AACzF,MAAIC,KAAJ;;AACA,MAAI,OAAOC,UAAP,KAAsB,UAA1B,EAAsC;AACpCD,SAAK,GAAG,IAAIC,UAAJ,CAAe,OAAf,EAAwB;AAC9BC,aAAO,EAAEH,EAAE,SAAF,MAAE,WAAF,GAAE,MAAF,KAAE,CAAEG,OADiB;AAE9BC,aAAO,EAAEJ,EAAE,SAAF,MAAE,WAAF,GAAE,MAAF,KAAE,CAAEI,OAFiB;AAG9BC,cAAQ,EAAEL,EAAE,SAAF,MAAE,WAAF,GAAE,MAAF,KAAE,CAAEK,QAHgB;AAI9BC,YAAM,EAAEN,EAAE,SAAF,MAAE,WAAF,GAAE,MAAF,KAAE,CAAEM,MAJkB;AAK9BC,aAAO,EAAEP,EAAE,SAAF,MAAE,WAAF,GAAE,MAAF,KAAE,CAAEO,OALiB;AAM9BC,gBAAU,EAAER,EAAE,SAAF,MAAE,WAAF,GAAE,MAAF,KAAE,CAAEQ;AANc,KAAxB,CAAR;AAQD,GATD,MASO;AACLP,SAAK,GAAGQ,QAAQ,CAACC,WAAT,CAAqB,aAArB,CAAR;AACAT,SAAK,CAACU,cAAN,CACE,OADF,EAEEX,EAAE,GAAGA,EAAE,CAACO,OAAN,GAAgB,KAFpB,EAGEP,EAAE,GAAGA,EAAE,CAACQ,UAAN,GAAmB,KAHvB,EAIEI,MAJF,EAIU;AACR,KALF,EAKK;AACH,KANF,EAMK;AACH,KAPF,EAOK;AACH,KARF,EAQK;AACH,KATF,EASK;AACHZ,MAAE,GAAGA,EAAE,CAACG,OAAN,GAAgB,KAVpB,EAWEH,EAAE,GAAGA,EAAE,CAACM,MAAN,GAAe,KAXnB,EAYEN,EAAE,GAAGA,EAAE,CAACK,QAAN,GAAiB,KAZrB,EAaEL,EAAE,GAAGA,EAAE,CAACI,OAAN,GAAgB,KAbpB,EAcE,CAdF,EAcK;AACH,QAfF;AAiBD;;AAEDL,QAAM,CAACc,aAAP,CAAqBZ,KAArB;AACD,C,CAED;;;AACA,SAASa,YAAT,GAAqB;AACnB,MAAI,CAAClB,eAAL,EAAsB;AACpBA,mBAAe,GAAGV,WAAW,CAC3B;AACE6B,eAAS,EAAE;AACT,kBAAU;AACRC,iBAAO,EAAE;AADD;AADD;AADb,KAD2B,EAQ3BnB,cAR2B,CAA7B;AAUD;;AACD,SAAOD,eAAP;AACD;;AAED,IAAMqB,aAAa,GAEf,EAFJ;;AAGA,IAAMC,WAAW,GAAmB,IAAIC,GAAJ,EAApC;;AAEA,IAAMC,mBAAmB,GAAG,CAAC,MAAD,EAAS,QAAT,EAAmB,UAAnB,EAA+B,OAA/B,EAAwC,KAAxC,EAA+C,KAA/C,EAAsD,QAAtD,CAA5B;AAEA,IAAMC,sBAAsB,GAAG,KAA/B;;AAEA;AAAA;AAAA;AAA+BC;;AA0D7B,qBAAYC,KAAZ,EAAkC;;;AAAlC,gBACEC,kBAAMD,KAAN,KAAY,IADd;;AAnDQE,kBAAsCjE,KAAK,CAACkE,SAAN,EAAtC;AACAD,uBAAaxC,eAAe,EAA5B;;AAgUAwC,qBAAW,UAACzB,EAAD,EAAkC;AACnD,UAAIyB,KAAI,CAACE,sBAAL,CAA4B3B,EAAE,CAACD,MAA/B,CAAJ,EAA2D;AACzD;AACA;AACD;;AAEK,eAUF0B,KAAI,CAACF,KAVH;AAAA,UACJK,sBAAsB,4BADlB;AAAA,UAEJ;AACAC,qCAA+B,qCAH3B;AAAA,UAIJC,oBAAoB,0BAJhB;AAAA,UAKJ;AACAC,yBAAmB,yBANf;AAAA,UAOJC,OAAO,aAPH;AAAA,UAQJC,wCAAwC,8CARpC;AAAA,UASJC,sBAAsB,4BATlB;;AAWN,UAAMC,qBAAqB,GAAGV,KAAI,CAACW,4BAAL,CAAkCpC,EAAE,CAACD,MAArC,CAA9B;;AACA,UAAIsC,gBAAJ;;AAEA,UAAIF,qBAAJ,EAA2B;AACzBE,wBAAgB,GAAGrC,EAAE,CAACD,MAAtB;AACD,OAFD,MAEO;AACL,YAAIuC,aAAa,GAAGtC,EAAE,CAACD,MAAvB;;AAEA,eAAOuC,aAAa,IAAIA,aAAa,KAAKb,KAAI,CAACc,KAAL,CAAWC,OAArD,EAA8D;AAC5D,cAAI7D,iBAAiB,CAAC2D,aAAD,CAAjB,IAAoCb,KAAI,CAACW,4BAAL,CAAkCE,aAAlC,CAAxC,EAA0F;AACxFD,4BAAgB,GAAGC,aAAnB;AACA;AACD;;AACDA,uBAAa,GAAGlE,SAAS,CAACkE,aAAD,EAAgBjB,sBAAhB,CAAzB;AACD;AACF,OAhCkD,CAkCnD;;;AACA,UAAIY,wCAAwC,IAAIjC,EAAE,CAACD,MAAH,KAAc0B,KAAI,CAACc,KAAL,CAAWC,OAAzE,EAAkF;AAChF,YAAMC,mBAAmB,GACvBP,sBAAsB,IACtB,OAAOA,sBAAP,KAAkC,UADlC,IAEAT,KAAI,CAACc,KAAL,CAAWC,OAFX,IAGAN,sBAAsB,CAACT,KAAI,CAACc,KAAL,CAAWC,OAAZ,CAJxB,CADgF,CAOhF;;AACA,YAAIC,mBAAmB,IAAI9D,iBAAiB,CAAC8D,mBAAD,CAA5C,EAAmE;AACjEJ,0BAAgB,GAAGI,mBAAnB;AACAA,6BAAmB,CAACC,KAApB;AACD,SAHD,MAGO;AACL;AACAjB,eAAI,CAACiB,KAAL,CAAW,IAAX;;AACA,cAAIjB,KAAI,CAACkB,cAAT,EAAyB;AACvB;AACAN,4BAAgB,GAAG,IAAnB;AACD;AACF;AACF;;AAED,UAAMO,qBAAqB,GAAG,CAACnB,KAAI,CAACkB,cAApC,CAxDmD,CA0DnD;AACA;;AACA,UAAIN,gBAAgB,IAAIA,gBAAgB,KAAKZ,KAAI,CAACkB,cAAlD,EAAkE;AAChE,YAAIR,qBAAqB,IAAIS,qBAA7B,EAAoD;AAClDnB,eAAI,CAACoB,kBAAL,CAAwBR,gBAAxB,EAA0C,IAA1C,EAAgD,IAAhD;AACD;;AAEDZ,aAAI,CAACkB,cAAL,GAAsBN,gBAAtB;;AAEA,YAAIO,qBAAJ,EAA2B;AACzBnB,eAAI,CAACqB,iBAAL;AACD;AACF;;AAED,UAAIlB,sBAAJ,EAA4B;AAC1BA,8BAAsB,CAACH,KAAI,CAACkB,cAAN,EAAqC3C,EAArC,CAAtB;AACD;;AAED,UAAI8B,oBAAoB,IAAID,+BAA5B,EAA6D;AAC3D7B,UAAE,CAAC+C,eAAH;AACD;;AAED,UAAIf,OAAJ,EAAa;AACXA,eAAO,CAAChC,EAAD,CAAP;AACD,OAFD,MAEO,IAAI+B,mBAAJ,EAAyB;AAC9BA,2BAAmB;AACpB;AACF,KArFO;;AAoHAN,oBAAU;AAChBA,WAAI,CAACuB,eAAL,CAAqB,KAArB;AACD,KAFO;;AAIAvB,yBAAe,UAACzB,EAAD,EAAkC;AACvD,UAAIyB,KAAI,CAACE,sBAAL,CAA4B3B,EAAE,CAACD,MAA/B,CAAJ,EAA2D;AACzD;AACA;AACD;;AAEO,kBAAQ,GAAK0B,KAAI,CAACF,KAAL,CAAU0B,QAAvB;;AAER,UAAIA,QAAJ,EAAc;AACZ;AACD;;AAED,UAAIlD,MAAM,GAAGC,EAAE,CAACD,MAAhB;AACA,UAAMmD,IAAI,GAAG,EAAb;;AAEA,aAAOnD,MAAM,IAAIA,MAAM,KAAK0B,KAAI,CAACc,KAAL,CAAWC,OAAvC,EAAgD;AAC9CU,YAAI,CAACC,IAAL,CAAUpD,MAAV;AACAA,cAAM,GAAG3B,SAAS,CAAC2B,MAAD,EAASsB,sBAAT,CAAlB;AACD;;AAED,aAAO6B,IAAI,CAACE,MAAZ,EAAoB;AAClBrD,cAAM,GAAGmD,IAAI,CAACG,GAAL,EAAT;;AAEA,YAAItD,MAAM,IAAIpB,iBAAiB,CAACoB,MAAD,CAA/B,EAAyC;AACvC0B,eAAI,CAAC6B,iBAAL,CAAuBvD,MAAvB,EAA+B,IAA/B;AACD;;AAED,YAAIrB,kBAAkB,CAACqB,MAAD,CAAtB,EAAgC;AAC9B;AACA;AACD;AACF;AACF,KAhCO;AA4DR;;;;;AAGQ0B,uBAAa,UAACzB,EAAD,EAAuCuD,KAAvC,EAAoD;AACvE,UAAI9B,KAAI,CAACE,sBAAL,CAA4B3B,EAAE,CAACD,MAA/B,CAAJ,EAA2D;AACzD;AACA;AACD,OAJsE,CAMvE;;;AACM,eAA6F0B,KAAI,CAACF,KAAlG;AAAA,UAAEiC,SAAS,eAAX;AAAA,UAAaP,QAAQ,cAArB;AAAA,UAAuBQ,oBAAoB,0BAA3C;AAAA,UAA6CC,qBAAqB,2BAAlE;AAAA,UAAoEC,oBAAoB,0BAAxF;;AAEN,UAAIV,QAAJ,EAAc;AACZ;AACD;;AAED,UAAIxB,KAAI,CAACF,KAAL,CAAWqC,SAAf,EAA0B;AACxBnC,aAAI,CAACF,KAAL,CAAWqC,SAAX,CAAqB5D,EAArB;AACD,OAfsE,CAiBvE;;;AACA,UAAIA,EAAE,CAAC6D,kBAAH,EAAJ,EAA6B;AAC3B;AACD;;AAED,UAAIpC,KAAI,CAACqC,YAAL,GAAoBC,aAApB,KAAsCtC,KAAI,CAACc,KAAL,CAAWC,OAAjD,IAA4Df,KAAI,CAACuC,YAArE,EAAmF;AACjF;AACA;AACA;AACD;;AAED,UACE,CAAEL,oBAAoB,IAAIA,oBAAoB,CAAC3D,EAAD,CAA7C,IAAuDyD,oBAAoB,IAAIA,oBAAoB,CAACzD,EAAD,CAApG,KACAyB,KAAI,CAACW,4BAAL,CAAkCpC,EAAE,CAACD,MAArC,CAFF,EAGE;AACA;AACA,YAAMkE,SAAS,GAAGxC,KAAI,CAACyC,kBAAL,EAAlB;;AAEA,YAAID,SAAJ,EAAe;AACb,cAAI,CAACA,SAAS,CAACvB,KAAV,CAAgB,IAAhB,CAAL,EAA4B;AAC1B;AACD;AACF,SAJD,MAIO,IAAIjE,qBAAqB,CAACuB,EAAE,CAACD,MAAJ,CAAzB,EAAqD;AAC1D,cACE,CAAC0B,KAAI,CAAC0C,YAAL,CACChG,cAAc,CACZ6B,EAAE,CAACD,MADS,EAEXC,EAAE,CAACD,MAAH,CAA0BqE,UAFf,EAGZ,IAHY,CADf,CADH,EAQE;AACA;AACD;AACF,SAZM,MAYA;AACL;AACD;AACF,OA1BD,MA0BO,IAAIpE,EAAE,CAACM,MAAP,EAAe;AACpB;AACD,OAFM,MAEA;AACL;AACA,gBAAQN,EAAE,CAACqE,KAAX;AACE,eAAK1G,QAAQ,CAAC2G,KAAd;AACE,gBAAI7C,KAAI,CAAC8C,yBAAL,IAAkC9C,KAAI,CAAC+C,2BAAL,CAAiCxE,EAAE,CAACD,MAApC,EAA2DC,EAA3D,CAAtC,EAAsG;AACpG;AACD;;AACD;;AAEF,eAAKrC,QAAQ,CAAC8G,IAAd;AACE,gBAAIjB,SAAS,KAAK/F,kBAAkB,CAACiH,QAArC,EAA+C;AAC7CjD,mBAAI,CAACkD,0BAAL,CAAgC3E,EAAhC;;AACA,kBAAIyB,KAAI,CAACmD,cAAL,CAAoBrB,KAApB,CAAJ,EAAgC;AAC9B;AACD;AACF;;AACD;;AAEF,eAAK5F,QAAQ,CAACkH,KAAd;AACE,gBAAIrB,SAAS,KAAK/F,kBAAkB,CAACiH,QAArC,EAA+C;AAC7CjD,mBAAI,CAACkD,0BAAL,CAAgC3E,EAAhC;;AACA,kBAAIyB,KAAI,CAACqD,eAAL,CAAqBvB,KAArB,CAAJ,EAAiC;AAC/B;AACD;AACF;;AACD;;AAEF,eAAK5F,QAAQ,CAACoH,EAAd;AACE,gBAAIvB,SAAS,KAAK/F,kBAAkB,CAACuH,UAArC,EAAiD;AAC/CvD,mBAAI,CAACkD,0BAAL,CAAgC3E,EAAhC;;AACA,kBAAIyB,KAAI,CAACwD,YAAL,EAAJ,EAAyB;AACvB;AACD;AACF;;AACD;;AAEF,eAAKtH,QAAQ,CAACuH,IAAd;AACE,gBAAI1B,SAAS,KAAK/F,kBAAkB,CAACuH,UAArC,EAAiD;AAC/CvD,mBAAI,CAACkD,0BAAL,CAAgC3E,EAAhC;;AACA,kBAAIyB,KAAI,CAAC0D,cAAL,EAAJ,EAA2B;AACzB;AACD;AACF;;AACD;;AACF,eAAKxH,QAAQ,CAACyH,QAAd;AACE,gBAAI,CAAC1B,qBAAD,IAA0BjC,KAAI,CAAC4D,gBAAL,CAAsB,IAAtB,CAA9B,EAA2D;AACzD;AACD;;AACD;;AACF,eAAK1H,QAAQ,CAAC2H,MAAd;AACE,gBAAI,CAAC5B,qBAAD,IAA0BjC,KAAI,CAAC4D,gBAAL,CAAsB,KAAtB,CAA9B,EAA4D;AAC1D;AACD;;AACD;;AAEF,eAAK1H,QAAQ,CAAC4H,GAAd;AACE,iBACE;AACA9D,iBAAI,CAACF,KAAL,CAAWiE,WAAX,IACA/D,KAAI,CAACF,KAAL,CAAWkE,YAAX,KAA4B/H,yBAAyB,CAACgI,GADtD,IAECjE,KAAI,CAACF,KAAL,CAAWkE,YAAX,KAA4B/H,yBAAyB,CAACiI,SAAtD,IACClE,KAAI,CAACmE,eAAL,CAAqB5F,EAAE,CAACD,MAAxB,CALJ,EAME;AACA,kBAAI8F,YAAY,GAAG,KAAnB;AACApE,mBAAI,CAACqE,iBAAL,GAAyB,IAAzB;;AACA,kBACEtC,SAAS,KAAK/F,kBAAkB,CAACiH,QAAjC,IACA,CAACjD,KAAI,CAACsE,gBAAL,CAAsBtE,KAAI,CAACkB,cAA3B,EAA0DlD,kBAA1D,CAFH,EAGE;AACAoG,4BAAY,GAAG7F,EAAE,CAACK,QAAH,GAAcoB,KAAI,CAACwD,YAAL,EAAd,GAAoCxD,KAAI,CAAC0D,cAAL,EAAnD;AACD,eALD,MAKO;AACL,oBAAMa,gBAAgB,GAAG1H,MAAM,CAACiF,KAAD,CAAN,GAAgB,CAACvD,EAAE,CAACK,QAApB,GAA+BL,EAAE,CAACK,QAA3D;AACAwF,4BAAY,GAAGG,gBAAgB,GAAGvE,KAAI,CAACmD,cAAL,CAAoBrB,KAApB,CAAH,GAAgC9B,KAAI,CAACqD,eAAL,CAAqBvB,KAArB,CAA/D;AACD;;AACD9B,mBAAI,CAACqE,iBAAL,GAAyB,KAAzB;;AACA,kBAAID,YAAJ,EAAkB;AAChB;AACD,eAFD,MAEO,IAAIpE,KAAI,CAACF,KAAL,CAAW0E,uCAAf,EAAwD;AAC7DxE,qBAAI,CAACkB,cAAL,GAAsB,IAAtB;AACD;AACF;;AACD;;AAEF,eAAKhF,QAAQ,CAACuI,IAAd;AACE,gBACEzE,KAAI,CAAC0E,yBAAL,CAA+BnG,EAAE,CAACD,MAAlC,KACC0B,KAAI,CAACmE,eAAL,CAAqB5F,EAAE,CAACD,MAAxB,KACC,CAAC0B,KAAI,CAAC2E,qBAAL,CAA2BpG,EAAE,CAACD,MAA9B,EAA0D,KAA1D,CAHL,EAIE;AACA,qBAAO,KAAP;AACD;;AACD,gBAAMqE,UAAU,GAAG3C,KAAI,CAACc,KAAL,CAAWC,OAAX,IAAuBf,KAAI,CAACc,KAAL,CAAWC,OAAX,CAAmB4B,UAA7D;;AACA,gBACE3C,KAAI,CAACc,KAAL,CAAWC,OAAX,IACA4B,UADA,IAEA3C,KAAI,CAAC0C,YAAL,CAAkBhG,cAAc,CAACsD,KAAI,CAACc,KAAL,CAAWC,OAAZ,EAAqB4B,UAArB,EAAiC,IAAjC,CAAhC,CAHF,EAIE;AACA;AACD;;AACD;;AAEF,eAAKzG,QAAQ,CAAC0I,GAAd;AACE,gBACE5E,KAAI,CAAC0E,yBAAL,CAA+BnG,EAAE,CAACD,MAAlC,KACC0B,KAAI,CAACmE,eAAL,CAAqB5F,EAAE,CAACD,MAAxB,KACC,CAAC0B,KAAI,CAAC2E,qBAAL,CAA2BpG,EAAE,CAACD,MAA9B,EAA0D,IAA1D,CAHL,EAIE;AACA,qBAAO,KAAP;AACD;;AAED,gBAAMuG,SAAS,GAAG7E,KAAI,CAACc,KAAL,CAAWC,OAAX,IAAuBf,KAAI,CAACc,KAAL,CAAWC,OAAX,CAAmB8D,SAA5D;;AACA,gBACE7E,KAAI,CAACc,KAAL,CAAWC,OAAX,IACAf,KAAI,CAAC0C,YAAL,CAAkB9F,kBAAkB,CAACoD,KAAI,CAACc,KAAL,CAAWC,OAAZ,EAAqB8D,SAArB,EAAgC,IAAhC,EAAsC,IAAtC,EAA4C,IAA5C,CAApC,CAFF,EAGE;AACA;AACD;;AACD;;AAEF,eAAK3I,QAAQ,CAAC4I,KAAd;AACE,gBAAI9E,KAAI,CAAC+E,yBAAL,IAAkC/E,KAAI,CAAC+C,2BAAL,CAAiCxE,EAAE,CAACD,MAApC,EAA2DC,EAA3D,CAAtC,EAAsG;AACpG;AACD;;AACD;;AAEF;AACE;AA5HJ;AA8HD;;AAEDA,QAAE,CAACyG,cAAH;AACAzG,QAAE,CAAC+C,eAAH;AACD,KA5LO;;AAufAtB,6CAAmC,UACzCiF,SADyC,EAEzCC,UAFyC,EAGzCC,UAHyC,EAGnB;AAEtB;AACA,UAAMC,aAAa,GAAGpF,KAAI,CAACqF,eAAL,CAAqBrC,IAArB,IAA6BhD,KAAI,CAACqF,eAAL,CAAqBC,CAAlD,IAAuD,CAA7E,CAHsB,CAItB;AACA;AACA;AACA;;AACA,UAAMC,aAAa,GAAGC,IAAI,CAACC,KAAL,CAAWN,UAAU,CAACO,GAAtB,CAAtB;AACA,UAAMC,gBAAgB,GAAGH,IAAI,CAACC,KAAL,CAAWP,UAAU,CAACU,MAAtB,CAAzB;AACA,UAAMC,gBAAgB,GAAGL,IAAI,CAACC,KAAL,CAAWN,UAAU,CAACS,MAAtB,CAAzB;AACA,UAAME,aAAa,GAAGN,IAAI,CAACC,KAAL,CAAWP,UAAU,CAACQ,GAAtB,CAAtB;AACA,UAAMK,4BAA4B,GAAGd,SAAS,IAAIM,aAAa,GAAGI,gBAAlE;AACA,UAAMK,0BAA0B,GAAG,CAACf,SAAD,IAAcY,gBAAgB,GAAGC,aAApE;;AAEA,UAAIC,4BAA4B,IAAIC,0BAApC,EAAgE;AAC9D,YAAIZ,aAAa,IAAID,UAAU,CAACnC,IAA5B,IAAoCoC,aAAa,IAAID,UAAU,CAACnC,IAAX,GAAkBmC,UAAU,CAACc,KAAtF,EAA6F;AAC3F,iBAAO,CAAP;AACD;;AACD,eAAOT,IAAI,CAACU,GAAL,CAASf,UAAU,CAACnC,IAAX,GAAkBmC,UAAU,CAACc,KAAX,GAAmB,CAArC,GAAyCb,aAAlD,CAAP;AACD;;AAED,UAAI,CAACpF,KAAI,CAACsE,gBAAL,CAAsBtE,KAAI,CAACkB,cAA3B,EAA0DnD,gBAA1D,CAAL,EAAkF;AAChF,eAAOG,mCAAP;AACD;;AACD,aAAOD,0BAAP;AACD,KA7BO,CA57B0B,CAEhC;;;AACAlB,0BAAsB,CAACiD,KAAD,CAAtB;;AAEA,QAAImG,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzCjJ,sBAAgB,CAAC,WAAD,EAAc0C,KAAd,EAAqB;AACnCwG,iBAAS,EAAEC,SADwB;AAEnCxC,mBAAW,EAAE,cAFsB;AAGnCyC,mBAAW,EAAE,IAHsB;AAInCC,uBAAe,EAAE,kBAJkB;AAKnCC,sBAAc,EAAE;AALmB,OAArB,CAAhB;AAOD;;AAED1G,SAAI,CAAC2G,GAAL,GAAWnK,KAAK,CAAC,WAAD,CAAhB;AAEAwD,SAAI,CAACqF,eAAL,GAAuB;AACrBrC,UAAI,EAAE,CADe;AAErB0C,SAAG,EAAE;AAFgB,KAAvB;AAKA1F,SAAI,CAACqE,iBAAL,GAAyB,KAAzB;AAEA,QAAMuC,yBAAyB,GAAG,iBAAK,CAACC,iBAAN,MAAuB,IAAvB,IAAuBC,aAAvB,GAAuBA,EAAvB,GAA2BC,SAAS,CAACC,YAAV,CAAuBH,iBAAlD,MAAmE,IAAnE,IAAmEI,aAAnE,GAAmEA,EAAnE,GAAuE,IAAzG;AACAjH,SAAI,CAAC+E,yBAAL,GAAiC,WAAK,CAACmC,wBAAN,MAA8B,IAA9B,IAA8BC,aAA9B,GAA8BA,EAA9B,GAAkCP,yBAAnE;AACA5G,SAAI,CAAC8C,yBAAL,GAAiC,WAAK,CAACsE,wBAAN,MAA8B,IAA9B,IAA8BC,aAA9B,GAA8BA,EAA9B,GAAkCT,yBAAnE;;AACD;AA5CD;;;AACcG,4BAAd;AACE,WAAOtH,WAAW,CAAC6H,IAAnB;AACD,GAFa;AAId;;;;;;;AAKeP,gCAAf,UAAiCxI,EAAjC,EAAkD;AAChD;AACA,QAAIA,EAAE,CAACqE,KAAH,KAAa1G,QAAQ,CAAC4H,GAA1B,EAA+B;AAC7BrE,iBAAW,CAAC8H,OAAZ,CAAoB,UAACC,IAAD,EAAgB;AAAK,mBAAI,CAACnG,iBAAL;AAAwB,OAAjE;AACD;AACF,GALc;;AAoCR0F,0CAAP;AACU,QAASU,IAAI,GAAK,KAAK3G,KAAL,CAAUC,OAA5B;AAERvB,iBAAa,CAAC,KAAKmH,GAAN,CAAb,GAA0B,IAA1B;;AAEA,QAAIc,IAAJ,EAAU;AACR,WAAKC,cAAL,GAAsBpK,SAAS,CAACmK,IAAD,CAA/B;AACA,UAAI5G,aAAa,GAAGlE,SAAS,CAAC8K,IAAD,EAAO7H,sBAAP,CAA7B;;AAEA,aAAOiB,aAAa,IAAIA,aAAa,KAAK,KAAKwB,YAAL,GAAoBsF,IAAvD,IAA+D9G,aAAa,CAAC+G,QAAd,KAA2B,CAAjG,EAAoG;AAClG,YAAI3K,kBAAkB,CAAC4D,aAAD,CAAtB,EAAuC;AACrC,eAAK0B,YAAL,GAAoB,IAApB;AACA;AACD;;AACD1B,qBAAa,GAAGlE,SAAS,CAACkE,aAAD,EAAgBjB,sBAAhB,CAAzB;AACD;;AAED,UAAI,CAAC,KAAK2C,YAAV,EAAwB;AACtB9C,mBAAW,CAACoI,GAAZ,CAAgB,IAAhB;;AAEA,YAAI,KAAKH,cAAL,IAAuBjI,WAAW,CAAC6H,IAAZ,KAAqB,CAAhD,EAAmD;AACjD,eAAKI,cAAL,CAAoBI,gBAApB,CAAqC,SAArC,EAAgDf,SAAS,CAACgB,iBAA1D,EAA6E,IAA7E;AACD;AACF;;AAED,WAAKjH,KAAL,CAAWC,OAAX,IAAsB,KAAKD,KAAL,CAAWC,OAAX,CAAmB+G,gBAAnB,CAAoC,MAApC,EAA4C,KAAKE,OAAjD,EAA0D,IAA1D,CAAtB,CApBQ,CAsBR;;AACA,WAAK3G,iBAAL;;AAEA,UAAI,KAAKvB,KAAL,CAAWW,sBAAX,IAAqC,OAAO,KAAKX,KAAL,CAAWW,sBAAlB,KAA6C,QAAtF,EAAgG;AAC9F,aAAKS,cAAL,GAAsB,KAAKmB,YAAL,GAAoB4F,aAApB,CAAkC,KAAKnI,KAAL,CAAWW,sBAA7C,CAAtB,CAD8F,CAE9F;AACD,OAHD,MAGO,IAAI,KAAKX,KAAL,CAAWoI,oBAAf,EAAqC;AAC1C;AACA,aAAKhH,cAAL,GAAsB,KAAKmB,YAAL,GAAoB4F,aAApB,CAAkC,KAAKnI,KAAL,CAAWoI,oBAA7C,CAAtB;AACD;;AAED,UAAI,KAAKpI,KAAL,CAAWqI,kBAAf,EAAmC;AACjC,aAAKlH,KAAL;AACD;AACF;AACF,GA1CM;;AA4CA8F,2CAAP;AACU,QAASU,IAAI,GAAK,KAAK3G,KAAL,CAAUC,OAA5B;;AACR,QAAMqH,GAAG,GAAG,KAAK/F,YAAL,EAAZ;;AAEA,QACE,CAAC,KAAKvC,KAAL,CAAWuI,uBAAZ,IACAD,GADA,IAEA,KAAKE,cAFL,KAGCF,GAAG,CAAC9F,aAAJ,KAAsB8F,GAAG,CAACT,IAA1B,IAAkCS,GAAG,CAAC9F,aAAJ,KAAsB,IAAxD,IAAgE8F,GAAG,CAAC9F,aAAJ,KAAsBmF,IAHvF,CADF,EAKE;AACA;AACA,UAAMc,cAAc,GAAGhM,uBAAuB,CAACkL,IAAD,EAAsB,KAAKa,cAA3B,CAA9C;;AAEA,UAAIC,cAAJ,EAAoB;AAClB,aAAK1G,iBAAL,CAAuB0G,cAAvB,EAAuC,IAAvC;;AACAA,sBAAc,CAACtH,KAAf;;AACA,aAAKM,eAAL,CAAqB,KAArB;AACD,OAJD,MAIO;AACL;AACA;AACA,aAAKA,eAAL,CAAqB,IAArB;AACD;AACF;AACF,GAvBM;;AAyBAwF,6CAAP;AACE,WAAOvH,aAAa,CAAC,KAAKmH,GAAN,CAApB;;AAEA,QAAI,CAAC,KAAKpE,YAAV,EAAwB;AACtB9C,iBAAW,CAAC+I,MAAZ,CAAmB,IAAnB,EADsB,CAGtB;;;AACA,UAAI,KAAKd,cAAL,IAAuBjI,WAAW,CAAC6H,IAAZ,KAAqB,CAAhD,EAAmD;AACjD,aAAKI,cAAL,CAAoBe,mBAApB,CAAwC,SAAxC,EAAmD1B,SAAS,CAACgB,iBAA7D,EAAgF,IAAhF;AACD;AACF;;AAED,QAAI,KAAKjH,KAAL,CAAWC,OAAf,EAAwB;AACtB,WAAKD,KAAL,CAAWC,OAAX,CAAmB0H,mBAAnB,CAAuC,MAAvC,EAA+C,KAAKT,OAApD,EAA6D,IAA7D;AACD;;AAED,SAAK9G,cAAL,GAAsB,IAAtB;AACA,SAAKwH,oBAAL,GAA4B,IAA5B;AACD,GAlBM;;AAoBA3B,+BAAP;AAAA,sBACE;;;AACM,aAAkF,KAAKjH,KAAvF;AAAA,QAAM6I,GAAG,QAAT;AAAA,QAAWnC,WAAW,iBAAtB;AAAA,QAAwBF,SAAS,eAAjC;AAAA,QAAmCG,eAAe,qBAAlD;AAAA,QAAoDC,cAAc,oBAAlE;AAAA,QAAoEkC,SAAS,eAA7E;AACN,QAAMC,QAAQ,GAAGpM,cAAc,CAAC,KAAKqD,KAAN,EAAahD,qBAAb,CAA/B;AAEA,QAAMgM,GAAG,GAAGH,GAAG,IAAInC,WAAP,IAAsB,KAAlC,CALF,CAOE;AACA;AACA;AACA;AACA;;AACA,SAAKuC,0BAAL,GAZF,CAcE;;;AACA,QAAMjH,KAAK,GAAWpE,QAAQ,EAA9B;AAEA,WACE3B,oBAAC+M,GAAD,EAAIE;AAAA,yBACetC,cADf;AAC6B,0BACbD;AAFhB,OAGEoC,QAHF,EASIvC,SATJ,EASqB;AAEvB;AACA;AACA;AACAsC,eAAS,EAAEzM,GAAG,CAACkD,YAAY,EAAb,EAAiBuJ,SAAjB,CALS;AAMvB;AACAK,SAAG,EAAE,KAAKC,UAAL,CAAgB,KAAKpJ,KAAL,CAAWqJ,UAA3B,EAAuC,KAAKrI,KAA5C,CAPkB;AAOgC,2BACpC,KAAK6F,GARD;AASvB;AACAxE,eAAS,EAAE,UAAC5D,EAAD,EAAqC;AAAK,oBAAI,CAAC6K,UAAL,CAAgB7K,EAAhB,EAAoBuD,KAApB;AAA0B,OAVxD;AAWvBvB,aAAO,EAAE,KAAK8I,QAXS;AAYvBC,wBAAkB,EAAE,KAAKC;AAZF,KATrB,CAAJ,EAuBG,KAAKzJ,KAAL,CAAW0J,QAvBd,CADF;AA2BD,GA5CM;AA8CP;;;;;;;;AAMOzC,8BAAP,UAAa0C,qBAAb,EAAmD;AAAtC;AAAAA;AAAsC;;AACjD,QAAI,KAAK3I,KAAL,CAAWC,OAAf,EAAwB;AACtB,UACE,CAAC0I,qBAAD,IACA,KAAK3I,KAAL,CAAWC,OAAX,CAAmB2I,YAAnB,CAAgC/L,sBAAhC,MAA4D,MAD5D,IAEA,KAAK4E,YAHP,EAIE;AACA,YAAMoH,gBAAgB,GAAG,KAAKC,aAAL,CAAmB,KAAK9I,KAAL,CAAWC,OAA9B,CAAzB;;AAEA,YAAI4I,gBAAgB,KAAK,KAAK7I,KAAL,CAAWC,OAApC,EAA6C;AAC3C,cAAM8I,SAAS,GAAGrK,aAAa,CAACmK,gBAAgB,CAACD,YAAjB,CAA8B7L,sBAA9B,CAAD,CAA/B;;AAEA,iBAAO,CAAC,CAACgM,SAAF,IAAeA,SAAS,CAACnH,YAAV,CAAuB,KAAK5B,KAAL,CAAWC,OAAlC,CAAtB;AACD;;AAED,eAAO,KAAP;AACD,OAdD,MAcO,IACL,CAAC0I,qBAAD,IACA,KAAKvI,cADL,IAEA9E,eAAe,CAAC,KAAK0E,KAAL,CAAWC,OAAZ,EAAqB,KAAKG,cAA1B,CAFf,IAGAhE,iBAAiB,CAAC,KAAKgE,cAAN,CAJZ,EAKL;AACA,aAAKA,cAAL,CAAoBD,KAApB;;AACA,eAAO,IAAP;AACD,OARM,MAQA;AACL,YAAM0B,UAAU,GAAG,KAAK7B,KAAL,CAAWC,OAAX,CAAmB4B,UAAtC;AAEA,eAAO,KAAKD,YAAL,CAAkBhG,cAAc,CAAC,KAAKoE,KAAL,CAAWC,OAAZ,EAAqB4B,UAArB,EAAiC,IAAjC,CAAhC,CAAP;AACD;AACF;;AACD,WAAO,KAAP;AACD,GA/BM;AAiCP;;;;;;AAIOoE,kCAAP;AACE,QAAI,KAAKjG,KAAL,CAAWC,OAAf,EAAwB;AACtB,UAAM8D,SAAS,GAAG,KAAK/D,KAAL,CAAWC,OAAX,IAAuB,KAAKD,KAAL,CAAWC,OAAX,CAAmB8D,SAA5D;AAEA,aAAO,KAAKnC,YAAL,CAAkB9F,kBAAkB,CAAC,KAAKkE,KAAL,CAAWC,OAAZ,EAAqB8D,SAArB,EAAgC,IAAhC,EAAsC,IAAtC,EAA4C,IAA5C,CAApC,CAAP;AACD;;AAED,WAAO,KAAP;AACD,GARM;AAUP;;;;;;;;;;AAQOkC,qCAAP,UAAoB+C,OAApB,EAA0CC,cAA1C,EAAkE;AAChE;AACM,aAAwC,KAAKjK,KAA7C;AAAA,QAAEkK,aAAa,mBAAf;AAAA,QAAiBC,kBAAkB,wBAAnC;;AAEN,QAAKA,kBAAkB,IAAI,CAACA,kBAAkB,CAACH,OAAD,CAA1C,IAAyDE,aAAa,IAAI,CAACA,aAAa,CAACF,OAAD,CAA5F,EAAwG;AACtG,aAAO,KAAP;AACD;;AAED,QAAIA,OAAJ,EAAa;AACX;AACA,WAAKjI,iBAAL,CAAuBiI,OAAvB,EAAgCC,cAAhC;;AACA,UAAI,KAAK7I,cAAT,EAAyB;AACvB,aAAKA,cAAL,CAAoBD,KAApB;AACD;;AAED,aAAO,IAAP;AACD;;AAED,WAAO,KAAP;AACD,GAnBM;AAqBP;;;;;;;AAKO8F,0CAAP,UAAyBmD,KAAzB,EAAqC;AACnC,SAAK7E,eAAL,GAAuB6E,KAAvB;AACD,GAFM;;AAICnD,mDAAR;AACU,QAASU,IAAI,GAAK,KAAK3G,KAAL,CAAUC,OAA5B;;AAER,QAAMqH,GAAG,GAAG,KAAK/F,YAAL,EAAZ;;AACA,QAAI+F,GAAJ,EAAS;AACP,UAAM+B,cAAc,GAAG/B,GAAG,CAAC9F,aAA3B,CADO,CAGP;;AACA,UAAI6H,cAAc,KAAK1C,IAAvB,EAA6B;AAC3B,YAAM2C,kBAAkB,GAAGhO,eAAe,CAACqL,IAAD,EAAO0C,cAAP,EAAuB,KAAvB,CAA1C;AACA,aAAK7B,cAAL,GAAsB8B,kBAAkB,GAAG9N,mBAAmB,CAACmL,IAAD,EAAsB0C,cAAtB,CAAtB,GAA8D5D,SAAtG;AACD;AACF;AACF,GAbO;AAsGR;;;;;;;;AAMQQ,wCAAR,UAAwBsD,QAAxB,EAAyC;AAC/B,QAAS5C,IAAI,GAAK,KAAK3G,KAAL,CAAUC,OAA5B;;AAER,QAAI0G,IAAI,IAAI,KAAK6C,SAAL,KAAmBD,QAA/B,EAAyC;AACvC,WAAKC,SAAL,GAAiBD,QAAjB;;AAEA,UAAIA,QAAJ,EAAc;AACZ,YAAI,CAAC,KAAKvK,KAAL,CAAWyK,cAAhB,EAAgC;AAC9B,eAAKC,eAAL,GAAuB/C,IAAI,CAACiC,YAAL,CAAkB,UAAlB,CAAvB;AACAjC,cAAI,CAACgD,YAAL,CAAkB,UAAlB,EAA8B,IAA9B;AACD;;AACDhD,YAAI,CAACxG,KAAL;AACD,OAND,MAMO,IAAI,CAAC,KAAKnB,KAAL,CAAWyK,cAAhB,EAAgC;AACrC,YAAI,KAAKC,eAAT,EAA0B;AACxB/C,cAAI,CAACgD,YAAL,CAAkB,UAAlB,EAA8B,KAAKD,eAAnC;AACA,eAAKA,eAAL,GAAuBjE,SAAvB;AACD,SAHD,MAGO;AACLkB,cAAI,CAACiD,eAAL,CAAqB,UAArB;AACD;AACF;AACF;AACF,GArBO;;AA6DA3D,0CAAR,UAA0B+C,OAA1B,EAAgDC,cAAhD,EAAwE;AACtE,QAAMY,qBAAqB,GAAG,KAAKzJ,cAAnC;AAEA,SAAKA,cAAL,GAAsB4I,OAAtB;;AAEA,QAAIa,qBAAJ,EAA2B;AACzB,UAAI1N,kBAAkB,CAAC0N,qBAAD,CAAtB,EAA+C;AAC7C,aAAKtJ,iBAAL,CAAuBsJ,qBAAvB;AACD;;AAEDA,2BAAqB,CAACC,QAAtB,GAAiC,CAAC,CAAlC;AACD;;AAED,QAAI,KAAK1J,cAAT,EAAyB;AACvB,UAAI,CAAC,KAAKmE,eAAN,IAAyB0E,cAA7B,EAA6C;AAC3C,aAAK3I,kBAAL,CAAwB0I,OAAxB,EAAiC,IAAjC,EAAuC,IAAvC;AACD;;AAED,WAAK5I,cAAL,CAAoB0J,QAApB,GAA+B,CAA/B;AACD;AACF,GApBO;;AAsBA7D,mDAAR,UAAmCxI,EAAnC,EAAuE;AACrE,SAAKuB,KAAL,CAAW+K,yBAAX,IAAwCtM,EAAE,CAACyG,cAAH,EAAxC;AACD,GAFO;AAqMR;;;;;AAGQ+B,oDAAR,UAAoC+D,aAApC,EAAgEvM,EAAhE,EAAqG;AACnG,QAAID,MAAM,GAAGwM,aAAb;;AACA,QAAIxM,MAAM,KAAK,KAAKwC,KAAL,CAAWC,OAA1B,EAAmC;AACjC,aAAO,KAAP;AACD;;AAED,OAAG;AACD,UACEzC,MAAM,CAACyM,OAAP,KAAmB,QAAnB,IACAzM,MAAM,CAACyM,OAAP,KAAmB,GADnB,IAEAzM,MAAM,CAACyM,OAAP,KAAmB,OAFnB,IAGAzM,MAAM,CAACyM,OAAP,KAAmB,UAJrB,EAKE;AACA,eAAO,KAAP;AACD;;AAED,UACE,KAAKpK,4BAAL,CAAkCrC,MAAlC,KACAA,MAAM,CAACoL,YAAP,CAAoB/L,sBAApB,MAAgD,MADhD,IAEAW,MAAM,CAACoL,YAAP,CAAoB9L,2BAApB,MAAqD,MAHvD,EAIE;AACAS,mCAA2B,CAACC,MAAD,EAASC,EAAT,CAA3B;AACA,eAAO,IAAP;AACD;;AAEDD,YAAM,GAAG3B,SAAS,CAAC2B,MAAD,EAASsB,sBAAT,CAAlB;AACD,KApBD,QAoBStB,MAAM,KAAK,KAAKwC,KAAL,CAAWC,OApB/B;;AAsBA,WAAO,KAAP;AACD,GA7BO;AA+BR;;;;;AAGQgG,2CAAR,UAA2BiE,WAA3B,EAA2D;AACzDA,eAAW,GAAGA,WAAW,IAAI,KAAK9J,cAApB,IAAsC,KAAKJ,KAAL,CAAWC,OAA/D;;AAEA,QAAI,CAACiK,WAAL,EAAkB;AAChB,aAAO,IAAP;AACD;;AAED,QAAI/N,kBAAkB,CAAC+N,WAAD,CAAtB,EAAqC;AACnC,aAAOxL,aAAa,CAACwL,WAAW,CAACtB,YAAZ,CAAyB7L,sBAAzB,CAAD,CAApB;AACD;;AAED,QAAIoN,KAAK,GAAGD,WAAW,CAACE,iBAAxB;;AAEA,WAAOD,KAAP,EAAc;AACZ,UAAIhO,kBAAkB,CAACgO,KAAD,CAAtB,EAA+B;AAC7B,eAAOzL,aAAa,CAACyL,KAAK,CAACvB,YAAN,CAAmB7L,sBAAnB,CAAD,CAApB;AACD;;AACD,UAAMsN,KAAK,GAAG,KAAK1I,kBAAL,CAAwBwI,KAAxB,CAAd;;AAEA,UAAIE,KAAJ,EAAW;AACT,eAAOA,KAAP;AACD;;AAEDF,WAAK,GAAGA,KAAK,CAACG,kBAAd;AACD;;AAED,WAAO,IAAP;AACD,GA3BO;;AA6BArE,mCAAR,UACE9B,SADF,EAEEoG,qBAFF,EAGE9M,EAHF,EAIE+M,cAJF,EAIgC;AAA9B;AAAAA;AAA8B;;AAE9B,QAAIxB,OAAO,GAAG,KAAK5I,cAAnB;AACA,QAAIqK,iBAAiB,GAAG,CAAC,CAAzB;AACA,QAAIC,gBAAgB,GAA4BjF,SAAhD;AACA,QAAIkF,YAAY,GAAG,KAAnB;AACA,QAAMC,eAAe,GAAG,KAAK5L,KAAL,CAAWiC,SAAX,KAAyB/F,kBAAkB,CAAC2P,aAApE;;AAEA,QAAI,CAAC7B,OAAD,IAAY,CAAC,KAAKhJ,KAAL,CAAWC,OAA5B,EAAqC;AACnC,aAAO,KAAP;AACD;;AAED,QAAI,KAAKoD,eAAL,CAAqB2F,OAArB,CAAJ,EAAmC;AACjC,UAAI,CAAC,KAAKnF,qBAAL,CAA2BmF,OAA3B,EAAwD7E,SAAxD,CAAL,EAAyE;AACvE,eAAO,KAAP;AACD;AACF;;AAED,QAAMC,UAAU,GAAGwG,eAAe,GAAG5B,OAAO,CAAC8B,qBAAR,EAAH,GAAqC,IAAvE;;AAEA,OAAG;AACD9B,aAAO,GAAI7E,SAAS,GAChBvI,cAAc,CAAC,KAAKoE,KAAL,CAAWC,OAAZ,EAAqB+I,OAArB,CADE,GAEhBlN,kBAAkB,CAAC,KAAKkE,KAAL,CAAWC,OAAZ,EAAqB+I,OAArB,CAFtB;;AAIA,UAAI4B,eAAJ,EAAqB;AACnB,YAAI5B,OAAJ,EAAa;AACX,cAAM3E,UAAU,GAAG2E,OAAO,CAAC8B,qBAAR,EAAnB;AACA,cAAMC,eAAe,GAAGR,qBAAqB,CAACnG,UAAD,EAA2BC,UAA3B,CAA7C;;AAEA,cAAI0G,eAAe,KAAK,CAAC,CAArB,IAA0BN,iBAAiB,KAAK,CAAC,CAArD,EAAwD;AACtDC,4BAAgB,GAAG1B,OAAnB;AACA;AACD;;AAED,cAAI+B,eAAe,GAAG,CAAC,CAAnB,KAAyBN,iBAAiB,KAAK,CAAC,CAAvB,IAA4BM,eAAe,GAAGN,iBAAvE,CAAJ,EAA+F;AAC7FA,6BAAiB,GAAGM,eAApB;AACAL,4BAAgB,GAAG1B,OAAnB;AACD;;AAED,cAAIyB,iBAAiB,IAAI,CAArB,IAA0BM,eAAe,GAAG,CAAhD,EAAmD;AACjD;AACD;AACF;AACF,OAnBD,MAmBO;AACLL,wBAAgB,GAAG1B,OAAnB;AACA;AACD;AACF,KA5BD,QA4BSA,OA5BT,EApB8B,CAkD9B;;;AACA,QAAI0B,gBAAgB,IAAIA,gBAAgB,KAAK,KAAKtK,cAAlD,EAAkE;AAChEuK,kBAAY,GAAG,IAAf;AACA,WAAK/I,YAAL,CAAkB8I,gBAAlB;AACD,KAHD,MAGO,IAAI,KAAK1L,KAAL,CAAWgM,oBAAX,IAAmCR,cAAvC,EAAuD;AAC5D,UAAIrG,SAAJ,EAAe;AACb,eAAO,KAAKvC,YAAL,CACLhG,cAAc,CAAC,KAAKoE,KAAL,CAAWC,OAAZ,EAAqB,KAAKD,KAAL,CAAWC,OAAX,CAAmBmK,iBAAxC,EAA0E,IAA1E,CADT,CAAP;AAGD,OAJD,MAIO;AACL,eAAO,KAAKxI,YAAL,CACL9F,kBAAkB,CAChB,KAAKkE,KAAL,CAAWC,OADK,EAEhB,KAAKD,KAAL,CAAWC,OAAX,CAAmBgL,gBAFH,EAGhB,IAHgB,EAIhB,IAJgB,EAKhB,IALgB,CADb,CAAP;AASD;AACF;;AAED,WAAON,YAAP;AACD,GA7EO;;AA+EA1E,uCAAR;AAAA;;AACE,QAAIiF,SAAS,GAAG,CAAC,CAAjB,CADF,CAEE;;AACA,QAAM5G,aAAa,GAAG,KAAKC,eAAL,CAAqBrC,IAArB,IAA6B,KAAKqC,eAAL,CAAqBC,CAAlD,IAAuD,CAA7E;;AAEA,QACE,KAAK2G,UAAL,CAAgB,IAAhB,EAAsB,UAAC/G,UAAD,EAAyBC,UAAzB,EAA+C;AACnE,UAAI+G,QAAQ,GAAG,CAAC,CAAhB,CADmE,CAEnE;AACA;AACA;AACA;;AACA,UAAM3G,aAAa,GAAGC,IAAI,CAACC,KAAL,CAAWN,UAAU,CAACO,GAAtB,CAAtB;AACA,UAAMC,gBAAgB,GAAGH,IAAI,CAACC,KAAL,CAAWP,UAAU,CAACU,MAAtB,CAAzB;;AAEA,UAAIL,aAAa,GAAGI,gBAApB,EAAsC;AACpC,YAAI,CAAC3F,KAAI,CAACsE,gBAAL,CAAsBtE,KAAI,CAACkB,cAA3B,EAA0DnD,gBAA1D,CAAL,EAAkF;AAChF,iBAAOG,mCAAP;AACD;;AAED,eAAOD,0BAAP;AACD;;AAED,UAAK+N,SAAS,KAAK,CAAC,CAAf,IAAoBzG,aAAa,IAAII,gBAAtC,IAA2DJ,aAAa,KAAKyG,SAAjF,EAA4F;AAC1FA,iBAAS,GAAGzG,aAAZ;;AACA,YAAIH,aAAa,IAAID,UAAU,CAACnC,IAA5B,IAAoCoC,aAAa,IAAID,UAAU,CAACnC,IAAX,GAAkBmC,UAAU,CAACc,KAAtF,EAA6F;AAC3FiG,kBAAQ,GAAG,CAAX;AACD,SAFD,MAEO;AACLA,kBAAQ,GAAG1G,IAAI,CAACU,GAAL,CAASf,UAAU,CAACnC,IAAX,GAAkBmC,UAAU,CAACc,KAAX,GAAmB,CAArC,GAAyCb,aAAlD,CAAX;AACD;AACF;;AAED,aAAO8G,QAAP;AACD,KA3BD,CADF,EA6BE;AACA,WAAK9K,kBAAL,CAAwB,KAAKF,cAA7B,EAA4D,KAA5D,EAAmE,IAAnE;;AACA,aAAO,IAAP;AACD;;AAED,WAAO,KAAP;AACD,GAxCO;;AA0CA6F,qCAAR;AAAA;;AACE,QAAIiF,SAAS,GAAG,CAAC,CAAjB,CADF,CAEE;;AACA,QAAM5G,aAAa,GAAG,KAAKC,eAAL,CAAqBrC,IAArB,IAA6B,KAAKqC,eAAL,CAAqBC,CAAlD,IAAuD,CAA7E;;AAEA,QACE,KAAK2G,UAAL,CAAgB,KAAhB,EAAuB,UAAC/G,UAAD,EAAyBC,UAAzB,EAA+C;AACpE,UAAI+G,QAAQ,GAAG,CAAC,CAAhB,CADoE,CAEpE;AACA;AACA;AACA;;AACA,UAAMrG,gBAAgB,GAAGL,IAAI,CAACC,KAAL,CAAWN,UAAU,CAACS,MAAtB,CAAzB;AACA,UAAML,aAAa,GAAGC,IAAI,CAACC,KAAL,CAAWN,UAAU,CAACO,GAAtB,CAAtB;AACA,UAAMI,aAAa,GAAGN,IAAI,CAACC,KAAL,CAAWP,UAAU,CAACQ,GAAtB,CAAtB;;AAEA,UAAIG,gBAAgB,GAAGC,aAAvB,EAAsC;AACpC,YAAI,CAAC9F,KAAI,CAACsE,gBAAL,CAAsBtE,KAAI,CAACkB,cAA3B,EAA0DnD,gBAA1D,CAAL,EAAkF;AAChF,iBAAOG,mCAAP;AACD;;AACD,eAAOD,0BAAP;AACD;;AAED,UAAK+N,SAAS,KAAK,CAAC,CAAf,IAAoBnG,gBAAgB,IAAIC,aAAzC,IAA2DP,aAAa,KAAKyG,SAAjF,EAA4F;AAC1FA,iBAAS,GAAGzG,aAAZ;;AACA,YAAIH,aAAa,IAAID,UAAU,CAACnC,IAA5B,IAAoCoC,aAAa,IAAID,UAAU,CAACnC,IAAX,GAAkBmC,UAAU,CAACc,KAAtF,EAA6F;AAC3FiG,kBAAQ,GAAG,CAAX;AACD,SAFD,MAEO;AACLA,kBAAQ,GAAG1G,IAAI,CAACU,GAAL,CAASf,UAAU,CAACnC,IAAX,GAAkBmC,UAAU,CAACc,KAAX,GAAmB,CAArC,GAAyCb,aAAlD,CAAX;AACD;AACF;;AAED,aAAO8G,QAAP;AACD,KA3BD,CADF,EA6BE;AACA,WAAK9K,kBAAL,CAAwB,KAAKF,cAA7B,EAA4D,KAA5D,EAAmE,IAAnE;;AACA,aAAO,IAAP;AACD;;AAED,WAAO,KAAP;AACD,GAxCO;;AA0CA6F,uCAAR,UAAuBjF,KAAvB,EAAoC;AAApC;;AACE,QAAMqK,UAAU,GAAG,KAAK7H,gBAAL,CAAsB,KAAKpD,cAA3B,EAA0DlD,kBAA1D,CAAnB;;AACA,QACE,KAAKiO,UAAL,CACEpP,MAAM,CAACiF,KAAD,CADR,EAEE,UAACoD,UAAD,EAAyBC,UAAzB,EAA+C;AAC7C,UAAI+G,QAAQ,GAAG,CAAC,CAAhB;AACA,UAAIE,mBAAJ;;AAEA,UAAIvP,MAAM,CAACiF,KAAD,CAAV,EAAmB;AACjB;AACA;AACA;AACA;AACAsK,2BAAmB,GAAGC,UAAU,CAAClH,UAAU,CAACO,GAAX,CAAe4G,OAAf,CAAuB,CAAvB,CAAD,CAAV,GAAwCD,UAAU,CAACnH,UAAU,CAACU,MAAX,CAAkB0G,OAAlB,CAA0B,CAA1B,CAAD,CAAxE;AACD,OAND,MAMO;AACLF,2BAAmB,GAAGC,UAAU,CAAClH,UAAU,CAACS,MAAX,CAAkB0G,OAAlB,CAA0B,CAA1B,CAAD,CAAV,GAA2CD,UAAU,CAACnH,UAAU,CAACQ,GAAX,CAAe4G,OAAf,CAAuB,CAAvB,CAAD,CAA3E;AACD;;AAED,UACEF,mBAAmB,IACnBjH,UAAU,CAAC/B,KAAX,IAAoB8B,UAAU,CAAC9B,KAD/B,IAEApD,KAAI,CAACF,KAAL,CAAWiC,SAAX,KAAyB/F,kBAAkB,CAACiH,QAH9C,EAIE;AACAiJ,gBAAQ,GAAGhH,UAAU,CAAC9B,KAAX,GAAmB+B,UAAU,CAAC/B,KAAzC;AACD,OAND,MAMO,IAAI,CAAC+I,UAAL,EAAiB;AACtBD,gBAAQ,GAAGhO,mCAAX;AACD;;AAED,aAAOgO,QAAP;AACD,KA3BH,EA4BE3F;AAAU;AA5BZ,MA6BE4F,UA7BF,CADF,EAgCE;AACA,WAAK/K,kBAAL,CAAwB,KAAKF,cAA7B,EAA4D,IAA5D,EAAkE,KAAlE;;AACA,aAAO,IAAP;AACD;;AAED,WAAO,KAAP;AACD,GAxCO;;AA0CA6F,wCAAR,UAAwBjF,KAAxB,EAAqC;AAArC;;AACE,QAAMqK,UAAU,GAAG,KAAK7H,gBAAL,CAAsB,KAAKpD,cAA3B,EAA0DlD,kBAA1D,CAAnB;;AACA,QACE,KAAKiO,UAAL,CACE,CAACpP,MAAM,CAACiF,KAAD,CADT,EAEE,UAACoD,UAAD,EAAyBC,UAAzB,EAA+C;AAC7C,UAAI+G,QAAQ,GAAG,CAAC,CAAhB;AACA,UAAIE,mBAAJ;;AAEA,UAAIvP,MAAM,CAACiF,KAAD,CAAV,EAAmB;AACjB;AACA;AACA;AACA;AACAsK,2BAAmB,GAAGC,UAAU,CAAClH,UAAU,CAACS,MAAX,CAAkB0G,OAAlB,CAA0B,CAA1B,CAAD,CAAV,GAA2CD,UAAU,CAACnH,UAAU,CAACQ,GAAX,CAAe4G,OAAf,CAAuB,CAAvB,CAAD,CAA3E;AACD,OAND,MAMO;AACLF,2BAAmB,GAAGC,UAAU,CAAClH,UAAU,CAACO,GAAX,CAAe4G,OAAf,CAAuB,CAAvB,CAAD,CAAV,GAAwCD,UAAU,CAACnH,UAAU,CAACU,MAAX,CAAkB0G,OAAlB,CAA0B,CAA1B,CAAD,CAAxE;AACD;;AAED,UACEF,mBAAmB,IACnBjH,UAAU,CAACnC,IAAX,IAAmBkC,UAAU,CAAClC,IAD9B,IAEAhD,KAAI,CAACF,KAAL,CAAWiC,SAAX,KAAyB/F,kBAAkB,CAACiH,QAH9C,EAIE;AACAiJ,gBAAQ,GAAG/G,UAAU,CAACnC,IAAX,GAAkBkC,UAAU,CAAClC,IAAxC;AACD,OAND,MAMO,IAAI,CAACmJ,UAAL,EAAiB;AACtBD,gBAAQ,GAAGhO,mCAAX;AACD;;AAED,aAAOgO,QAAP;AACD,KA3BH,EA4BE3F;AAAU;AA5BZ,MA6BE4F,UA7BF,CADF,EAgCE;AACA,WAAK/K,kBAAL,CAAwB,KAAKF,cAA7B,EAA4D,IAA5D,EAAkE,KAAlE;;AACA,aAAO,IAAP;AACD;;AAED,WAAO,KAAP;AACD,GAxCO;;AAyEA6F,yCAAR,UAAyB9B,SAAzB,EAA6CqG,cAA7C,EAA2E;AAA9B;AAAAA;AAA8B;;AACzE,QAAIxB,OAAO,GAAG,KAAK5I,cAAnB;;AACA,QAAI,CAAC4I,OAAD,IAAY,CAAC,KAAKhJ,KAAL,CAAWC,OAA5B,EAAqC;AACnC,aAAO,KAAP;AACD;;AACD,QAAI,KAAKoD,eAAL,CAAqB2F,OAArB,CAAJ,EAAmC;AACjC,UAAI,CAAC,KAAKnF,qBAAL,CAA2BmF,OAA3B,EAAwD7E,SAAxD,CAAL,EAAyE;AACvE,eAAO,KAAP;AACD;AACF;;AACD,QAAMsH,gBAAgB,GAAGhP,oBAAoB,CAACuM,OAAD,CAA7C;;AACA,QAAI,CAACyC,gBAAL,EAAuB;AACrB,aAAO,KAAP;AACD;;AACD,QAAIhB,iBAAiB,GAAG,CAAC,CAAzB;AACA,QAAIC,gBAAgB,GAAGjF,SAAvB;AACA,QAAIyF,SAAS,GAAG,CAAC,CAAjB;AACA,QAAIQ,YAAY,GAAG,CAAC,CAApB;AACA,QAAMC,QAAQ,GAAIF,gBAAgC,CAACG,YAAnD;AACA,QAAMxH,UAAU,GAAG4E,OAAO,CAAC8B,qBAAR,EAAnB;;AACA,OAAG;AACD9B,aAAO,GAAG7E,SAAS,GACfvI,cAAc,CAAC,KAAKoE,KAAL,CAAWC,OAAZ,EAAqB+I,OAArB,CADC,GAEflN,kBAAkB,CAAC,KAAKkE,KAAL,CAAWC,OAAZ,EAAqB+I,OAArB,CAFtB;;AAGA,UAAIA,OAAJ,EAAa;AACX,YAAM3E,UAAU,GAAG2E,OAAO,CAAC8B,qBAAR,EAAnB;AACA,YAAMrG,aAAa,GAAGC,IAAI,CAACC,KAAL,CAAWN,UAAU,CAACO,GAAtB,CAAtB;AACA,YAAMC,gBAAgB,GAAGH,IAAI,CAACC,KAAL,CAAWP,UAAU,CAACU,MAAtB,CAAzB;AACA,YAAMC,gBAAgB,GAAGL,IAAI,CAACC,KAAL,CAAWN,UAAU,CAACS,MAAtB,CAAzB;AACA,YAAME,aAAa,GAAGN,IAAI,CAACC,KAAL,CAAWP,UAAU,CAACQ,GAAtB,CAAtB;;AACA,YAAMmG,eAAe,GAAG,KAAKc,gCAAL,CAAsC1H,SAAtC,EAAiDC,UAAjD,EAA6DC,UAA7D,CAAxB;;AACA,YAAMyH,mCAAmC,GAAG3H,SAAS,IAAIM,aAAa,GAAGI,gBAAgB,GAAG8G,QAA5F;AACA,YAAMI,iCAAiC,GAAG,CAAC5H,SAAD,IAAcY,gBAAgB,GAAGC,aAAa,GAAG2G,QAA3F;;AAEA,YAAIG,mCAAmC,IAAIC,iCAA3C,EAA8E;AAC5E;AACD;;AACD,YAAIhB,eAAe,GAAG,CAAC,CAAvB,EAA0B;AACxB;AACA,cAAI5G,SAAS,IAAIM,aAAa,GAAGyG,SAAjC,EAA4C;AAC1CA,qBAAS,GAAGzG,aAAZ;AACAgG,6BAAiB,GAAGM,eAApB;AACAL,4BAAgB,GAAG1B,OAAnB;AACD,WAJD,MAIO,IAAI,CAAC7E,SAAD,IAAcY,gBAAgB,GAAG2G,YAArC,EAAmD;AACxD;AACAA,wBAAY,GAAG3G,gBAAf;AACA0F,6BAAiB,GAAGM,eAApB;AACAL,4BAAgB,GAAG1B,OAAnB;AACD,WALM,MAKA,IAAIyB,iBAAiB,KAAK,CAAC,CAAvB,IAA4BM,eAAe,IAAIN,iBAAnD,EAAsE;AAC3EA,6BAAiB,GAAGM,eAApB;AACAL,4BAAgB,GAAG1B,OAAnB;AACD;AACF;AACF;AACF,KAlCD,QAkCSA,OAlCT;;AAoCA,QAAI2B,YAAY,GAAG,KAAnB,CAxDyE,CAyDzE;;AACA,QAAID,gBAAgB,IAAIA,gBAAgB,KAAK,KAAKtK,cAAlD,EAAkE;AAChEuK,kBAAY,GAAG,IAAf;AACA,WAAK/I,YAAL,CAAkB8I,gBAAlB;;AACA,WAAKpK,kBAAL,CAAwBoK,gBAAxB,EAAyD,KAAzD,EAAgE,IAAhE;AACD,KAJD,MAIO,IAAI,KAAK1L,KAAL,CAAWgM,oBAAX,IAAmCR,cAAvC,EAAuD;AAC5D,UAAIrG,SAAJ,EAAe;AACb,eAAO,KAAKvC,YAAL,CACLhG,cAAc,CAAC,KAAKoE,KAAL,CAAWC,OAAZ,EAAqB,KAAKD,KAAL,CAAWC,OAAX,CAAmBmK,iBAAxC,EAA0E,IAA1E,CADT,CAAP;AAGD;;AACD,aAAO,KAAKxI,YAAL,CACL9F,kBAAkB,CAChB,KAAKkE,KAAL,CAAWC,OADK,EAEhB,KAAKD,KAAL,CAAWC,OAAX,CAAmBgL,gBAFH,EAGhB,IAHgB,EAIhB,IAJgB,EAKhB,IALgB,CADb,CAAP;AASD;;AACD,WAAON,YAAP;AACD,GA/EO;;AAiFA1E,2CAAR,UAA2B+C,OAA3B,EAAiDgD,YAAjD,EAAyEC,UAAzE,EAA6F;AAC3F,QACE,KAAKjN,KAAL,CAAWiC,SAAX,KAAyB/F,kBAAkB,CAAC2P,aAA5C,KACC,CAAC,KAAKtG,eAAN,IAAyByH,YAAzB,IAAyCC,UAD1C,CADF,EAGE;AACA,UAAMC,IAAI,GAAGlD,OAAO,CAAC8B,qBAAR,EAAb;AACA,UAAM5I,IAAI,GAAGgK,IAAI,CAAChK,IAAL,GAAYgK,IAAI,CAAC/G,KAAL,GAAa,CAAtC;AACA,UAAMgH,KAAG,GAAGD,IAAI,CAACtH,GAAL,GAAWsH,IAAI,CAACE,MAAL,GAAc,CAArC;;AAEA,UAAI,CAAC,KAAK7H,eAAV,EAA2B;AACzB,aAAKA,eAAL,GAAuB;AAAErC,cAAI,MAAN;AAAQ0C,aAAG;AAAX,SAAvB;AACD;;AAED,UAAIoH,YAAJ,EAAkB;AAChB,aAAKzH,eAAL,CAAqBrC,IAArB,GAA4BA,IAA5B;AACD;;AAED,UAAI+J,UAAJ,EAAgB;AACd,aAAK1H,eAAL,CAAqBK,GAArB,GAA2BuH,KAA3B;AACD;AACF;AACF,GArBO;;AAuBAlG,qDAAR,UAAqC+C,OAArC,EAA0D;AACxD,WAAO,KAAKF,aAAL,CAAmBE,OAAnB,MAAgC,KAAKhJ,KAAL,CAAWC,OAAlD;AACD,GAFO;;AAIAgG,sCAAR,UAAsB+C,OAAtB,EAA2C;AACzC,QAAIjJ,aAAa,GAAGlE,SAAS,CAACmN,OAAD,EAAyBlK,sBAAzB,CAA7B;;AAEA,WAAOiB,aAAa,IAAIA,aAAa,KAAK,KAAKC,KAAL,CAAWC,OAA9C,IAAyDF,aAAa,KAAK,KAAKwB,YAAL,GAAoBsF,IAAtG,EAA4G;AAC1G,UAAI1K,kBAAkB,CAAC4D,aAAD,CAAtB,EAAuC;AACrC,eAAOA,aAAP;AACD;;AAEDA,mBAAa,GAAGlE,SAAS,CAACkE,aAAD,EAAgBjB,sBAAhB,CAAzB;AACD;;AAED,WAAOiB,aAAP;AACD,GAZO;;AAcAkG,0CAAR,UAA0B+C,OAA1B,EAA+C;AAC7C,QACE,CAAC,KAAK5I,cAAN,IACA,KAAKpB,KAAL,CAAWW,sBADX,IAEA,OAAO,KAAKX,KAAL,CAAWW,sBAAlB,KAA6C,UAH/C,EAIE;AACA,WAAKS,cAAL,GAAsB,KAAKpB,KAAL,CAAWW,sBAAX,CAAkC,KAAKK,KAAL,CAAWC,OAA7C,CAAtB;AACD;;AAED,QAAI,CAAC+I,OAAD,IAAY,KAAKhJ,KAAL,CAAWC,OAA3B,EAAoC;AAClC,WAAK2H,oBAAL,GAA4B,IAA5B;AACAoB,aAAO,GAAG,KAAKhJ,KAAL,CAAWC,OAArB;;AACA,UAAI,KAAKG,cAAL,IAAuB,CAAC9E,eAAe,CAAC0N,OAAD,EAAU,KAAK5I,cAAf,CAA3C,EAA2E;AACzE,aAAKA,cAAL,GAAsB,IAAtB;AACD;AACF,KAf4C,CAiB7C;AACA;;;AACA,QAAI,KAAKA,cAAL,IAAuB,CAAChE,iBAAiB,CAAC,KAAKgE,cAAN,CAA7C,EAAoE;AAClE,WAAKA,cAAL,GAAsB,IAAtB;AACD;;AAED,QAAMiM,UAAU,GAAGrD,OAAO,IAAIA,OAAO,CAACN,QAAtC;;AAEA,SAAK,IAAI4D,UAAU,GAAG,CAAtB,EAAyBD,UAAU,IAAIC,UAAU,GAAGD,UAAU,CAACxL,MAA/D,EAAuEyL,UAAU,EAAjF,EAAqF;AACnF,UAAMnC,KAAK,GAAGkC,UAAU,CAACC,UAAD,CAAxB;;AAEA,UAAI,CAACnQ,kBAAkB,CAACgO,KAAD,CAAvB,EAAgC;AAC9B;AACA,YAAIA,KAAK,CAACvB,YAAN,IAAsBuB,KAAK,CAACvB,YAAN,CAAmB/L,sBAAnB,MAA+C,OAAzE,EAAkF;AAChFsN,eAAK,CAACR,YAAN,CAAmB3M,QAAnB,EAA6B,IAA7B;AACD;;AAED,YAAIZ,iBAAiB,CAAC+N,KAAD,CAArB,EAA8B;AAC5B,cAAI,KAAKnL,KAAL,CAAW0B,QAAf,EAAyB;AACvByJ,iBAAK,CAACR,YAAN,CAAmB3M,QAAnB,EAA6B,IAA7B;AACD,WAFD,MAEO,IACL,CAAC,KAAKyE,YAAN,KACE,CAAC,KAAKrB,cAAN,IAAwB,CAAC,KAAKwH,oBAA/B,IAAwD,KAAKxH,cAAL,KAAwB+J,KADjF,CADK,EAGL;AACA,iBAAKvC,oBAAL,GAA4BuC,KAA5B;;AACA,gBAAIA,KAAK,CAACvB,YAAN,CAAmB5L,QAAnB,MAAiC,GAArC,EAA0C;AACxCmN,mBAAK,CAACR,YAAN,CAAmB3M,QAAnB,EAA6B,GAA7B;AACD;AACF,WARM,MAQA,IAAImN,KAAK,CAACvB,YAAN,CAAmB5L,QAAnB,MAAiC,IAArC,EAA2C;AAChDmN,iBAAK,CAACR,YAAN,CAAmB3M,QAAnB,EAA6B,IAA7B;AACD;AACF,SAdD,MAcO,IAAImN,KAAK,CAACF,OAAN,KAAkB,KAAlB,IAA2BE,KAAK,CAACvB,YAAN,CAAmB,WAAnB,MAAoC,OAAnE,EAA4E;AACjF;AACAuB,eAAK,CAACR,YAAN,CAAmB,WAAnB,EAAgC,OAAhC;AACD;AACF,OAxBD,MAwBO,IAAIQ,KAAK,CAACvB,YAAN,CAAmB/L,sBAAnB,MAA+C,MAAnD,EAA2D;AAChE,YACE,CAAC,KAAK4E,YAAN,KACE,CAAC,KAAKrB,cAAN,IAAwB,CAAC,KAAKwH,oBAA/B,IAAwD,KAAKxH,cAAL,KAAwB+J,KADjF,CADF,EAGE;AACA,eAAKvC,oBAAL,GAA4BuC,KAA5B;;AACA,cAAIA,KAAK,CAACvB,YAAN,CAAmB5L,QAAnB,MAAiC,GAArC,EAA0C;AACxCmN,iBAAK,CAACR,YAAN,CAAmB3M,QAAnB,EAA6B,GAA7B;AACD;AACF,SARD,MAQO,IAAImN,KAAK,CAACvB,YAAN,CAAmB5L,QAAnB,MAAiC,IAArC,EAA2C;AAChDmN,eAAK,CAACR,YAAN,CAAmB3M,QAAnB,EAA6B,IAA7B;AACD;AACF;;AAED,WAAKuD,iBAAL,CAAuB4J,KAAvB;AACD;AACF,GApEO;;AAsEAlE,kDAAR,UAAkC+C,OAAlC,EAAsD;AACpD,WAAOA,OAAO,IAAIA,OAAO,CAACJ,YAAR,CAAqB,iBAArB,MAA4C,MAA9D;AACD,GAFO;;AAIA3C,wCAAR,UAAwB+C,OAAxB,EAA4C;AAC1C,QACEA,OAAO,IACPA,OAAO,CAACiB,OADR,KAECjB,OAAO,CAACiB,OAAR,CAAgBsC,WAAhB,OAAkC,OAAlC,IAA6CvD,OAAO,CAACiB,OAAR,CAAgBsC,WAAhB,OAAkC,UAFhF,CADF,EAIE;AACA,aAAO,IAAP;AACD;;AACD,WAAO,KAAP;AACD,GATO;;AAWAtG,8CAAR,UAA8B+C,OAA9B,EAAyD7E,SAAzD,EAA4E;AAC1E;AACA,QACE,CAAC,KAAKZ,iBAAN,IACAyF,OADA,IAEAA,OAAO,CAACwD,IAFR,IAGA3N,mBAAmB,CAAC4N,OAApB,CAA4BzD,OAAO,CAACwD,IAAR,CAAaD,WAAb,EAA5B,IAA0D,CAAC,CAJ7D,EAKE;AACA,UAAMG,cAAc,GAAG1D,OAAO,CAAC0D,cAA/B;AACA,UAAMC,YAAY,GAAG3D,OAAO,CAAC2D,YAA7B;AACA,UAAMC,eAAe,GAAGF,cAAc,KAAKC,YAA3C;AACA,UAAME,UAAU,GAAG7D,OAAO,CAAC8D,KAA3B;AACA,UAAMC,UAAU,GAAG/D,OAAO,CAACgE,QAA3B,CALA,CAOA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,UACEJ,eAAe,IACdF,cAAe,GAAG,CAAlB,IAAuB,CAACvI,SAAxB,IAAqC,CAAC4I,UADvC,IAECL,cAAc,KAAKG,UAAU,CAAChM,MAA9B,IAAwCsD,SAAxC,IAAqD,CAAC4I,UAFvD,IAGC,CAAC,CAAC,KAAK/N,KAAL,CAAWkE,YAAb,IACC,EAAE,KAAKlE,KAAL,CAAWiO,8BAAX,IAA6C,KAAKjO,KAAL,CAAWiO,8BAAX,CAA0CjE,OAA1C,CAA/C,CALJ,EAME;AACA,eAAO,KAAP;AACD;AACF;;AAED,WAAO,IAAP;AACD,GAjCO;;AAmCA/C,yCAAR,UACE+C,OADF,EAEEkE,mBAFF,EAE0E;AAExE,WAAO,KAAKlO,KAAL,CAAWmO,cAAX,GAA4B9Q,eAAe,CAAC2M,OAAD,EAAUkE,mBAAV,CAA3C,GAA4E,IAAnF;AACD,GALO;AAOR;;;;;AAGQjH,+CAAR,UAA+B+C,OAA/B,EAAmD;AACjD,WAAOA,OAAO,IAAI,CAAC,CAAC,KAAKhJ,KAAL,CAAWC,OAAxB,IAAmC1D,qBAAqB,CAACyM,OAAD,EAAU,KAAKhJ,KAAL,CAAWC,OAArB,CAA/D;AACD,GAFO;;AAIAgG,qCAAR;AACE,WAAO1K,WAAW,CAAC,KAAKyE,KAAL,CAAWC,OAAZ,CAAlB;AACD,GAFO;;AApxCMgG,2BAAgC;AAC5C+E,wBAAoB,EAAE,KADsB;AAE5C/J,aAAS,EAAE/F,kBAAkB,CAAC2P,aAFc;AAG5C9E,qBAAiB,EAAE;AAHyB,GAAhC;AAuxChB;AAxxCA,EAA+B9K,KAAK,CAACmS,SAArC;;SAAanH","names":["React","FocusZoneDirection","FocusZoneTabbableElements","KeyCodes","css","elementContains","getDocument","getElementIndexPath","getFocusableByIndexPath","getId","getNativeProps","getNextElement","getParent","getPreviousElement","getRTL","htmlElementProperties","initializeComponentRef","isElementFocusSubZone","isElementFocusZone","isElementTabbable","shouldWrapFocus","warnDeprecations","portalContainsElement","getWindow","findScrollableParent","createMergedRef","mergeStyles","getTheme","IS_FOCUSABLE_ATTRIBUTE","IS_ENTER_DISABLED_ATTRIBUTE","FOCUSZONE_ID_ATTRIBUTE","TABINDEX","NO_VERTICAL_WRAP","NO_HORIZONTAL_WRAP","LARGE_DISTANCE_FROM_CENTER","LARGE_NEGATIVE_DISTANCE_FROM_CENTER","focusZoneStyles","focusZoneClass","raiseClickFromKeyboardEvent","target","ev","event","MouseEvent","ctrlKey","metaKey","shiftKey","altKey","bubbles","cancelable","document","createEvent","initMouseEvent","window","dispatchEvent","getRootClass","selectors","outline","_allInstances","_outerZones","Set","ALLOWED_INPUT_TYPES","ALLOW_VIRTUAL_ELEMENTS","__extends","props","_super","_this","createRef","_portalContainsElement","onActiveElementChanged","doNotAllowFocusEventToPropagate","stopFocusPropagation","onFocusNotification","onFocus","shouldFocusInnerElementWhenReceivedFocus","defaultTabbableElement","isImmediateDescendant","_isImmediateDescendantOfZone","newActiveElement","parentElement","_root","current","maybeElementToFocus","focus","_activeElement","initialElementFocused","_setFocusAlignment","_updateTabIndexes","stopPropagation","_setParkedFocus","disabled","path","push","length","pop","_setActiveElement","theme","direction","isInnerZoneKeystroke","pagingSupportDisabled","shouldEnterInnerZone","onKeyDown","isDefaultPrevented","_getDocument","activeElement","_isInnerZone","innerZone","_getFirstInnerZone","focusElement","firstChild","which","space","_shouldRaiseClicksOnSpace","_tryInvokeClickForFocusable","left","vertical","_preventDefaultWhenHandled","_moveFocusLeft","right","_moveFocusRight","up","horizontal","_moveFocusUp","down","_moveFocusDown","pageDown","_moveFocusPaging","pageUp","tab","allowTabKey","handleTabKey","all","inputOnly","_isElementInput","focusChanged","_processingTabKey","_shouldWrapFocus","tabWithDirection","shouldResetActiveElementWhenTabFromZone","home","_isContentEditableElement","_shouldInputLoseFocus","end","lastChild","enter","_shouldRaiseClicksOnEnter","preventDefault","isForward","activeRect","targetRect","leftAlignment","_focusAlignment","x","targetRectTop","Math","floor","top","activeRectBottom","bottom","targetRectBottom","activeRectTop","isValidCandidateOnpagingDown","isValidCandidateOnpagingUp","width","abs","process","env","NODE_ENV","rootProps","undefined","elementType","ariaDescribedBy","ariaLabelledBy","_id","shouldRaiseClicksFallback","shouldRaiseClicks","_a","FocusZone","defaultProps","_b","shouldRaiseClicksOnEnter","_c","shouldRaiseClicksOnSpace","_d","size","forEach","zone","root","_windowElement","body","nodeType","add","addEventListener","_onKeyDownCapture","_onBlur","querySelector","defaultActiveElement","shouldFocusOnMount","doc","preventFocusRestoration","_lastIndexPath","elementToFocus","delete","removeEventListener","_defaultFocusElement","tag","className","divProps","Tag","_evaluateFocusBeforeRender","__assign","ref","_mergedRef","elementRef","_onKeyDown","_onFocus","onMouseDownCapture","_onMouseDown","children","forceIntoFirstElement","getAttribute","ownerZoneElement","_getOwnerZone","ownerZone","element","forceAlignment","onBeforeFocus","shouldReceiveFocus","point","focusedElement","shouldRestoreFocus","isParked","_isParked","allowFocusRoot","_parkedTabIndex","setAttribute","removeAttribute","previousActiveElement","tabIndex","preventDefaultWhenHandled","targetElement","tagName","rootElement","child","firstElementChild","match","nextElementSibling","getDistanceFromCenter","useDefaultWrap","candidateDistance","candidateElement","changedFocus","isBidirectional","bidirectional","getBoundingClientRect","elementDistance","isCircularNavigation","lastElementChild","targetTop","_moveFocus","distance","shouldWrap","topBottomComparison","parseFloat","toFixed","scrollableParent","targetBottom","pagesize","clientHeight","_getHorizontalDistanceFromCenter","isElementPassedPageSizeOnPagingDown","isElementPassedPageSizeOnPagingUp","isHorizontal","isVertical","rect","top_1","height","childNodes","childIndex","toLowerCase","type","indexOf","selectionStart","selectionEnd","isRangeSelected","inputValue","value","isReadonly","readOnly","shouldInputLoseFocusOnArrowKey","noWrapDataAttribute","checkForNoWrap","Component"],"sources":["/home/npr/Downloads/Final FrontEnd (2)/node_modules/@fluentui/react-focus/lib/components/src/components/FocusZone/FocusZone.tsx"],"sourcesContent":["import * as React from 'react';\nimport { FocusZoneDirection, FocusZoneTabbableElements } from './FocusZone.types';\nimport {\n  KeyCodes,\n  css,\n  elementContains,\n  getDocument,\n  getElementIndexPath,\n  getFocusableByIndexPath,\n  getId,\n  getNativeProps,\n  getNextElement,\n  getParent,\n  getPreviousElement,\n  getRTL,\n  htmlElementProperties,\n  initializeComponentRef,\n  isElementFocusSubZone,\n  isElementFocusZone,\n  isElementTabbable,\n  shouldWrapFocus,\n  warnDeprecations,\n  portalContainsElement,\n  getWindow,\n  findScrollableParent,\n  createMergedRef,\n} from '@fluentui/utilities';\nimport { mergeStyles } from '@fluentui/merge-styles';\nimport { getTheme } from '@fluentui/style-utilities';\nimport type { IFocusZone, IFocusZoneProps } from './FocusZone.types';\nimport type { Point } from '@fluentui/utilities';\nimport type { ITheme } from '@fluentui/style-utilities';\n\nconst IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';\nconst IS_ENTER_DISABLED_ATTRIBUTE = 'data-disable-click-on-enter';\nconst FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';\nconst TABINDEX = 'tabindex';\nconst NO_VERTICAL_WRAP = 'data-no-vertical-wrap';\nconst NO_HORIZONTAL_WRAP = 'data-no-horizontal-wrap';\nconst LARGE_DISTANCE_FROM_CENTER = 999999999;\nconst LARGE_NEGATIVE_DISTANCE_FROM_CENTER = -999999999;\n\nlet focusZoneStyles: string;\n\nconst focusZoneClass: string = 'ms-FocusZone';\n\n/**\n * Raises a click on a target element based on a keyboard event.\n */\nfunction raiseClickFromKeyboardEvent(target: Element, ev?: React.KeyboardEvent<HTMLElement>): void {\n  let event;\n  if (typeof MouseEvent === 'function') {\n    event = new MouseEvent('click', {\n      ctrlKey: ev?.ctrlKey,\n      metaKey: ev?.metaKey,\n      shiftKey: ev?.shiftKey,\n      altKey: ev?.altKey,\n      bubbles: ev?.bubbles,\n      cancelable: ev?.cancelable,\n    });\n  } else {\n    event = document.createEvent('MouseEvents');\n    event.initMouseEvent(\n      'click',\n      ev ? ev.bubbles : false,\n      ev ? ev.cancelable : false,\n      window, // not using getWindow() since this can only be run client side\n      0, // detail\n      0, // screen x\n      0, // screen y\n      0, // client x\n      0, // client y\n      ev ? ev.ctrlKey : false,\n      ev ? ev.altKey : false,\n      ev ? ev.shiftKey : false,\n      ev ? ev.metaKey : false,\n      0, // button\n      null, // relatedTarget\n    );\n  }\n\n  target.dispatchEvent(event);\n}\n\n// Helper function that will return a class for when the root is focused\nfunction getRootClass(): string {\n  if (!focusZoneStyles) {\n    focusZoneStyles = mergeStyles(\n      {\n        selectors: {\n          ':focus': {\n            outline: 'none',\n          },\n        },\n      },\n      focusZoneClass,\n    );\n  }\n  return focusZoneStyles;\n}\n\nconst _allInstances: {\n  [key: string]: FocusZone;\n} = {};\nconst _outerZones: Set<FocusZone> = new Set();\n\nconst ALLOWED_INPUT_TYPES = ['text', 'number', 'password', 'email', 'tel', 'url', 'search'];\n\nconst ALLOW_VIRTUAL_ELEMENTS = false;\n\nexport class FocusZone extends React.Component<IFocusZoneProps> implements IFocusZone {\n  public static defaultProps: IFocusZoneProps = {\n    isCircularNavigation: false,\n    direction: FocusZoneDirection.bidirectional,\n    shouldRaiseClicks: true,\n  };\n\n  private _root: React.RefObject<HTMLElement> = React.createRef();\n  private _mergedRef = createMergedRef<HTMLElement>();\n\n  private _id: string;\n\n  /** The most recently focused child element. */\n  private _activeElement: HTMLElement | null;\n\n  /**\n   * The index path to the last focused child element.\n   */\n  private _lastIndexPath: number[] | undefined;\n\n  /**\n   * Flag to define when we've intentionally parked focus on the root element to temporarily\n   * hold focus until items appear within the zone.\n   */\n  private _isParked: boolean;\n\n  /** The child element with tabindex=0. */\n  private _defaultFocusElement: HTMLElement | null;\n  private _focusAlignment: Point;\n  private _isInnerZone: boolean;\n  private _parkedTabIndex: string | null | undefined;\n\n  /** Used to allow moving to next focusable element even when we're focusing on a input element when pressing tab */\n  private _processingTabKey: boolean;\n\n  /** Provides granular control over `shouldRaiseClicks` and should be preferred over `props.shouldRaiseClicks`. */\n  private _shouldRaiseClicksOnEnter: boolean;\n  private _shouldRaiseClicksOnSpace: boolean;\n\n  private _windowElement: Window | undefined;\n\n  /** Used for testing purposes only. */\n  public static getOuterZones(): number {\n    return _outerZones.size;\n  }\n\n  /**\n   * Handle global tab presses so that we can patch tabindexes on the fly.\n   * HEADS UP: This must not be an arrow function in order to be referentially equal among instances\n   * for ref counting to work correctly!\n   */\n  private static _onKeyDownCapture(ev: KeyboardEvent): void {\n    // eslint-disable-next-line deprecation/deprecation, @fluentui/deprecated-keyboard-event-props\n    if (ev.which === KeyCodes.tab) {\n      _outerZones.forEach((zone: FocusZone) => zone._updateTabIndexes());\n    }\n  }\n\n  constructor(props: IFocusZoneProps) {\n    super(props);\n    // Manage componentRef resolution.\n    initializeComponentRef(this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      warnDeprecations('FocusZone', props, {\n        rootProps: undefined,\n        allowTabKey: 'handleTabKey',\n        elementType: 'as',\n        ariaDescribedBy: 'aria-describedby',\n        ariaLabelledBy: 'aria-labelledby',\n      });\n    }\n\n    this._id = getId('FocusZone');\n\n    this._focusAlignment = {\n      left: 0,\n      top: 0,\n    };\n\n    this._processingTabKey = false;\n\n    const shouldRaiseClicksFallback = props.shouldRaiseClicks ?? FocusZone.defaultProps.shouldRaiseClicks ?? true;\n    this._shouldRaiseClicksOnEnter = props.shouldRaiseClicksOnEnter ?? shouldRaiseClicksFallback;\n    this._shouldRaiseClicksOnSpace = props.shouldRaiseClicksOnSpace ?? shouldRaiseClicksFallback;\n  }\n\n  public componentDidMount(): void {\n    const { current: root } = this._root;\n\n    _allInstances[this._id] = this;\n\n    if (root) {\n      this._windowElement = getWindow(root);\n      let parentElement = getParent(root, ALLOW_VIRTUAL_ELEMENTS);\n\n      while (parentElement && parentElement !== this._getDocument().body && parentElement.nodeType === 1) {\n        if (isElementFocusZone(parentElement)) {\n          this._isInnerZone = true;\n          break;\n        }\n        parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n      }\n\n      if (!this._isInnerZone) {\n        _outerZones.add(this);\n\n        if (this._windowElement && _outerZones.size === 1) {\n          this._windowElement.addEventListener('keydown', FocusZone._onKeyDownCapture, true);\n        }\n      }\n\n      this._root.current && this._root.current.addEventListener('blur', this._onBlur, true);\n\n      // Assign initial tab indexes so that we can set initial focus as appropriate.\n      this._updateTabIndexes();\n\n      if (this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === 'string') {\n        this._activeElement = this._getDocument().querySelector(this.props.defaultTabbableElement) as HTMLElement;\n        // eslint-disable-next-line deprecation/deprecation\n      } else if (this.props.defaultActiveElement) {\n        // eslint-disable-next-line deprecation/deprecation\n        this._activeElement = this._getDocument().querySelector(this.props.defaultActiveElement) as HTMLElement;\n      }\n\n      if (this.props.shouldFocusOnMount) {\n        this.focus();\n      }\n    }\n  }\n\n  public componentDidUpdate(): void {\n    const { current: root } = this._root;\n    const doc = this._getDocument();\n\n    if (\n      !this.props.preventFocusRestoration &&\n      doc &&\n      this._lastIndexPath &&\n      (doc.activeElement === doc.body || doc.activeElement === null || doc.activeElement === root)\n    ) {\n      // The element has been removed after the render, attempt to restore focus.\n      const elementToFocus = getFocusableByIndexPath(root as HTMLElement, this._lastIndexPath);\n\n      if (elementToFocus) {\n        this._setActiveElement(elementToFocus, true);\n        elementToFocus.focus();\n        this._setParkedFocus(false);\n      } else {\n        // We had a focus path to restore, but now that path is unresolvable. Park focus\n        // on the container until we can try again.\n        this._setParkedFocus(true);\n      }\n    }\n  }\n\n  public componentWillUnmount(): void {\n    delete _allInstances[this._id];\n\n    if (!this._isInnerZone) {\n      _outerZones.delete(this);\n\n      // If this is the last outer zone, remove the keydown listener.\n      if (this._windowElement && _outerZones.size === 0) {\n        this._windowElement.removeEventListener('keydown', FocusZone._onKeyDownCapture, true);\n      }\n    }\n\n    if (this._root.current) {\n      this._root.current.removeEventListener('blur', this._onBlur, true);\n    }\n\n    this._activeElement = null;\n    this._defaultFocusElement = null;\n  }\n\n  public render(): React.ReactNode {\n    // eslint-disable-next-line deprecation/deprecation\n    const { as: tag, elementType, rootProps, ariaDescribedBy, ariaLabelledBy, className } = this.props;\n    const divProps = getNativeProps(this.props, htmlElementProperties);\n\n    const Tag = tag || elementType || 'div';\n\n    // Note, right before rendering/reconciling proceeds, we need to record if focus\n    // was in the zone before the update. This helper will track this and, if focus\n    // was actually in the zone, what the index path to the element is at this time.\n    // Then, later in componentDidUpdate, we can evaluate if we need to restore it in\n    // the case the element was removed.\n    this._evaluateFocusBeforeRender();\n\n    // Only support RTL defined in global theme, not contextual theme/RTL.\n    const theme: ITheme = getTheme();\n\n    return (\n      <Tag\n        aria-labelledby={ariaLabelledBy}\n        aria-describedby={ariaDescribedBy}\n        {...divProps}\n        {\n          // root props has been deprecated and should get removed.\n          // it needs to be marked as \"any\" since root props expects a div element, but really Tag can\n          // be any native element so typescript rightly flags this as a problem.\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          ...(rootProps as any)\n        }\n        // Once the getClassName correctly memoizes inputs this should\n        // be replaced so that className is passed to getRootClass and is included there so\n        // the class names will always be in the same order.\n        className={css(getRootClass(), className)}\n        // eslint-disable-next-line deprecation/deprecation\n        ref={this._mergedRef(this.props.elementRef, this._root)}\n        data-focuszone-id={this._id}\n        // eslint-disable-next-line react/jsx-no-bind\n        onKeyDown={(ev: React.KeyboardEvent<HTMLElement>) => this._onKeyDown(ev, theme)}\n        onFocus={this._onFocus}\n        onMouseDownCapture={this._onMouseDown}\n      >\n        {this.props.children}\n      </Tag>\n    );\n  }\n\n  /**\n   * Sets focus to the first tabbable item in the zone.\n   * @param forceIntoFirstElement - If true, focus will be forced into the first element, even\n   * if focus is already in the focus zone.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  public focus(forceIntoFirstElement: boolean = false): boolean {\n    if (this._root.current) {\n      if (\n        !forceIntoFirstElement &&\n        this._root.current.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' &&\n        this._isInnerZone\n      ) {\n        const ownerZoneElement = this._getOwnerZone(this._root.current) as HTMLElement;\n\n        if (ownerZoneElement !== this._root.current) {\n          const ownerZone = _allInstances[ownerZoneElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE) as string];\n\n          return !!ownerZone && ownerZone.focusElement(this._root.current);\n        }\n\n        return false;\n      } else if (\n        !forceIntoFirstElement &&\n        this._activeElement &&\n        elementContains(this._root.current, this._activeElement) &&\n        isElementTabbable(this._activeElement)\n      ) {\n        this._activeElement.focus();\n        return true;\n      } else {\n        const firstChild = this._root.current.firstChild as HTMLElement;\n\n        return this.focusElement(getNextElement(this._root.current, firstChild, true) as HTMLElement);\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Sets focus to the last tabbable item in the zone.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  public focusLast(): boolean {\n    if (this._root.current) {\n      const lastChild = this._root.current && (this._root.current.lastChild as HTMLElement | null);\n\n      return this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true) as HTMLElement);\n    }\n\n    return false;\n  }\n\n  /**\n   * Sets focus to a specific child element within the zone. This can be used in conjunction with\n   * shouldReceiveFocus to create delayed focus scenarios (like animate the scroll position to the correct\n   * location and then focus.)\n   * @param element - The child element within the zone to focus.\n   * @param forceAlignment - If true, focus alignment will be set according to the element provided.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  public focusElement(element: HTMLElement, forceAlignment?: boolean): boolean {\n    // eslint-disable-next-line deprecation/deprecation\n    const { onBeforeFocus, shouldReceiveFocus } = this.props;\n\n    if ((shouldReceiveFocus && !shouldReceiveFocus(element)) || (onBeforeFocus && !onBeforeFocus(element))) {\n      return false;\n    }\n\n    if (element) {\n      // when we set focus to a specific child, we should recalculate the alignment depending on its position.\n      this._setActiveElement(element, forceAlignment);\n      if (this._activeElement) {\n        this._activeElement.focus();\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Forces horizontal alignment in the context of vertical arrowing to use specific point as the reference,\n   * rather than a center based on the last horizontal motion.\n   * @param point - the new reference point.\n   */\n  public setFocusAlignment(point: Point): void {\n    this._focusAlignment = point;\n  }\n\n  private _evaluateFocusBeforeRender(): void {\n    const { current: root } = this._root;\n\n    const doc = this._getDocument();\n    if (doc) {\n      const focusedElement = doc.activeElement as HTMLElement;\n\n      // Only update the index path if we are not parked on the root.\n      if (focusedElement !== root) {\n        const shouldRestoreFocus = elementContains(root, focusedElement, false);\n        this._lastIndexPath = shouldRestoreFocus ? getElementIndexPath(root as HTMLElement, focusedElement) : undefined;\n      }\n    }\n  }\n\n  private _onFocus = (ev: React.FocusEvent<HTMLElement>): void => {\n    if (this._portalContainsElement(ev.target as HTMLElement)) {\n      // If the event target is inside a portal do not process the event.\n      return;\n    }\n\n    const {\n      onActiveElementChanged,\n      // eslint-disable-next-line deprecation/deprecation\n      doNotAllowFocusEventToPropagate,\n      stopFocusPropagation,\n      // eslint-disable-next-line deprecation/deprecation\n      onFocusNotification,\n      onFocus,\n      shouldFocusInnerElementWhenReceivedFocus,\n      defaultTabbableElement,\n    } = this.props;\n    const isImmediateDescendant = this._isImmediateDescendantOfZone(ev.target as HTMLElement);\n    let newActiveElement: HTMLElement | null | undefined;\n\n    if (isImmediateDescendant) {\n      newActiveElement = ev.target as HTMLElement;\n    } else {\n      let parentElement = ev.target as HTMLElement;\n\n      while (parentElement && parentElement !== this._root.current) {\n        if (isElementTabbable(parentElement) && this._isImmediateDescendantOfZone(parentElement)) {\n          newActiveElement = parentElement;\n          break;\n        }\n        parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS) as HTMLElement;\n      }\n    }\n\n    // If an inner focusable element should be focused when FocusZone container receives focus\n    if (shouldFocusInnerElementWhenReceivedFocus && ev.target === this._root.current) {\n      const maybeElementToFocus =\n        defaultTabbableElement &&\n        typeof defaultTabbableElement === 'function' &&\n        this._root.current &&\n        defaultTabbableElement(this._root.current);\n\n      // try to focus defaultTabbable element\n      if (maybeElementToFocus && isElementTabbable(maybeElementToFocus)) {\n        newActiveElement = maybeElementToFocus;\n        maybeElementToFocus.focus();\n      } else {\n        // force focus on first focusable element\n        this.focus(true);\n        if (this._activeElement) {\n          // set to null as new active element was handled in method above\n          newActiveElement = null;\n        }\n      }\n    }\n\n    const initialElementFocused = !this._activeElement;\n\n    // If the new active element is a child of this zone and received focus,\n    // update alignment an immediate descendant\n    if (newActiveElement && newActiveElement !== this._activeElement) {\n      if (isImmediateDescendant || initialElementFocused) {\n        this._setFocusAlignment(newActiveElement, true, true);\n      }\n\n      this._activeElement = newActiveElement;\n\n      if (initialElementFocused) {\n        this._updateTabIndexes();\n      }\n    }\n\n    if (onActiveElementChanged) {\n      onActiveElementChanged(this._activeElement as HTMLElement, ev);\n    }\n\n    if (stopFocusPropagation || doNotAllowFocusEventToPropagate) {\n      ev.stopPropagation();\n    }\n\n    if (onFocus) {\n      onFocus(ev);\n    } else if (onFocusNotification) {\n      onFocusNotification();\n    }\n  };\n\n  /**\n   * When focus is in the zone at render time but then all focusable elements are removed,\n   * we \"park\" focus temporarily on the root. Once we update with focusable children, we restore\n   * focus to the closest path from previous. If the user tabs away from the parked container,\n   * we restore focusability to the pre-parked state.\n   */\n  private _setParkedFocus(isParked: boolean): void {\n    const { current: root } = this._root;\n\n    if (root && this._isParked !== isParked) {\n      this._isParked = isParked;\n\n      if (isParked) {\n        if (!this.props.allowFocusRoot) {\n          this._parkedTabIndex = root.getAttribute('tabindex');\n          root.setAttribute('tabindex', '-1');\n        }\n        root.focus();\n      } else if (!this.props.allowFocusRoot) {\n        if (this._parkedTabIndex) {\n          root.setAttribute('tabindex', this._parkedTabIndex);\n          this._parkedTabIndex = undefined;\n        } else {\n          root.removeAttribute('tabindex');\n        }\n      }\n    }\n  }\n\n  private _onBlur = (): void => {\n    this._setParkedFocus(false);\n  };\n\n  private _onMouseDown = (ev: React.MouseEvent<HTMLElement>): void => {\n    if (this._portalContainsElement(ev.target as HTMLElement)) {\n      // If the event target is inside a portal do not process the event.\n      return;\n    }\n\n    const { disabled } = this.props;\n\n    if (disabled) {\n      return;\n    }\n\n    let target = ev.target as HTMLElement;\n    const path = [];\n\n    while (target && target !== this._root.current) {\n      path.push(target);\n      target = getParent(target, ALLOW_VIRTUAL_ELEMENTS) as HTMLElement;\n    }\n\n    while (path.length) {\n      target = path.pop() as HTMLElement;\n\n      if (target && isElementTabbable(target)) {\n        this._setActiveElement(target, true);\n      }\n\n      if (isElementFocusZone(target)) {\n        // Stop here since the focus zone will take care of its own children.\n        break;\n      }\n    }\n  };\n\n  private _setActiveElement(element: HTMLElement, forceAlignment?: boolean): void {\n    const previousActiveElement = this._activeElement;\n\n    this._activeElement = element;\n\n    if (previousActiveElement) {\n      if (isElementFocusZone(previousActiveElement)) {\n        this._updateTabIndexes(previousActiveElement);\n      }\n\n      previousActiveElement.tabIndex = -1;\n    }\n\n    if (this._activeElement) {\n      if (!this._focusAlignment || forceAlignment) {\n        this._setFocusAlignment(element, true, true);\n      }\n\n      this._activeElement.tabIndex = 0;\n    }\n  }\n\n  private _preventDefaultWhenHandled(ev: React.KeyboardEvent<HTMLElement>): void {\n    this.props.preventDefaultWhenHandled && ev.preventDefault();\n  }\n\n  /**\n   * Handle the keystrokes.\n   */\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLElement>, theme: ITheme): boolean | undefined => {\n    if (this._portalContainsElement(ev.target as HTMLElement)) {\n      // If the event target is inside a portal do not process the event.\n      return;\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    const { direction, disabled, isInnerZoneKeystroke, pagingSupportDisabled, shouldEnterInnerZone } = this.props;\n\n    if (disabled) {\n      return;\n    }\n\n    if (this.props.onKeyDown) {\n      this.props.onKeyDown(ev);\n    }\n\n    // If the default has been prevented, do not process keyboard events.\n    if (ev.isDefaultPrevented()) {\n      return;\n    }\n\n    if (this._getDocument().activeElement === this._root.current && this._isInnerZone) {\n      // If this element has focus, it is being controlled by a parent.\n      // Ignore the keystroke.\n      return;\n    }\n\n    if (\n      ((shouldEnterInnerZone && shouldEnterInnerZone(ev)) || (isInnerZoneKeystroke && isInnerZoneKeystroke(ev))) &&\n      this._isImmediateDescendantOfZone(ev.target as HTMLElement)\n    ) {\n      // Try to focus\n      const innerZone = this._getFirstInnerZone();\n\n      if (innerZone) {\n        if (!innerZone.focus(true)) {\n          return;\n        }\n      } else if (isElementFocusSubZone(ev.target as HTMLElement)) {\n        if (\n          !this.focusElement(\n            getNextElement(\n              ev.target as HTMLElement,\n              (ev.target as HTMLElement).firstChild as HTMLElement,\n              true,\n            ) as HTMLElement,\n          )\n        ) {\n          return;\n        }\n      } else {\n        return;\n      }\n    } else if (ev.altKey) {\n      return;\n    } else {\n      // eslint-disable-next-line @fluentui/deprecated-keyboard-event-props, deprecation/deprecation\n      switch (ev.which) {\n        case KeyCodes.space:\n          if (this._shouldRaiseClicksOnSpace && this._tryInvokeClickForFocusable(ev.target as HTMLElement, ev)) {\n            break;\n          }\n          return;\n\n        case KeyCodes.left:\n          if (direction !== FocusZoneDirection.vertical) {\n            this._preventDefaultWhenHandled(ev);\n            if (this._moveFocusLeft(theme)) {\n              break;\n            }\n          }\n          return;\n\n        case KeyCodes.right:\n          if (direction !== FocusZoneDirection.vertical) {\n            this._preventDefaultWhenHandled(ev);\n            if (this._moveFocusRight(theme)) {\n              break;\n            }\n          }\n          return;\n\n        case KeyCodes.up:\n          if (direction !== FocusZoneDirection.horizontal) {\n            this._preventDefaultWhenHandled(ev);\n            if (this._moveFocusUp()) {\n              break;\n            }\n          }\n          return;\n\n        case KeyCodes.down:\n          if (direction !== FocusZoneDirection.horizontal) {\n            this._preventDefaultWhenHandled(ev);\n            if (this._moveFocusDown()) {\n              break;\n            }\n          }\n          return;\n        case KeyCodes.pageDown:\n          if (!pagingSupportDisabled && this._moveFocusPaging(true)) {\n            break;\n          }\n          return;\n        case KeyCodes.pageUp:\n          if (!pagingSupportDisabled && this._moveFocusPaging(false)) {\n            break;\n          }\n          return;\n\n        case KeyCodes.tab:\n          if (\n            // eslint-disable-next-line deprecation/deprecation\n            this.props.allowTabKey ||\n            this.props.handleTabKey === FocusZoneTabbableElements.all ||\n            (this.props.handleTabKey === FocusZoneTabbableElements.inputOnly &&\n              this._isElementInput(ev.target as HTMLElement))\n          ) {\n            let focusChanged = false;\n            this._processingTabKey = true;\n            if (\n              direction === FocusZoneDirection.vertical ||\n              !this._shouldWrapFocus(this._activeElement as HTMLElement, NO_HORIZONTAL_WRAP)\n            ) {\n              focusChanged = ev.shiftKey ? this._moveFocusUp() : this._moveFocusDown();\n            } else {\n              const tabWithDirection = getRTL(theme) ? !ev.shiftKey : ev.shiftKey;\n              focusChanged = tabWithDirection ? this._moveFocusLeft(theme) : this._moveFocusRight(theme);\n            }\n            this._processingTabKey = false;\n            if (focusChanged) {\n              break;\n            } else if (this.props.shouldResetActiveElementWhenTabFromZone) {\n              this._activeElement = null;\n            }\n          }\n          return;\n\n        case KeyCodes.home:\n          if (\n            this._isContentEditableElement(ev.target as HTMLElement) ||\n            (this._isElementInput(ev.target as HTMLElement) &&\n              !this._shouldInputLoseFocus(ev.target as HTMLInputElement, false))\n          ) {\n            return false;\n          }\n          const firstChild = this._root.current && (this._root.current.firstChild as HTMLElement | null);\n          if (\n            this._root.current &&\n            firstChild &&\n            this.focusElement(getNextElement(this._root.current, firstChild, true) as HTMLElement)\n          ) {\n            break;\n          }\n          return;\n\n        case KeyCodes.end:\n          if (\n            this._isContentEditableElement(ev.target as HTMLElement) ||\n            (this._isElementInput(ev.target as HTMLElement) &&\n              !this._shouldInputLoseFocus(ev.target as HTMLInputElement, true))\n          ) {\n            return false;\n          }\n\n          const lastChild = this._root.current && (this._root.current.lastChild as HTMLElement | null);\n          if (\n            this._root.current &&\n            this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true) as HTMLElement)\n          ) {\n            break;\n          }\n          return;\n\n        case KeyCodes.enter:\n          if (this._shouldRaiseClicksOnEnter && this._tryInvokeClickForFocusable(ev.target as HTMLElement, ev)) {\n            break;\n          }\n          return;\n\n        default:\n          return;\n      }\n    }\n\n    ev.preventDefault();\n    ev.stopPropagation();\n  };\n\n  /**\n   * Walk up the dom try to find a focusable element.\n   */\n  private _tryInvokeClickForFocusable(targetElement: HTMLElement, ev?: React.KeyboardEvent<HTMLElement>): boolean {\n    let target = targetElement;\n    if (target === this._root.current) {\n      return false;\n    }\n\n    do {\n      if (\n        target.tagName === 'BUTTON' ||\n        target.tagName === 'A' ||\n        target.tagName === 'INPUT' ||\n        target.tagName === 'TEXTAREA'\n      ) {\n        return false;\n      }\n\n      if (\n        this._isImmediateDescendantOfZone(target) &&\n        target.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' &&\n        target.getAttribute(IS_ENTER_DISABLED_ATTRIBUTE) !== 'true'\n      ) {\n        raiseClickFromKeyboardEvent(target, ev);\n        return true;\n      }\n\n      target = getParent(target, ALLOW_VIRTUAL_ELEMENTS) as HTMLElement;\n    } while (target !== this._root.current);\n\n    return false;\n  }\n\n  /**\n   * Traverse to find first child zone.\n   */\n  private _getFirstInnerZone(rootElement?: HTMLElement | null): FocusZone | null {\n    rootElement = rootElement || this._activeElement || this._root.current;\n\n    if (!rootElement) {\n      return null;\n    }\n\n    if (isElementFocusZone(rootElement)) {\n      return _allInstances[rootElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE) as string];\n    }\n\n    let child = rootElement.firstElementChild as HTMLElement | null;\n\n    while (child) {\n      if (isElementFocusZone(child)) {\n        return _allInstances[child.getAttribute(FOCUSZONE_ID_ATTRIBUTE) as string];\n      }\n      const match = this._getFirstInnerZone(child);\n\n      if (match) {\n        return match;\n      }\n\n      child = child.nextElementSibling as HTMLElement | null;\n    }\n\n    return null;\n  }\n\n  private _moveFocus(\n    isForward: boolean,\n    getDistanceFromCenter: (activeRect: ClientRect, targetRect: ClientRect) => number,\n    ev?: Event,\n    useDefaultWrap: boolean = true,\n  ): boolean {\n    let element = this._activeElement;\n    let candidateDistance = -1;\n    let candidateElement: HTMLElement | undefined = undefined;\n    let changedFocus = false;\n    const isBidirectional = this.props.direction === FocusZoneDirection.bidirectional;\n\n    if (!element || !this._root.current) {\n      return false;\n    }\n\n    if (this._isElementInput(element)) {\n      if (!this._shouldInputLoseFocus(element as HTMLInputElement, isForward)) {\n        return false;\n      }\n    }\n\n    const activeRect = isBidirectional ? element.getBoundingClientRect() : null;\n\n    do {\n      element = (isForward\n        ? getNextElement(this._root.current, element)\n        : getPreviousElement(this._root.current, element)) as HTMLElement;\n\n      if (isBidirectional) {\n        if (element) {\n          const targetRect = element.getBoundingClientRect();\n          const elementDistance = getDistanceFromCenter(activeRect as ClientRect, targetRect);\n\n          if (elementDistance === -1 && candidateDistance === -1) {\n            candidateElement = element;\n            break;\n          }\n\n          if (elementDistance > -1 && (candidateDistance === -1 || elementDistance < candidateDistance)) {\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          }\n\n          if (candidateDistance >= 0 && elementDistance < 0) {\n            break;\n          }\n        }\n      } else {\n        candidateElement = element;\n        break;\n      }\n    } while (element);\n\n    // Focus the closest candidate\n    if (candidateElement && candidateElement !== this._activeElement) {\n      changedFocus = true;\n      this.focusElement(candidateElement);\n    } else if (this.props.isCircularNavigation && useDefaultWrap) {\n      if (isForward) {\n        return this.focusElement(\n          getNextElement(this._root.current, this._root.current.firstElementChild as HTMLElement, true) as HTMLElement,\n        );\n      } else {\n        return this.focusElement(\n          getPreviousElement(\n            this._root.current,\n            this._root.current.lastElementChild as HTMLElement,\n            true,\n            true,\n            true,\n          ) as HTMLElement,\n        );\n      }\n    }\n\n    return changedFocus;\n  }\n\n  private _moveFocusDown(): boolean {\n    let targetTop = -1;\n    // eslint-disable-next-line deprecation/deprecation\n    const leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;\n\n    if (\n      this._moveFocus(true, (activeRect: ClientRect, targetRect: ClientRect) => {\n        let distance = -1;\n        // ClientRect values can be floats that differ by very small fractions of a decimal.\n        // If the difference between top and bottom are within a pixel then we should treat\n        // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n        // but without Math.Floor they will be handled incorrectly.\n        const targetRectTop = Math.floor(targetRect.top);\n        const activeRectBottom = Math.floor(activeRect.bottom);\n\n        if (targetRectTop < activeRectBottom) {\n          if (!this._shouldWrapFocus(this._activeElement as HTMLElement, NO_VERTICAL_WRAP)) {\n            return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n          }\n\n          return LARGE_DISTANCE_FROM_CENTER;\n        }\n\n        if ((targetTop === -1 && targetRectTop >= activeRectBottom) || targetRectTop === targetTop) {\n          targetTop = targetRectTop;\n          if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n            distance = 0;\n          } else {\n            distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n          }\n        }\n\n        return distance;\n      })\n    ) {\n      this._setFocusAlignment(this._activeElement as HTMLElement, false, true);\n      return true;\n    }\n\n    return false;\n  }\n\n  private _moveFocusUp(): boolean {\n    let targetTop = -1;\n    // eslint-disable-next-line deprecation/deprecation\n    const leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;\n\n    if (\n      this._moveFocus(false, (activeRect: ClientRect, targetRect: ClientRect) => {\n        let distance = -1;\n        // ClientRect values can be floats that differ by very small fractions of a decimal.\n        // If the difference between top and bottom are within a pixel then we should treat\n        // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n        // but without Math.Floor they will be handled incorrectly.\n        const targetRectBottom = Math.floor(targetRect.bottom);\n        const targetRectTop = Math.floor(targetRect.top);\n        const activeRectTop = Math.floor(activeRect.top);\n\n        if (targetRectBottom > activeRectTop) {\n          if (!this._shouldWrapFocus(this._activeElement as HTMLElement, NO_VERTICAL_WRAP)) {\n            return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n          }\n          return LARGE_DISTANCE_FROM_CENTER;\n        }\n\n        if ((targetTop === -1 && targetRectBottom <= activeRectTop) || targetRectTop === targetTop) {\n          targetTop = targetRectTop;\n          if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n            distance = 0;\n          } else {\n            distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n          }\n        }\n\n        return distance;\n      })\n    ) {\n      this._setFocusAlignment(this._activeElement as HTMLElement, false, true);\n      return true;\n    }\n\n    return false;\n  }\n\n  private _moveFocusLeft(theme: ITheme): boolean {\n    const shouldWrap = this._shouldWrapFocus(this._activeElement as HTMLElement, NO_HORIZONTAL_WRAP);\n    if (\n      this._moveFocus(\n        getRTL(theme),\n        (activeRect: ClientRect, targetRect: ClientRect) => {\n          let distance = -1;\n          let topBottomComparison;\n\n          if (getRTL(theme)) {\n            // When in RTL, this comparison should be the same as the one in _moveFocusRight for LTR.\n            // Going left at a leftmost rectangle will go down a line instead of up a line like in LTR.\n            // This is important, because we want to be comparing the top of the target rect\n            // with the bottom of the active rect.\n            topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));\n          } else {\n            topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));\n          }\n\n          if (\n            topBottomComparison &&\n            targetRect.right <= activeRect.right &&\n            this.props.direction !== FocusZoneDirection.vertical\n          ) {\n            distance = activeRect.right - targetRect.right;\n          } else if (!shouldWrap) {\n            distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n          }\n\n          return distance;\n        },\n        undefined /*ev*/,\n        shouldWrap,\n      )\n    ) {\n      this._setFocusAlignment(this._activeElement as HTMLElement, true, false);\n      return true;\n    }\n\n    return false;\n  }\n\n  private _moveFocusRight(theme: ITheme): boolean {\n    const shouldWrap = this._shouldWrapFocus(this._activeElement as HTMLElement, NO_HORIZONTAL_WRAP);\n    if (\n      this._moveFocus(\n        !getRTL(theme),\n        (activeRect: ClientRect, targetRect: ClientRect) => {\n          let distance = -1;\n          let topBottomComparison;\n\n          if (getRTL(theme)) {\n            // When in RTL, this comparison should be the same as the one in _moveFocusLeft for LTR.\n            // Going right at a rightmost rectangle will go up a line instead of down a line like in LTR.\n            // This is important, because we want to be comparing the bottom of the target rect\n            // with the top of the active rect.\n            topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));\n          } else {\n            topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));\n          }\n\n          if (\n            topBottomComparison &&\n            targetRect.left >= activeRect.left &&\n            this.props.direction !== FocusZoneDirection.vertical\n          ) {\n            distance = targetRect.left - activeRect.left;\n          } else if (!shouldWrap) {\n            distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n          }\n\n          return distance;\n        },\n        undefined /*ev*/,\n        shouldWrap,\n      )\n    ) {\n      this._setFocusAlignment(this._activeElement as HTMLElement, true, false);\n      return true;\n    }\n\n    return false;\n  }\n\n  private _getHorizontalDistanceFromCenter = (\n    isForward: boolean,\n    activeRect: ClientRect,\n    targetRect: ClientRect,\n  ): number => {\n    // eslint-disable-next-line deprecation/deprecation\n    const leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;\n    // ClientRect values can be floats that differ by very small fractions of a decimal.\n    // If the difference between top and bottom are within a pixel then we should treat\n    // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n    // but without Math.Floor they will be handled incorrectly.\n    const targetRectTop = Math.floor(targetRect.top);\n    const activeRectBottom = Math.floor(activeRect.bottom);\n    const targetRectBottom = Math.floor(targetRect.bottom);\n    const activeRectTop = Math.floor(activeRect.top);\n    const isValidCandidateOnpagingDown = isForward && targetRectTop > activeRectBottom;\n    const isValidCandidateOnpagingUp = !isForward && targetRectBottom < activeRectTop;\n\n    if (isValidCandidateOnpagingDown || isValidCandidateOnpagingUp) {\n      if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n        return 0;\n      }\n      return Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n    }\n\n    if (!this._shouldWrapFocus(this._activeElement as HTMLElement, NO_VERTICAL_WRAP)) {\n      return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n    }\n    return LARGE_DISTANCE_FROM_CENTER;\n  };\n\n  private _moveFocusPaging(isForward: boolean, useDefaultWrap: boolean = true): boolean {\n    let element = this._activeElement;\n    if (!element || !this._root.current) {\n      return false;\n    }\n    if (this._isElementInput(element)) {\n      if (!this._shouldInputLoseFocus(element as HTMLInputElement, isForward)) {\n        return false;\n      }\n    }\n    const scrollableParent = findScrollableParent(element);\n    if (!scrollableParent) {\n      return false;\n    }\n    let candidateDistance = -1;\n    let candidateElement = undefined;\n    let targetTop = -1;\n    let targetBottom = -1;\n    const pagesize = (scrollableParent as HTMLElement).clientHeight;\n    const activeRect = element.getBoundingClientRect();\n    do {\n      element = isForward\n        ? getNextElement(this._root.current, element)\n        : getPreviousElement(this._root.current, element);\n      if (element) {\n        const targetRect = element.getBoundingClientRect();\n        const targetRectTop = Math.floor(targetRect.top);\n        const activeRectBottom = Math.floor(activeRect.bottom);\n        const targetRectBottom = Math.floor(targetRect.bottom);\n        const activeRectTop = Math.floor(activeRect.top);\n        const elementDistance = this._getHorizontalDistanceFromCenter(isForward, activeRect, targetRect);\n        const isElementPassedPageSizeOnPagingDown = isForward && targetRectTop > activeRectBottom + pagesize;\n        const isElementPassedPageSizeOnPagingUp = !isForward && targetRectBottom < activeRectTop - pagesize;\n\n        if (isElementPassedPageSizeOnPagingDown || isElementPassedPageSizeOnPagingUp) {\n          break;\n        }\n        if (elementDistance > -1) {\n          // for paging down\n          if (isForward && targetRectTop > targetTop) {\n            targetTop = targetRectTop;\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          } else if (!isForward && targetRectBottom < targetBottom) {\n            // for paging up\n            targetBottom = targetRectBottom;\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          } else if (candidateDistance === -1 || elementDistance <= candidateDistance) {\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          }\n        }\n      }\n    } while (element);\n\n    let changedFocus = false;\n    // Focus the closest candidate\n    if (candidateElement && candidateElement !== this._activeElement) {\n      changedFocus = true;\n      this.focusElement(candidateElement);\n      this._setFocusAlignment(candidateElement as HTMLElement, false, true);\n    } else if (this.props.isCircularNavigation && useDefaultWrap) {\n      if (isForward) {\n        return this.focusElement(\n          getNextElement(this._root.current, this._root.current.firstElementChild as HTMLElement, true) as HTMLElement,\n        );\n      }\n      return this.focusElement(\n        getPreviousElement(\n          this._root.current,\n          this._root.current.lastElementChild as HTMLElement,\n          true,\n          true,\n          true,\n        ) as HTMLElement,\n      );\n    }\n    return changedFocus;\n  }\n\n  private _setFocusAlignment(element: HTMLElement, isHorizontal?: boolean, isVertical?: boolean): void {\n    if (\n      this.props.direction === FocusZoneDirection.bidirectional &&\n      (!this._focusAlignment || isHorizontal || isVertical)\n    ) {\n      const rect = element.getBoundingClientRect();\n      const left = rect.left + rect.width / 2;\n      const top = rect.top + rect.height / 2;\n\n      if (!this._focusAlignment) {\n        this._focusAlignment = { left, top };\n      }\n\n      if (isHorizontal) {\n        this._focusAlignment.left = left;\n      }\n\n      if (isVertical) {\n        this._focusAlignment.top = top;\n      }\n    }\n  }\n\n  private _isImmediateDescendantOfZone(element?: HTMLElement): boolean {\n    return this._getOwnerZone(element) === this._root.current;\n  }\n\n  private _getOwnerZone(element?: HTMLElement): HTMLElement | null {\n    let parentElement = getParent(element as HTMLElement, ALLOW_VIRTUAL_ELEMENTS);\n\n    while (parentElement && parentElement !== this._root.current && parentElement !== this._getDocument().body) {\n      if (isElementFocusZone(parentElement)) {\n        return parentElement;\n      }\n\n      parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n    }\n\n    return parentElement;\n  }\n\n  private _updateTabIndexes(element?: HTMLElement): void {\n    if (\n      !this._activeElement &&\n      this.props.defaultTabbableElement &&\n      typeof this.props.defaultTabbableElement === 'function'\n    ) {\n      this._activeElement = this.props.defaultTabbableElement(this._root.current as HTMLElement);\n    }\n\n    if (!element && this._root.current) {\n      this._defaultFocusElement = null;\n      element = this._root.current;\n      if (this._activeElement && !elementContains(element, this._activeElement)) {\n        this._activeElement = null;\n      }\n    }\n\n    // If active element changes state to disabled, set it to null.\n    // Otherwise, we lose keyboard accessibility to other elements in focus zone.\n    if (this._activeElement && !isElementTabbable(this._activeElement)) {\n      this._activeElement = null;\n    }\n\n    const childNodes = element && element.children;\n\n    for (let childIndex = 0; childNodes && childIndex < childNodes.length; childIndex++) {\n      const child = childNodes[childIndex] as HTMLElement;\n\n      if (!isElementFocusZone(child)) {\n        // If the item is explicitly set to not be focusable then TABINDEX needs to be set to -1.\n        if (child.getAttribute && child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'false') {\n          child.setAttribute(TABINDEX, '-1');\n        }\n\n        if (isElementTabbable(child)) {\n          if (this.props.disabled) {\n            child.setAttribute(TABINDEX, '-1');\n          } else if (\n            !this._isInnerZone &&\n            ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)\n          ) {\n            this._defaultFocusElement = child;\n            if (child.getAttribute(TABINDEX) !== '0') {\n              child.setAttribute(TABINDEX, '0');\n            }\n          } else if (child.getAttribute(TABINDEX) !== '-1') {\n            child.setAttribute(TABINDEX, '-1');\n          }\n        } else if (child.tagName === 'svg' && child.getAttribute('focusable') !== 'false') {\n          // Disgusting IE hack. Sad face.\n          child.setAttribute('focusable', 'false');\n        }\n      } else if (child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true') {\n        if (\n          !this._isInnerZone &&\n          ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)\n        ) {\n          this._defaultFocusElement = child;\n          if (child.getAttribute(TABINDEX) !== '0') {\n            child.setAttribute(TABINDEX, '0');\n          }\n        } else if (child.getAttribute(TABINDEX) !== '-1') {\n          child.setAttribute(TABINDEX, '-1');\n        }\n      }\n\n      this._updateTabIndexes(child);\n    }\n  }\n\n  private _isContentEditableElement(element: HTMLElement): boolean {\n    return element && element.getAttribute('contenteditable') === 'true';\n  }\n\n  private _isElementInput(element: HTMLElement): boolean {\n    if (\n      element &&\n      element.tagName &&\n      (element.tagName.toLowerCase() === 'input' || element.tagName.toLowerCase() === 'textarea')\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  private _shouldInputLoseFocus(element: HTMLInputElement, isForward?: boolean): boolean {\n    // If a tab was used, we want to focus on the next element.\n    if (\n      !this._processingTabKey &&\n      element &&\n      element.type &&\n      ALLOWED_INPUT_TYPES.indexOf(element.type.toLowerCase()) > -1\n    ) {\n      const selectionStart = element.selectionStart;\n      const selectionEnd = element.selectionEnd;\n      const isRangeSelected = selectionStart !== selectionEnd;\n      const inputValue = element.value;\n      const isReadonly = element.readOnly;\n\n      // We shouldn't lose focus in the following cases:\n      // 1. There is range selected.\n      // 2. When selection start is larger than 0 and it is backward and not readOnly.\n      // 3. when selection start is not the end of length, it is forward and not readOnly.\n      // 4. We press any of the arrow keys when our handleTabKey isn't none or undefined (only losing focus if we hit\n      // tab) and if shouldInputLoseFocusOnArrowKey is defined, if scenario prefers to not loose the focus which is\n      // determined by calling the callback shouldInputLoseFocusOnArrowKey\n      if (\n        isRangeSelected ||\n        (selectionStart! > 0 && !isForward && !isReadonly) ||\n        (selectionStart !== inputValue.length && isForward && !isReadonly) ||\n        (!!this.props.handleTabKey &&\n          !(this.props.shouldInputLoseFocusOnArrowKey && this.props.shouldInputLoseFocusOnArrowKey(element)))\n      ) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private _shouldWrapFocus(\n    element: HTMLElement,\n    noWrapDataAttribute: 'data-no-vertical-wrap' | 'data-no-horizontal-wrap',\n  ): boolean {\n    return this.props.checkForNoWrap ? shouldWrapFocus(element, noWrapDataAttribute) : true;\n  }\n\n  /**\n   * Returns true if the element is a descendant of the FocusZone through a React portal.\n   */\n  private _portalContainsElement(element: HTMLElement): boolean {\n    return element && !!this._root.current && portalContainsElement(element, this._root.current);\n  }\n\n  private _getDocument(): Document {\n    return getDocument(this._root.current)!;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}