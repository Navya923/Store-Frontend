{"ast":null,"code":"var _a;\n\nimport { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { css, divProperties, elementContains, focusFirstChild, getNativeProps, on, shallowCompare, getPropsWithDefaults } from '../../Utilities';\nimport { positionCallout, RectangleEdge, positionCard, getBoundsFromTargetWindow } from '../../Positioning';\nimport { Popup } from '../../Popup';\nimport { classNamesFunction } from '../../Utilities';\nimport { AnimationClassNames } from '../../Styling';\nimport { useMergedRefs, useAsync, useConst, useTarget, useOnEvent } from '@fluentui/react-hooks';\nvar COMPONENT_NAME = 'CalloutContentBase';\nvar ANIMATIONS = (_a = {}, _a[RectangleEdge.top] = AnimationClassNames.slideUpIn10, _a[RectangleEdge.bottom] = AnimationClassNames.slideDownIn10, _a[RectangleEdge.left] = AnimationClassNames.slideLeftIn10, _a[RectangleEdge.right] = AnimationClassNames.slideRightIn10, _a);\nvar BEAK_ORIGIN_POSITION = {\n  top: 0,\n  left: 0\n}; // Microsoft Edge will overwrite inline styles if there is an animation pertaining to that style.\n// To help ensure that edge will respect the offscreen style opacity\n// filter needs to be added as an additional way to set opacity.\n// Also set pointer-events: none so that the callout will not occlude the element it is\n// going to be positioned against\n\nvar OFF_SCREEN_STYLE = {\n  opacity: 0,\n  filter: 'opacity(0)',\n  pointerEvents: 'none'\n}; // role and role description go hand-in-hand. Both would be included by spreading getNativeProps for a basic element\n// This constant array can be used to filter these out of native props spread on callout root and apply them together on\n// calloutMain (the Popup component within the callout)\n\nvar ARIA_ROLE_ATTRIBUTES = ['role', 'aria-roledescription'];\nvar DEFAULT_PROPS = {\n  preventDismissOnLostFocus: false,\n  preventDismissOnScroll: false,\n  preventDismissOnResize: false,\n  isBeakVisible: true,\n  beakWidth: 16,\n  gapSpace: 0,\n  minPagePadding: 8,\n  directionalHint: DirectionalHint.bottomAutoEdge\n};\nvar getClassNames = classNamesFunction({\n  disableCaching: true // disabling caching because stylesProp.position mutates often\n\n});\n/**\n * (Hook) to return a function to lazily fetch the bounds of the target element for the callout.\n */\n\nfunction useBounds(_a, targetRef, targetWindow) {\n  var bounds = _a.bounds,\n      _b = _a.minPagePadding,\n      minPagePadding = _b === void 0 ? DEFAULT_PROPS.minPagePadding : _b,\n      target = _a.target;\n\n  var _c = React.useState(false),\n      targetWindowResized = _c[0],\n      setTargetWindowResized = _c[1];\n\n  var cachedBounds = React.useRef();\n  var getBounds = React.useCallback(function () {\n    if (!cachedBounds.current || targetWindowResized) {\n      var currentBounds = typeof bounds === 'function' ? targetWindow ? bounds(target, targetWindow) : undefined : bounds;\n\n      if (!currentBounds && targetWindow) {\n        currentBounds = getBoundsFromTargetWindow(targetRef.current, targetWindow);\n        currentBounds = {\n          top: currentBounds.top + minPagePadding,\n          left: currentBounds.left + minPagePadding,\n          right: currentBounds.right - minPagePadding,\n          bottom: currentBounds.bottom - minPagePadding,\n          width: currentBounds.width - minPagePadding * 2,\n          height: currentBounds.height - minPagePadding * 2\n        };\n      }\n\n      cachedBounds.current = currentBounds;\n      targetWindowResized && setTargetWindowResized(false);\n    }\n\n    return cachedBounds.current;\n  }, [bounds, minPagePadding, target, targetRef, targetWindow, targetWindowResized]);\n  var async = useAsync();\n  useOnEvent(targetWindow, 'resize', async.debounce(function () {\n    setTargetWindowResized(true);\n  }, 500, {\n    leading: true\n  }));\n  return getBounds;\n}\n/**\n * (Hook) to return the maximum available height for the Callout to render into.\n */\n\n\nfunction useMaxHeight(_a, getBounds, positions) {\n  var _b;\n\n  var calloutMaxHeight = _a.calloutMaxHeight,\n      finalHeight = _a.finalHeight,\n      directionalHint = _a.directionalHint,\n      directionalHintFixed = _a.directionalHintFixed,\n      hidden = _a.hidden;\n\n  var _c = React.useState(),\n      maxHeight = _c[0],\n      setMaxHeight = _c[1];\n\n  var _d = (_b = positions === null || positions === void 0 ? void 0 : positions.elementPosition) !== null && _b !== void 0 ? _b : {},\n      top = _d.top,\n      bottom = _d.bottom;\n\n  React.useEffect(function () {\n    var _a;\n\n    var _b = (_a = getBounds()) !== null && _a !== void 0 ? _a : {},\n        topBounds = _b.top,\n        bottomBounds = _b.bottom;\n\n    if (!calloutMaxHeight && !hidden) {\n      if (typeof top === 'number' && bottomBounds) {\n        setMaxHeight(bottomBounds - top);\n      } else if (typeof bottom === 'number' && typeof topBounds === 'number' && bottomBounds) {\n        setMaxHeight(bottomBounds - topBounds - bottom);\n      }\n    } else if (calloutMaxHeight) {\n      setMaxHeight(calloutMaxHeight);\n    } else {\n      setMaxHeight(undefined);\n    }\n  }, [bottom, calloutMaxHeight, finalHeight, directionalHint, directionalHintFixed, getBounds, hidden, positions, top]);\n  return maxHeight;\n}\n/**\n * (Hook) to find the current position of Callout. If Callout is resized then a new position is calculated.\n */\n\n\nfunction usePositions(props, hostElement, calloutElement, targetRef, getBounds) {\n  var _a = React.useState(),\n      positions = _a[0],\n      setPositions = _a[1];\n\n  var positionAttempts = React.useRef(0);\n  var previousTarget = React.useRef();\n  var async = useAsync();\n  var hidden = props.hidden,\n      target = props.target,\n      finalHeight = props.finalHeight,\n      calloutMaxHeight = props.calloutMaxHeight,\n      onPositioned = props.onPositioned,\n      directionalHint = props.directionalHint;\n  React.useEffect(function () {\n    if (!hidden) {\n      var timerId_1 = async.requestAnimationFrame(function () {\n        var _a, _b;\n\n        if (hostElement.current && calloutElement) {\n          var currentProps = __assign(__assign({}, props), {\n            target: targetRef.current,\n            bounds: getBounds()\n          }); // duplicate calloutElement & remove useMaxHeight's maxHeight for position calc\n\n\n          var dupeCalloutElement = calloutElement.cloneNode(true);\n          dupeCalloutElement.style.maxHeight = calloutMaxHeight ? \"\" + calloutMaxHeight : '';\n          dupeCalloutElement.style.visibility = 'hidden';\n          (_a = calloutElement.parentElement) === null || _a === void 0 ? void 0 : _a.appendChild(dupeCalloutElement);\n          var previousPositions = previousTarget.current === target ? positions : undefined; // If there is a finalHeight given then we assume that the user knows and will handle\n          // additional positioning adjustments so we should call positionCard\n\n          var newPositions = finalHeight ? positionCard(currentProps, hostElement.current, dupeCalloutElement, previousPositions) : positionCallout(currentProps, hostElement.current, dupeCalloutElement, previousPositions); // clean up duplicate calloutElement\n\n          (_b = calloutElement.parentElement) === null || _b === void 0 ? void 0 : _b.removeChild(dupeCalloutElement); // Set the new position only when the positions do not exist or one of the new callout positions\n          // is different. The position should not change if the position is within 2 decimal places.\n\n          if (!positions && newPositions || positions && newPositions && !arePositionsEqual(positions, newPositions) && positionAttempts.current < 5) {\n            // We should not reposition the callout more than a few times, if it is then the content is likely resizing\n            // and we should stop trying to reposition to prevent a stack overflow.\n            positionAttempts.current++;\n            setPositions(newPositions);\n          } else if (positionAttempts.current > 0) {\n            // Only call the onPositioned callback if the callout has been re-positioned at least once.\n            positionAttempts.current = 0;\n            onPositioned === null || onPositioned === void 0 ? void 0 : onPositioned(positions);\n          }\n        }\n      }, calloutElement);\n      previousTarget.current = target;\n      return function () {\n        async.cancelAnimationFrame(timerId_1);\n        previousTarget.current = undefined;\n      };\n    } else {\n      // When the callout is hidden, clear position state so that it is not accidentally used next render.\n      setPositions(undefined);\n      positionAttempts.current = 0;\n    }\n  }, [hidden, directionalHint, async, calloutElement, calloutMaxHeight, hostElement, targetRef, finalHeight, getBounds, onPositioned, positions, props, target]);\n  return positions;\n}\n/**\n * (Hook) to set up behavior to automatically focus the callout when it appears, if indicated by props.\n */\n\n\nfunction useAutoFocus(_a, positions, calloutElement) {\n  var hidden = _a.hidden,\n      setInitialFocus = _a.setInitialFocus;\n  var async = useAsync();\n  var hasPositions = !!positions;\n  React.useEffect(function () {\n    if (!hidden && setInitialFocus && hasPositions && calloutElement) {\n      var timerId_2 = async.requestAnimationFrame(function () {\n        return focusFirstChild(calloutElement);\n      }, calloutElement);\n      return function () {\n        return async.cancelAnimationFrame(timerId_2);\n      };\n    }\n  }, [hidden, hasPositions, async, calloutElement, setInitialFocus]);\n}\n/**\n * (Hook) to set up various handlers to dismiss the popup when it loses focus or the window scrolls or similar cases.\n */\n\n\nfunction useDismissHandlers(_a, positions, hostElement, targetRef, targetWindow) {\n  var hidden = _a.hidden,\n      onDismiss = _a.onDismiss,\n      // eslint-disable-next-line deprecation/deprecation\n  preventDismissOnScroll = _a.preventDismissOnScroll,\n      // eslint-disable-next-line deprecation/deprecation\n  preventDismissOnResize = _a.preventDismissOnResize,\n      // eslint-disable-next-line deprecation/deprecation\n  preventDismissOnLostFocus = _a.preventDismissOnLostFocus,\n      dismissOnTargetClick = _a.dismissOnTargetClick,\n      shouldDismissOnWindowFocus = _a.shouldDismissOnWindowFocus,\n      preventDismissOnEvent = _a.preventDismissOnEvent;\n  var isMouseDownOnPopup = React.useRef(false);\n  var async = useAsync();\n  var mouseDownHandlers = useConst([function () {\n    isMouseDownOnPopup.current = true;\n  }, function () {\n    isMouseDownOnPopup.current = false;\n  }]);\n  var positionsExists = !!positions;\n  React.useEffect(function () {\n    var dismissOnScroll = function (ev) {\n      if (positionsExists && !preventDismissOnScroll) {\n        dismissOnClickOrScroll(ev);\n      }\n    };\n\n    var dismissOnResize = function (ev) {\n      if (!preventDismissOnResize && !(preventDismissOnEvent && preventDismissOnEvent(ev))) {\n        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);\n      }\n    };\n\n    var dismissOnLostFocus = function (ev) {\n      if (!preventDismissOnLostFocus) {\n        dismissOnClickOrScroll(ev);\n      }\n    };\n\n    var dismissOnClickOrScroll = function (ev) {\n      var eventPaths = ev.composedPath ? ev.composedPath() : [];\n      var target = eventPaths.length > 0 ? eventPaths[0] : ev.target;\n      var isEventTargetOutsideCallout = hostElement.current && !elementContains(hostElement.current, target); // If mouse is pressed down on callout but moved outside then released, don't dismiss the callout.\n\n      if (isEventTargetOutsideCallout && isMouseDownOnPopup.current) {\n        isMouseDownOnPopup.current = false;\n        return;\n      }\n\n      if (!targetRef.current && isEventTargetOutsideCallout || ev.target !== targetWindow && isEventTargetOutsideCallout && (!targetRef.current || 'stopPropagation' in targetRef.current || dismissOnTargetClick || target !== targetRef.current && !elementContains(targetRef.current, target))) {\n        if (preventDismissOnEvent && preventDismissOnEvent(ev)) {\n          return;\n        }\n\n        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);\n      }\n    };\n\n    var dismissOnTargetWindowBlur = function (ev) {\n      // Do nothing\n      if (!shouldDismissOnWindowFocus) {\n        return;\n      }\n\n      if ((preventDismissOnEvent && !preventDismissOnEvent(ev) || !preventDismissOnEvent && !preventDismissOnLostFocus) && !(targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.hasFocus()) && ev.relatedTarget === null) {\n        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);\n      }\n    }; // This is added so the callout will dismiss when the window is scrolled\n    // but not when something inside the callout is scrolled. The delay seems\n    // to be required to avoid React firing an async focus event in IE from\n    // the target changing focus quickly prior to rendering the callout.\n\n\n    var disposablesPromise = new Promise(function (resolve) {\n      async.setTimeout(function () {\n        if (!hidden && targetWindow) {\n          var disposables_1 = [on(targetWindow, 'scroll', dismissOnScroll, true), on(targetWindow, 'resize', dismissOnResize, true), on(targetWindow.document.documentElement, 'focus', dismissOnLostFocus, true), on(targetWindow.document.documentElement, 'click', dismissOnLostFocus, true), on(targetWindow, 'blur', dismissOnTargetWindowBlur, true)];\n          resolve(function () {\n            disposables_1.forEach(function (dispose) {\n              return dispose();\n            });\n          });\n        }\n      }, 0);\n    });\n    return function () {\n      disposablesPromise.then(function (dispose) {\n        return dispose();\n      });\n    };\n  }, [hidden, async, hostElement, targetRef, targetWindow, onDismiss, shouldDismissOnWindowFocus, dismissOnTargetClick, preventDismissOnLostFocus, preventDismissOnResize, preventDismissOnScroll, positionsExists, preventDismissOnEvent]);\n  return mouseDownHandlers;\n}\n\nexport var CalloutContentBase = React.memo(React.forwardRef(function (propsWithoutDefaults, forwardedRef) {\n  var props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n  var styles = props.styles,\n      style = props.style,\n      ariaLabel = props.ariaLabel,\n      ariaDescribedBy = props.ariaDescribedBy,\n      ariaLabelledBy = props.ariaLabelledBy,\n      className = props.className,\n      isBeakVisible = props.isBeakVisible,\n      children = props.children,\n      beakWidth = props.beakWidth,\n      calloutWidth = props.calloutWidth,\n      calloutMaxWidth = props.calloutMaxWidth,\n      calloutMinWidth = props.calloutMinWidth,\n      doNotLayer = props.doNotLayer,\n      finalHeight = props.finalHeight,\n      _a = props.hideOverflow,\n      hideOverflow = _a === void 0 ? !!finalHeight : _a,\n      backgroundColor = props.backgroundColor,\n      calloutMaxHeight = props.calloutMaxHeight,\n      onScroll = props.onScroll,\n      // eslint-disable-next-line deprecation/deprecation\n  _b = props.shouldRestoreFocus,\n      // eslint-disable-next-line deprecation/deprecation\n  shouldRestoreFocus = _b === void 0 ? true : _b,\n      target = props.target,\n      hidden = props.hidden,\n      onLayerMounted = props.onLayerMounted;\n  var hostElement = React.useRef(null);\n\n  var _c = React.useState(null),\n      calloutElement = _c[0],\n      setCalloutElement = _c[1];\n\n  var calloutCallback = React.useCallback(function (calloutEl) {\n    setCalloutElement(calloutEl);\n  }, []);\n  var rootRef = useMergedRefs(hostElement, forwardedRef);\n\n  var _d = useTarget(props.target, {\n    current: calloutElement\n  }),\n      targetRef = _d[0],\n      targetWindow = _d[1];\n\n  var getBounds = useBounds(props, targetRef, targetWindow);\n  var positions = usePositions(props, hostElement, calloutElement, targetRef, getBounds);\n  var maxHeight = useMaxHeight(props, getBounds, positions);\n\n  var _e = useDismissHandlers(props, positions, hostElement, targetRef, targetWindow),\n      mouseDownOnPopup = _e[0],\n      mouseUpOnPopup = _e[1]; // do not set both top and bottom css props from positions\n  // instead, use maxHeight\n\n\n  var isForcedInBounds = (positions === null || positions === void 0 ? void 0 : positions.elementPosition.top) && (positions === null || positions === void 0 ? void 0 : positions.elementPosition.bottom);\n\n  var cssPositions = __assign(__assign({}, positions === null || positions === void 0 ? void 0 : positions.elementPosition), {\n    maxHeight: maxHeight\n  });\n\n  if (isForcedInBounds) {\n    cssPositions.bottom = undefined;\n  }\n\n  useAutoFocus(props, positions, calloutElement);\n  React.useEffect(function () {\n    if (!hidden) {\n      onLayerMounted === null || onLayerMounted === void 0 ? void 0 : onLayerMounted();\n    } // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run if hidden changes\n\n  }, [hidden]); // If there is no target window then we are likely in server side rendering and we should not render anything.\n\n  if (!targetWindow) {\n    return null;\n  }\n\n  var overflowYHidden = hideOverflow;\n  var beakVisible = isBeakVisible && !!target;\n  var classNames = getClassNames(styles, {\n    theme: props.theme,\n    className: className,\n    overflowYHidden: overflowYHidden,\n    calloutWidth: calloutWidth,\n    positions: positions,\n    beakWidth: beakWidth,\n    backgroundColor: backgroundColor,\n    calloutMaxWidth: calloutMaxWidth,\n    calloutMinWidth: calloutMinWidth,\n    doNotLayer: doNotLayer\n  });\n\n  var overflowStyle = __assign(__assign({\n    maxHeight: calloutMaxHeight ? calloutMaxHeight : '100%'\n  }, style), overflowYHidden && {\n    overflowY: 'hidden'\n  });\n\n  var visibilityStyle = props.hidden ? {\n    visibility: 'hidden'\n  } : undefined; // React.CSSProperties does not understand IRawStyle, so the inline animations will need to be cast as any for now.\n\n  return React.createElement(\"div\", {\n    ref: rootRef,\n    className: classNames.container,\n    style: visibilityStyle\n  }, React.createElement(\"div\", __assign({}, getNativeProps(props, divProperties, ARIA_ROLE_ATTRIBUTES), {\n    className: css(classNames.root, positions && positions.targetEdge && ANIMATIONS[positions.targetEdge]),\n    style: positions ? __assign({}, cssPositions) : OFF_SCREEN_STYLE,\n    // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.\n    // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus\n    tabIndex: -1,\n    ref: calloutCallback\n  }), beakVisible && React.createElement(\"div\", {\n    className: classNames.beak,\n    style: getBeakPosition(positions)\n  }), beakVisible && React.createElement(\"div\", {\n    className: classNames.beakCurtain\n  }), React.createElement(Popup // don't use getNativeElementProps for role and roledescription because it will also\n  // pass through data-* props (resulting in them being used in two places)\n  , {\n    // don't use getNativeElementProps for role and roledescription because it will also\n    // pass through data-* props (resulting in them being used in two places)\n    role: props.role,\n    \"aria-roledescription\": props['aria-roledescription'],\n    ariaDescribedBy: ariaDescribedBy,\n    ariaLabel: ariaLabel,\n    ariaLabelledBy: ariaLabelledBy,\n    className: classNames.calloutMain,\n    onDismiss: props.onDismiss,\n    onMouseDown: mouseDownOnPopup,\n    onMouseUp: mouseUpOnPopup,\n    onRestoreFocus: props.onRestoreFocus,\n    onScroll: onScroll,\n    shouldRestoreFocus: shouldRestoreFocus,\n    style: overflowStyle\n  }, children)));\n}), function (previousProps, nextProps) {\n  if (!nextProps.shouldUpdateWhenHidden && previousProps.hidden && nextProps.hidden) {\n    // Do not update when hidden.\n    return true;\n  }\n\n  return shallowCompare(previousProps, nextProps);\n});\n/**\n * (Utility) to find and return the current `Callout` Beak position.\n *\n * @param positions\n */\n\nfunction getBeakPosition(positions) {\n  var _a, _b;\n\n  var beakPositionStyle = __assign(__assign({}, (_a = positions === null || positions === void 0 ? void 0 : positions.beakPosition) === null || _a === void 0 ? void 0 : _a.elementPosition), {\n    display: ((_b = positions === null || positions === void 0 ? void 0 : positions.beakPosition) === null || _b === void 0 ? void 0 : _b.hideBeak) ? 'none' : undefined\n  });\n\n  if (!beakPositionStyle.top && !beakPositionStyle.bottom && !beakPositionStyle.left && !beakPositionStyle.right) {\n    beakPositionStyle.left = BEAK_ORIGIN_POSITION.left;\n    beakPositionStyle.top = BEAK_ORIGIN_POSITION.top;\n  }\n\n  return beakPositionStyle;\n}\n/**\n * (Utility) used to compare two different elementPositions to determine whether they are equal.\n *\n * @param prevElementPositions\n * @param newElementPosition\n */\n\n\nfunction arePositionsEqual(prevElementPositions, newElementPosition) {\n  return comparePositions(prevElementPositions.elementPosition, newElementPosition.elementPosition) && comparePositions(prevElementPositions.beakPosition.elementPosition, newElementPosition.beakPosition.elementPosition);\n}\n/**\n * (Utility) used in **arePositionsEqual** to compare two different elementPositions.\n *\n * @param prevElementPositions\n * @param newElementPositions\n */\n\n\nfunction comparePositions(prevElementPositions, newElementPositions) {\n  for (var key in newElementPositions) {\n    if (newElementPositions.hasOwnProperty(key)) {\n      var oldPositionEdge = prevElementPositions[key];\n      var newPositionEdge = newElementPositions[key];\n\n      if (oldPositionEdge !== undefined && newPositionEdge !== undefined) {\n        if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nCalloutContentBase.displayName = COMPONENT_NAME;","map":{"version":3,"mappings":"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","names":["React","DirectionalHint","css","divProperties","elementContains","focusFirstChild","getNativeProps","on","shallowCompare","getPropsWithDefaults","positionCallout","RectangleEdge","positionCard","getBoundsFromTargetWindow","Popup","classNamesFunction","AnimationClassNames","useMergedRefs","useAsync","useConst","useTarget","useOnEvent","COMPONENT_NAME","ANIMATIONS","_a","top","slideUpIn10","bottom","slideDownIn10","left","slideLeftIn10","right","slideRightIn10","BEAK_ORIGIN_POSITION","OFF_SCREEN_STYLE","opacity","filter","pointerEvents","ARIA_ROLE_ATTRIBUTES","DEFAULT_PROPS","preventDismissOnLostFocus","preventDismissOnScroll","preventDismissOnResize","isBeakVisible","beakWidth","gapSpace","minPagePadding","directionalHint","bottomAutoEdge","getClassNames","disableCaching","useBounds","targetRef","targetWindow","bounds","_b","target","useState","targetWindowResized","setTargetWindowResized","cachedBounds","useRef","getBounds","useCallback","current","currentBounds","undefined","width","height","async","debounce","leading","useMaxHeight","positions","calloutMaxHeight","finalHeight","directionalHintFixed","hidden","maxHeight","setMaxHeight","elementPosition","useEffect","topBounds","bottomBounds","usePositions","props","hostElement","calloutElement","setPositions","positionAttempts","previousTarget","onPositioned","timerId_1","requestAnimationFrame","currentProps","dupeCalloutElement","cloneNode","style","visibility","parentElement","appendChild","previousPositions","newPositions","removeChild","arePositionsEqual","cancelAnimationFrame","useAutoFocus","setInitialFocus","hasPositions","timerId_2","useDismissHandlers","onDismiss","dismissOnTargetClick","shouldDismissOnWindowFocus","preventDismissOnEvent","isMouseDownOnPopup","mouseDownHandlers","positionsExists","dismissOnScroll","ev","dismissOnClickOrScroll","dismissOnResize","dismissOnLostFocus","eventPaths","composedPath","length","isEventTargetOutsideCallout","dismissOnTargetWindowBlur","document","hasFocus","relatedTarget","disposablesPromise","Promise","setTimeout","disposables_1","documentElement","resolve","forEach","then","CalloutContentBase","memo","forwardRef","propsWithoutDefaults","forwardedRef","ariaLabel","ariaDescribedBy","ariaLabelledBy","className","children","calloutWidth","calloutMaxWidth","calloutMinWidth","doNotLayer","hideOverflow","backgroundColor","onScroll","shouldRestoreFocus","onLayerMounted","setCalloutElement","calloutCallback","calloutEl","rootRef","mouseDownOnPopup","mouseUpOnPopup","isForcedInBounds","cssPositions","overflowYHidden","beakVisible","classNames","styles","theme","overflowStyle","overflowY","visibilityStyle","ref","container","root","targetEdge","__assign","tabIndex","beak","getBeakPosition","beakCurtain","role","calloutMain","onMouseDown","onMouseUp","onRestoreFocus","previousProps","nextProps","shouldUpdateWhenHidden","beakPositionStyle","beakPosition","display","hideBeak","prevElementPositions","newElementPosition","comparePositions","newElementPositions","key","hasOwnProperty","oldPositionEdge","newPositionEdge","toFixed","displayName"],"sources":["/home/npr/Downloads/Final FrontEnd (2)/node_modules/@fluentui/react/lib/components/src/components/Callout/CalloutContent.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport {\n  css,\n  divProperties,\n  elementContains,\n  focusFirstChild,\n  getNativeProps,\n  on,\n  shallowCompare,\n  getPropsWithDefaults,\n  Async,\n} from '../../Utilities';\nimport { positionCallout, RectangleEdge, positionCard, getBoundsFromTargetWindow } from '../../Positioning';\nimport { Popup } from '../../Popup';\nimport { classNamesFunction } from '../../Utilities';\nimport { AnimationClassNames } from '../../Styling';\nimport { useMergedRefs, useAsync, useConst, useTarget, useOnEvent } from '@fluentui/react-hooks';\nimport type { ICalloutProps, ICalloutContentStyleProps, ICalloutContentStyles } from './Callout.types';\nimport type { Point, IRectangle } from '../../Utilities';\nimport type { ICalloutPositionedInfo, IPositionProps, IPosition } from '../../Positioning';\nimport type { Target } from '@fluentui/react-hooks';\n\nconst COMPONENT_NAME = 'CalloutContentBase';\n\nconst ANIMATIONS: { [key: number]: string | undefined } = {\n  [RectangleEdge.top]: AnimationClassNames.slideUpIn10,\n  [RectangleEdge.bottom]: AnimationClassNames.slideDownIn10,\n  [RectangleEdge.left]: AnimationClassNames.slideLeftIn10,\n  [RectangleEdge.right]: AnimationClassNames.slideRightIn10,\n};\n\nconst BEAK_ORIGIN_POSITION = { top: 0, left: 0 };\n// Microsoft Edge will overwrite inline styles if there is an animation pertaining to that style.\n// To help ensure that edge will respect the offscreen style opacity\n// filter needs to be added as an additional way to set opacity.\n// Also set pointer-events: none so that the callout will not occlude the element it is\n// going to be positioned against\nconst OFF_SCREEN_STYLE: React.CSSProperties = {\n  opacity: 0,\n  filter: 'opacity(0)',\n  pointerEvents: 'none',\n};\n// role and role description go hand-in-hand. Both would be included by spreading getNativeProps for a basic element\n// This constant array can be used to filter these out of native props spread on callout root and apply them together on\n// calloutMain (the Popup component within the callout)\nconst ARIA_ROLE_ATTRIBUTES = ['role', 'aria-roledescription'];\n\nconst DEFAULT_PROPS = {\n  preventDismissOnLostFocus: false,\n  preventDismissOnScroll: false,\n  preventDismissOnResize: false,\n  isBeakVisible: true,\n  beakWidth: 16,\n  gapSpace: 0,\n  minPagePadding: 8,\n  directionalHint: DirectionalHint.bottomAutoEdge,\n} as const;\n\nconst getClassNames = classNamesFunction<ICalloutContentStyleProps, ICalloutContentStyles>({\n  disableCaching: true, // disabling caching because stylesProp.position mutates often\n});\n\n/**\n * (Hook) to return a function to lazily fetch the bounds of the target element for the callout.\n */\nfunction useBounds(\n  { bounds, minPagePadding = DEFAULT_PROPS.minPagePadding, target }: ICalloutProps,\n  targetRef: React.RefObject<Element | MouseEvent | Point | null>,\n  targetWindow: Window | undefined,\n) {\n  const [targetWindowResized, setTargetWindowResized] = React.useState(false);\n  const cachedBounds = React.useRef<IRectangle | undefined>();\n\n  const getBounds = React.useCallback((): IRectangle | undefined => {\n    if (!cachedBounds.current || targetWindowResized) {\n      let currentBounds =\n        typeof bounds === 'function' ? (targetWindow ? bounds(target, targetWindow) : undefined) : bounds;\n\n      if (!currentBounds && targetWindow) {\n        currentBounds = getBoundsFromTargetWindow(targetRef.current, targetWindow);\n        currentBounds = {\n          top: currentBounds.top + minPagePadding,\n          left: currentBounds.left + minPagePadding,\n          right: currentBounds.right! - minPagePadding,\n          bottom: currentBounds.bottom! - minPagePadding,\n          width: currentBounds.width - minPagePadding * 2,\n          height: currentBounds.height - minPagePadding * 2,\n        };\n      }\n      cachedBounds.current = currentBounds;\n      targetWindowResized && setTargetWindowResized(false);\n    }\n\n    return cachedBounds.current;\n  }, [bounds, minPagePadding, target, targetRef, targetWindow, targetWindowResized]);\n\n  const async: Async = useAsync();\n  useOnEvent(\n    targetWindow,\n    'resize',\n    async.debounce(\n      () => {\n        setTargetWindowResized(true);\n      },\n      500,\n      { leading: true },\n    ),\n  );\n\n  return getBounds;\n}\n\n/**\n * (Hook) to return the maximum available height for the Callout to render into.\n */\nfunction useMaxHeight(\n  { calloutMaxHeight, finalHeight, directionalHint, directionalHintFixed, hidden }: ICalloutProps,\n  getBounds: () => IRectangle | undefined,\n  positions?: ICalloutPositionedInfo,\n) {\n  const [maxHeight, setMaxHeight] = React.useState<number | undefined>();\n  const { top, bottom } = positions?.elementPosition ?? {};\n\n  React.useEffect(() => {\n    const { top: topBounds, bottom: bottomBounds } = getBounds() ?? {};\n\n    if (!calloutMaxHeight && !hidden) {\n      if (typeof top === 'number' && bottomBounds) {\n        setMaxHeight(bottomBounds - top);\n      } else if (typeof bottom === 'number' && typeof topBounds === 'number' && bottomBounds) {\n        setMaxHeight(bottomBounds - topBounds - bottom);\n      }\n    } else if (calloutMaxHeight) {\n      setMaxHeight(calloutMaxHeight);\n    } else {\n      setMaxHeight(undefined);\n    }\n  }, [bottom, calloutMaxHeight, finalHeight, directionalHint, directionalHintFixed, getBounds, hidden, positions, top]);\n\n  return maxHeight;\n}\n\n/**\n * (Hook) to find the current position of Callout. If Callout is resized then a new position is calculated.\n */\nfunction usePositions(\n  props: ICalloutProps,\n  hostElement: React.RefObject<HTMLDivElement>,\n  calloutElement: HTMLDivElement | null,\n  targetRef: React.RefObject<Element | MouseEvent | Point | null>,\n  getBounds: () => IRectangle | undefined,\n) {\n  const [positions, setPositions] = React.useState<ICalloutPositionedInfo>();\n  const positionAttempts = React.useRef(0);\n  const previousTarget = React.useRef<Target>();\n  const async = useAsync();\n  const { hidden, target, finalHeight, calloutMaxHeight, onPositioned, directionalHint } = props;\n\n  React.useEffect(() => {\n    if (!hidden) {\n      const timerId = async.requestAnimationFrame(() => {\n        if (hostElement.current && calloutElement) {\n          const currentProps: IPositionProps = {\n            ...props,\n            target: targetRef.current!,\n            bounds: getBounds(),\n          };\n\n          // duplicate calloutElement & remove useMaxHeight's maxHeight for position calc\n          const dupeCalloutElement = calloutElement.cloneNode(true) as HTMLElement;\n          dupeCalloutElement.style.maxHeight = calloutMaxHeight ? `${calloutMaxHeight}` : '';\n          dupeCalloutElement.style.visibility = 'hidden';\n          calloutElement.parentElement?.appendChild(dupeCalloutElement);\n\n          const previousPositions = previousTarget.current === target ? positions : undefined;\n\n          // If there is a finalHeight given then we assume that the user knows and will handle\n          // additional positioning adjustments so we should call positionCard\n          const newPositions: ICalloutPositionedInfo = finalHeight\n            ? positionCard(currentProps, hostElement.current, dupeCalloutElement, previousPositions)\n            : positionCallout(currentProps, hostElement.current, dupeCalloutElement, previousPositions);\n\n          // clean up duplicate calloutElement\n          calloutElement.parentElement?.removeChild(dupeCalloutElement);\n\n          // Set the new position only when the positions do not exist or one of the new callout positions\n          // is different. The position should not change if the position is within 2 decimal places.\n          if (\n            (!positions && newPositions) ||\n            (positions && newPositions && !arePositionsEqual(positions, newPositions) && positionAttempts.current < 5)\n          ) {\n            // We should not reposition the callout more than a few times, if it is then the content is likely resizing\n            // and we should stop trying to reposition to prevent a stack overflow.\n            positionAttempts.current++;\n            setPositions(newPositions);\n          } else if (positionAttempts.current > 0) {\n            // Only call the onPositioned callback if the callout has been re-positioned at least once.\n            positionAttempts.current = 0;\n            onPositioned?.(positions);\n          }\n        }\n      }, calloutElement);\n\n      previousTarget.current = target;\n\n      return () => {\n        async.cancelAnimationFrame(timerId);\n        previousTarget.current = undefined;\n      };\n    } else {\n      // When the callout is hidden, clear position state so that it is not accidentally used next render.\n      setPositions(undefined);\n      positionAttempts.current = 0;\n    }\n  }, [\n    hidden,\n    directionalHint,\n    async,\n    calloutElement,\n    calloutMaxHeight,\n    hostElement,\n    targetRef,\n    finalHeight,\n    getBounds,\n    onPositioned,\n    positions,\n    props,\n    target,\n  ]);\n\n  return positions;\n}\n\n/**\n * (Hook) to set up behavior to automatically focus the callout when it appears, if indicated by props.\n */\nfunction useAutoFocus(\n  { hidden, setInitialFocus }: ICalloutProps,\n  positions: ICalloutPositionedInfo | undefined,\n  calloutElement: HTMLDivElement | null,\n) {\n  const async = useAsync();\n  const hasPositions = !!positions;\n  React.useEffect(() => {\n    if (!hidden && setInitialFocus && hasPositions && calloutElement) {\n      const timerId = async.requestAnimationFrame(() => focusFirstChild(calloutElement), calloutElement);\n\n      return () => async.cancelAnimationFrame(timerId);\n    }\n  }, [hidden, hasPositions, async, calloutElement, setInitialFocus]);\n}\n\n/**\n * (Hook) to set up various handlers to dismiss the popup when it loses focus or the window scrolls or similar cases.\n */\nfunction useDismissHandlers(\n  {\n    hidden,\n    onDismiss,\n    // eslint-disable-next-line deprecation/deprecation\n    preventDismissOnScroll,\n    // eslint-disable-next-line deprecation/deprecation\n    preventDismissOnResize,\n    // eslint-disable-next-line deprecation/deprecation\n    preventDismissOnLostFocus,\n    dismissOnTargetClick,\n    shouldDismissOnWindowFocus,\n    preventDismissOnEvent,\n  }: ICalloutProps,\n  positions: ICalloutPositionedInfo | undefined,\n  hostElement: React.RefObject<HTMLDivElement>,\n  targetRef: React.RefObject<Element | MouseEvent | Point | null>,\n  targetWindow: Window | undefined,\n) {\n  const isMouseDownOnPopup = React.useRef(false);\n  const async = useAsync();\n\n  const mouseDownHandlers = useConst([\n    () => {\n      isMouseDownOnPopup.current = true;\n    },\n    () => {\n      isMouseDownOnPopup.current = false;\n    },\n  ] as const);\n\n  const positionsExists = !!positions;\n\n  React.useEffect(() => {\n    const dismissOnScroll = (ev: Event) => {\n      if (positionsExists && !preventDismissOnScroll) {\n        dismissOnClickOrScroll(ev);\n      }\n    };\n\n    const dismissOnResize = (ev: Event) => {\n      if (!preventDismissOnResize && !(preventDismissOnEvent && preventDismissOnEvent(ev))) {\n        onDismiss?.(ev);\n      }\n    };\n\n    const dismissOnLostFocus = (ev: Event) => {\n      if (!preventDismissOnLostFocus) {\n        dismissOnClickOrScroll(ev);\n      }\n    };\n\n    const dismissOnClickOrScroll = (ev: Event) => {\n      const eventPaths: Array<EventTarget> = ev.composedPath ? ev.composedPath() : [];\n      const target = eventPaths.length > 0 ? (eventPaths[0] as HTMLElement) : (ev.target as HTMLElement);\n      const isEventTargetOutsideCallout = hostElement.current && !elementContains(hostElement.current, target);\n\n      // If mouse is pressed down on callout but moved outside then released, don't dismiss the callout.\n      if (isEventTargetOutsideCallout && isMouseDownOnPopup.current) {\n        isMouseDownOnPopup.current = false;\n        return;\n      }\n\n      if (\n        (!targetRef.current && isEventTargetOutsideCallout) ||\n        (ev.target !== targetWindow &&\n          isEventTargetOutsideCallout &&\n          (!targetRef.current ||\n            'stopPropagation' in targetRef.current ||\n            dismissOnTargetClick ||\n            (target !== targetRef.current && !elementContains(targetRef.current as HTMLElement, target))))\n      ) {\n        if (preventDismissOnEvent && preventDismissOnEvent(ev)) {\n          return;\n        }\n        onDismiss?.(ev);\n      }\n    };\n\n    const dismissOnTargetWindowBlur = (ev: FocusEvent) => {\n      // Do nothing\n      if (!shouldDismissOnWindowFocus) {\n        return;\n      }\n\n      if (\n        ((preventDismissOnEvent && !preventDismissOnEvent(ev)) ||\n          (!preventDismissOnEvent && !preventDismissOnLostFocus)) &&\n        !targetWindow?.document.hasFocus() &&\n        ev.relatedTarget === null\n      ) {\n        onDismiss?.(ev);\n      }\n    };\n\n    // This is added so the callout will dismiss when the window is scrolled\n    // but not when something inside the callout is scrolled. The delay seems\n    // to be required to avoid React firing an async focus event in IE from\n    // the target changing focus quickly prior to rendering the callout.\n    const disposablesPromise = new Promise<() => void>(resolve => {\n      async.setTimeout(() => {\n        if (!hidden && targetWindow) {\n          const disposables = [\n            on(targetWindow, 'scroll', dismissOnScroll, true),\n            on(targetWindow, 'resize', dismissOnResize, true),\n            on(targetWindow.document.documentElement, 'focus', dismissOnLostFocus, true),\n            on(targetWindow.document.documentElement, 'click', dismissOnLostFocus, true),\n            on(targetWindow, 'blur', dismissOnTargetWindowBlur, true),\n          ];\n\n          resolve(() => {\n            disposables.forEach(dispose => dispose());\n          });\n        }\n      }, 0);\n    });\n\n    return () => {\n      disposablesPromise.then(dispose => dispose());\n    };\n  }, [\n    hidden,\n    async,\n    hostElement,\n    targetRef,\n    targetWindow,\n    onDismiss,\n    shouldDismissOnWindowFocus,\n    dismissOnTargetClick,\n    preventDismissOnLostFocus,\n    preventDismissOnResize,\n    preventDismissOnScroll,\n    positionsExists,\n    preventDismissOnEvent,\n  ]);\n\n  return mouseDownHandlers;\n}\n\nexport const CalloutContentBase: React.FunctionComponent<ICalloutProps> = React.memo(\n  React.forwardRef<HTMLDivElement, ICalloutProps>((propsWithoutDefaults, forwardedRef) => {\n    const props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n\n    const {\n      styles,\n      style,\n      ariaLabel,\n      ariaDescribedBy,\n      ariaLabelledBy,\n      className,\n      isBeakVisible,\n      children,\n      beakWidth,\n      calloutWidth,\n      calloutMaxWidth,\n      calloutMinWidth,\n      doNotLayer,\n      finalHeight,\n      hideOverflow = !!finalHeight,\n      backgroundColor,\n      calloutMaxHeight,\n      onScroll,\n      // eslint-disable-next-line deprecation/deprecation\n      shouldRestoreFocus = true,\n      target,\n      hidden,\n      onLayerMounted,\n    } = props;\n\n    const hostElement = React.useRef<HTMLDivElement>(null);\n    const [calloutElement, setCalloutElement] = React.useState<HTMLDivElement | null>(null);\n    const calloutCallback = React.useCallback(calloutEl => {\n      setCalloutElement(calloutEl);\n    }, []);\n    const rootRef = useMergedRefs(hostElement, forwardedRef);\n\n    const [targetRef, targetWindow] = useTarget(props.target, {\n      current: calloutElement,\n    });\n    const getBounds = useBounds(props, targetRef, targetWindow);\n    const positions = usePositions(props, hostElement, calloutElement, targetRef, getBounds);\n    const maxHeight = useMaxHeight(props, getBounds, positions);\n    const [mouseDownOnPopup, mouseUpOnPopup] = useDismissHandlers(\n      props,\n      positions,\n      hostElement,\n      targetRef,\n      targetWindow,\n    );\n\n    // do not set both top and bottom css props from positions\n    // instead, use maxHeight\n    const isForcedInBounds = positions?.elementPosition.top && positions?.elementPosition.bottom;\n    const cssPositions = {\n      ...positions?.elementPosition,\n      maxHeight,\n    };\n    if (isForcedInBounds) {\n      cssPositions.bottom = undefined;\n    }\n\n    useAutoFocus(props, positions, calloutElement);\n\n    React.useEffect(() => {\n      if (!hidden) {\n        onLayerMounted?.();\n      }\n      // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run if hidden changes\n    }, [hidden]);\n\n    // If there is no target window then we are likely in server side rendering and we should not render anything.\n    if (!targetWindow) {\n      return null;\n    }\n\n    const overflowYHidden = hideOverflow;\n\n    const beakVisible = isBeakVisible && !!target;\n    const classNames = getClassNames(styles!, {\n      theme: props.theme!,\n      className,\n      overflowYHidden: overflowYHidden,\n      calloutWidth,\n      positions,\n      beakWidth,\n      backgroundColor,\n      calloutMaxWidth,\n      calloutMinWidth,\n      doNotLayer,\n    });\n\n    const overflowStyle: React.CSSProperties = {\n      maxHeight: calloutMaxHeight ? calloutMaxHeight : '100%',\n      ...style,\n      ...(overflowYHidden && { overflowY: 'hidden' }),\n    };\n\n    const visibilityStyle: React.CSSProperties | undefined = props.hidden ? { visibility: 'hidden' } : undefined;\n    // React.CSSProperties does not understand IRawStyle, so the inline animations will need to be cast as any for now.\n    return (\n      <div ref={rootRef} className={classNames.container} style={visibilityStyle}>\n        <div\n          {...getNativeProps(props, divProperties, ARIA_ROLE_ATTRIBUTES)}\n          className={css(classNames.root, positions && positions.targetEdge && ANIMATIONS[positions.targetEdge!])}\n          style={positions ? { ...cssPositions } : OFF_SCREEN_STYLE}\n          // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.\n          // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus\n          tabIndex={-1}\n          ref={calloutCallback}\n        >\n          {beakVisible && <div className={classNames.beak} style={getBeakPosition(positions)} />}\n          {beakVisible && <div className={classNames.beakCurtain} />}\n          <Popup\n            // don't use getNativeElementProps for role and roledescription because it will also\n            // pass through data-* props (resulting in them being used in two places)\n            role={props.role}\n            aria-roledescription={props['aria-roledescription']}\n            ariaDescribedBy={ariaDescribedBy}\n            ariaLabel={ariaLabel}\n            ariaLabelledBy={ariaLabelledBy}\n            className={classNames.calloutMain}\n            onDismiss={props.onDismiss}\n            onMouseDown={mouseDownOnPopup}\n            onMouseUp={mouseUpOnPopup}\n            onRestoreFocus={props.onRestoreFocus}\n            onScroll={onScroll}\n            shouldRestoreFocus={shouldRestoreFocus}\n            style={overflowStyle}\n          >\n            {children}\n          </Popup>\n        </div>\n      </div>\n    );\n  }),\n  (previousProps: ICalloutProps, nextProps: ICalloutProps) => {\n    if (!nextProps.shouldUpdateWhenHidden && previousProps.hidden && nextProps.hidden) {\n      // Do not update when hidden.\n      return true;\n    }\n    return shallowCompare(previousProps, nextProps);\n  },\n);\n\n/**\n * (Utility) to find and return the current `Callout` Beak position.\n *\n * @param positions\n */\nfunction getBeakPosition(positions?: ICalloutPositionedInfo): React.CSSProperties {\n  const beakPositionStyle: React.CSSProperties = {\n    ...positions?.beakPosition?.elementPosition,\n    display: positions?.beakPosition?.hideBeak ? 'none' : undefined,\n  };\n\n  if (!beakPositionStyle.top && !beakPositionStyle.bottom && !beakPositionStyle.left && !beakPositionStyle.right) {\n    beakPositionStyle.left = BEAK_ORIGIN_POSITION.left;\n    beakPositionStyle.top = BEAK_ORIGIN_POSITION.top;\n  }\n\n  return beakPositionStyle;\n}\n\n/**\n * (Utility) used to compare two different elementPositions to determine whether they are equal.\n *\n * @param prevElementPositions\n * @param newElementPosition\n */\nfunction arePositionsEqual(\n  prevElementPositions: ICalloutPositionedInfo,\n  newElementPosition: ICalloutPositionedInfo,\n): boolean {\n  return (\n    comparePositions(prevElementPositions.elementPosition, newElementPosition.elementPosition) &&\n    comparePositions(prevElementPositions.beakPosition.elementPosition, newElementPosition.beakPosition.elementPosition)\n  );\n}\n\n/**\n * (Utility) used in **arePositionsEqual** to compare two different elementPositions.\n *\n * @param prevElementPositions\n * @param newElementPositions\n */\nfunction comparePositions(prevElementPositions: IPosition, newElementPositions: IPosition): boolean {\n  for (const key in newElementPositions) {\n    if (newElementPositions.hasOwnProperty(key)) {\n      const oldPositionEdge = prevElementPositions[key];\n      const newPositionEdge = newElementPositions[key];\n      if (oldPositionEdge !== undefined && newPositionEdge !== undefined) {\n        if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nCalloutContentBase.displayName = COMPONENT_NAME;\n"]},"metadata":{},"sourceType":"module"}