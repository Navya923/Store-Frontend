{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { elementContains, getNativeProps, divProperties, getFirstTabbable, getLastTabbable, getNextElement, focusAsync, modalize, on } from '../../Utilities';\nimport { useId, useConst, useMergedRefs, useUnmount } from '@fluentui/react-hooks';\nimport { useDocument } from '../../WindowProvider';\nvar COMPONENT_NAME = 'FocusTrapZone';\n\nvar useComponentRef = function (componentRef, previouslyFocusedElement, focus) {\n  React.useImperativeHandle(componentRef, function () {\n    return {\n      get previouslyFocusedElement() {\n        return previouslyFocusedElement;\n      },\n\n      focus: focus\n    };\n  }, [previouslyFocusedElement, focus]);\n};\n\nexport var FocusTrapZone = React.forwardRef(function (props, ref) {\n  var root = React.useRef(null);\n  var firstBumper = React.useRef(null);\n  var lastBumper = React.useRef(null);\n  var mergedRootRef = useMergedRefs(root, ref);\n  var id = useId(undefined, props.id);\n  var doc = useDocument();\n  var divProps = getNativeProps(props, divProperties);\n  var internalState = useConst(function () {\n    return {\n      previouslyFocusedElementOutsideTrapZone: undefined,\n      previouslyFocusedElementInTrapZone: undefined,\n      disposeFocusHandler: undefined,\n      disposeClickHandler: undefined,\n      hasFocus: false,\n      unmodalize: undefined\n    };\n  });\n  var ariaLabelledBy = props.ariaLabelledBy,\n      className = props.className,\n      children = props.children,\n      componentRef = props.componentRef,\n      disabled = props.disabled,\n      _a = props.disableFirstFocus,\n      disableFirstFocus = _a === void 0 ? false : _a,\n      _b = props.disabled,\n      currentDisabledValue = _b === void 0 ? false : _b,\n      elementToFocusOnDismiss = props.elementToFocusOnDismiss,\n      _c = props.forceFocusInsideTrap,\n      forceFocusInsideTrap = _c === void 0 ? true : _c,\n      focusPreviouslyFocusedInnerElement = props.focusPreviouslyFocusedInnerElement,\n      // eslint-disable-next-line deprecation/deprecation\n  firstFocusableSelector = props.firstFocusableSelector,\n      firstFocusableTarget = props.firstFocusableTarget,\n      ignoreExternalFocusing = props.ignoreExternalFocusing,\n      _d = props.isClickableOutsideFocusTrap,\n      isClickableOutsideFocusTrap = _d === void 0 ? false : _d,\n      onFocus = props.onFocus,\n      onBlur = props.onBlur,\n      onFocusCapture = props.onFocusCapture,\n      onBlurCapture = props.onBlurCapture,\n      enableAriaHiddenSiblings = props.enableAriaHiddenSiblings;\n  var bumperProps = {\n    'aria-hidden': true,\n    style: {\n      pointerEvents: 'none',\n      position: 'fixed' // 'fixed' prevents browsers from scrolling to bumpers when viewport does not contain them\n\n    },\n    tabIndex: disabled ? -1 : 0,\n    'data-is-visible': true,\n    'data-is-focus-trap-zone-bumper': true\n  };\n  var focus = React.useCallback(function () {\n    if (focusPreviouslyFocusedInnerElement && internalState.previouslyFocusedElementInTrapZone && elementContains(root.current, internalState.previouslyFocusedElementInTrapZone)) {\n      // focus on the last item that had focus in the zone before we left the zone\n      focusAsync(internalState.previouslyFocusedElementInTrapZone);\n      return;\n    }\n\n    var focusSelector = typeof firstFocusableSelector === 'string' ? firstFocusableSelector : firstFocusableSelector && firstFocusableSelector();\n    var firstFocusableChild = null;\n\n    if (root.current) {\n      if (typeof firstFocusableTarget === 'string') {\n        firstFocusableChild = root.current.querySelector(firstFocusableTarget);\n      } else if (firstFocusableTarget) {\n        firstFocusableChild = firstFocusableTarget(root.current);\n      } else if (focusSelector) {\n        firstFocusableChild = root.current.querySelector('.' + focusSelector);\n      } // Fall back to first element if query selector did not match any elements.\n\n\n      if (!firstFocusableChild) {\n        firstFocusableChild = getNextElement(root.current, root.current.firstChild, false, false, false, true);\n      }\n    }\n\n    if (firstFocusableChild) {\n      focusAsync(firstFocusableChild);\n    }\n  }, [firstFocusableSelector, firstFocusableTarget, focusPreviouslyFocusedInnerElement, internalState]);\n  var onBumperFocus = React.useCallback(function (isFirstBumper) {\n    if (disabled) {\n      return;\n    }\n\n    var currentBumper = isFirstBumper === internalState.hasFocus ? lastBumper.current : firstBumper.current;\n\n    if (root.current) {\n      var nextFocusable = isFirstBumper === internalState.hasFocus ? getLastTabbable(root.current, currentBumper, true, false) : getFirstTabbable(root.current, currentBumper, true, false);\n\n      if (nextFocusable) {\n        if (nextFocusable === firstBumper.current || nextFocusable === lastBumper.current) {\n          // This can happen when FTZ contains no tabbable elements.\n          // focus will take care of finding a focusable element in FTZ.\n          focus();\n        } else {\n          nextFocusable.focus();\n        }\n      }\n    }\n  }, [disabled, focus, internalState]);\n  var onRootBlurCapture = React.useCallback(function (ev) {\n    onBlurCapture === null || onBlurCapture === void 0 ? void 0 : onBlurCapture(ev);\n    var relatedTarget = ev.relatedTarget;\n\n    if (ev.relatedTarget === null) {\n      // In IE11, due to lack of support, event.relatedTarget is always\n      // null making every onBlur call to be \"outside\" of the root\n      // even when it's not. Using document.activeElement is another way\n      // for us to be able to get what the relatedTarget without relying\n      // on the event\n      relatedTarget = doc.activeElement;\n    }\n\n    if (!elementContains(root.current, relatedTarget)) {\n      internalState.hasFocus = false;\n    }\n  }, [doc, internalState, onBlurCapture]);\n  var onRootFocusCapture = React.useCallback(function (ev) {\n    onFocusCapture === null || onFocusCapture === void 0 ? void 0 : onFocusCapture(ev);\n\n    if (ev.target === firstBumper.current) {\n      onBumperFocus(true);\n    } else if (ev.target === lastBumper.current) {\n      onBumperFocus(false);\n    }\n\n    internalState.hasFocus = true;\n\n    if (ev.target !== ev.currentTarget && !(ev.target === firstBumper.current || ev.target === lastBumper.current)) {\n      // every time focus changes within the trap zone, remember the focused element so that\n      // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))\n      internalState.previouslyFocusedElementInTrapZone = ev.target;\n    }\n  }, [onFocusCapture, internalState, onBumperFocus]);\n  var returnFocusToInitiator = React.useCallback(function () {\n    FocusTrapZone.focusStack = FocusTrapZone.focusStack.filter(function (value) {\n      return id !== value;\n    });\n\n    if (doc) {\n      var activeElement = doc.activeElement;\n\n      if (!ignoreExternalFocusing && internalState.previouslyFocusedElementOutsideTrapZone && typeof internalState.previouslyFocusedElementOutsideTrapZone.focus === 'function' && (elementContains(root.current, activeElement) || activeElement === doc.body)) {\n        if (!(internalState.previouslyFocusedElementOutsideTrapZone === firstBumper.current || internalState.previouslyFocusedElementOutsideTrapZone === lastBumper.current)) {\n          focusAsync(internalState.previouslyFocusedElementOutsideTrapZone);\n        }\n      }\n    }\n  }, [doc, id, ignoreExternalFocusing, internalState]);\n  var forceFocusInTrap = React.useCallback(function (ev) {\n    if (disabled) {\n      return;\n    }\n\n    if (FocusTrapZone.focusStack.length && id === FocusTrapZone.focusStack[FocusTrapZone.focusStack.length - 1]) {\n      var focusedElement = ev.target;\n\n      if (!elementContains(root.current, focusedElement)) {\n        focus();\n        internalState.hasFocus = true; // set focus here since we stop event propagation\n\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  }, [disabled, id, focus, internalState]);\n  var forceClickInTrap = React.useCallback(function (ev) {\n    if (disabled) {\n      return;\n    }\n\n    if (FocusTrapZone.focusStack.length && id === FocusTrapZone.focusStack[FocusTrapZone.focusStack.length - 1]) {\n      var clickedElement = ev.target;\n\n      if (clickedElement && !elementContains(root.current, clickedElement)) {\n        focus();\n        internalState.hasFocus = true; // set focus here since we stop event propagation\n\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  }, [disabled, id, focus, internalState]);\n  var updateEventHandlers = React.useCallback(function () {\n    if (forceFocusInsideTrap && !internalState.disposeFocusHandler) {\n      internalState.disposeFocusHandler = on(window, 'focus', forceFocusInTrap, true);\n    } else if (!forceFocusInsideTrap && internalState.disposeFocusHandler) {\n      internalState.disposeFocusHandler();\n      internalState.disposeFocusHandler = undefined;\n    }\n\n    if (!isClickableOutsideFocusTrap && !internalState.disposeClickHandler) {\n      internalState.disposeClickHandler = on(window, 'click', forceClickInTrap, true);\n    } else if (isClickableOutsideFocusTrap && internalState.disposeClickHandler) {\n      internalState.disposeClickHandler();\n      internalState.disposeClickHandler = undefined;\n    }\n  }, [forceClickInTrap, forceFocusInTrap, forceFocusInsideTrap, isClickableOutsideFocusTrap, internalState]); // Updates eventHandlers and cleans up focusStack when the component unmounts.\n\n  React.useEffect(function () {\n    var parentRoot = root.current;\n    updateEventHandlers();\n    return function () {\n      // don't handle return focus unless forceFocusInsideTrap is true or focus is still within FocusTrapZone\n      if (!disabled || forceFocusInsideTrap || !elementContains(parentRoot, doc === null || doc === void 0 ? void 0 : doc.activeElement)) {\n        returnFocusToInitiator();\n      }\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps -- Should only run on mount.\n  }, [updateEventHandlers]); // Updates focusStack and the previouslyFocusedElementOutsideTrapZone on prop change.\n\n  React.useEffect(function () {\n    var newForceFocusInsideTrap = forceFocusInsideTrap !== undefined ? forceFocusInsideTrap : true;\n    var newDisabled = disabled !== undefined ? disabled : false; // Transition from forceFocusInsideTrap / FTZ disabled to enabled.\n\n    if (!newDisabled || newForceFocusInsideTrap) {\n      if (currentDisabledValue) {\n        return;\n      }\n\n      FocusTrapZone.focusStack.push(id);\n      internalState.previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss ? elementToFocusOnDismiss : doc.activeElement;\n\n      if (!disableFirstFocus && !elementContains(root.current, internalState.previouslyFocusedElementOutsideTrapZone)) {\n        focus();\n      }\n\n      if (!internalState.unmodalize && root.current && enableAriaHiddenSiblings) {\n        internalState.unmodalize = modalize(root.current);\n      }\n    } else if (!newForceFocusInsideTrap || newDisabled) {\n      // Transition from forceFocusInsideTrap / FTZ enabled to disabled.\n      returnFocusToInitiator();\n\n      if (internalState.unmodalize) {\n        internalState.unmodalize();\n      }\n    }\n\n    if (elementToFocusOnDismiss && internalState.previouslyFocusedElementOutsideTrapZone !== elementToFocusOnDismiss) {\n      internalState.previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss;\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [elementToFocusOnDismiss, forceFocusInsideTrap, disabled]); // Cleanup lifecyle method for internalState.\n\n  useUnmount(function () {\n    // Dispose of event handlers so their closures can be garbage-collected\n    if (internalState.disposeClickHandler) {\n      internalState.disposeClickHandler();\n      internalState.disposeClickHandler = undefined;\n    }\n\n    if (internalState.disposeFocusHandler) {\n      internalState.disposeFocusHandler();\n      internalState.disposeFocusHandler = undefined;\n    }\n\n    if (internalState.unmodalize) {\n      internalState.unmodalize();\n    } // Dispose of element references so the DOM Nodes can be garbage-collected\n\n\n    delete internalState.previouslyFocusedElementInTrapZone;\n    delete internalState.previouslyFocusedElementOutsideTrapZone;\n  });\n  useComponentRef(componentRef, internalState.previouslyFocusedElementInTrapZone, focus);\n  return React.createElement(\"div\", __assign({}, divProps, {\n    className: className,\n    ref: mergedRootRef,\n    \"aria-labelledby\": ariaLabelledBy,\n    onFocusCapture: onRootFocusCapture,\n    onFocus: onFocus,\n    onBlur: onBlur,\n    onBlurCapture: onRootBlurCapture\n  }), React.createElement(\"div\", __assign({}, bumperProps, {\n    ref: firstBumper\n  })), children, React.createElement(\"div\", __assign({}, bumperProps, {\n    ref: lastBumper\n  })));\n});\nFocusTrapZone.displayName = COMPONENT_NAME;\nFocusTrapZone.focusStack = [];","map":{"version":3,"mappings":"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","names":["React","elementContains","getNativeProps","divProperties","getFirstTabbable","getLastTabbable","getNextElement","focusAsync","modalize","on","useId","useConst","useMergedRefs","useUnmount","useDocument","COMPONENT_NAME","useComponentRef","componentRef","previouslyFocusedElement","focus","useImperativeHandle","FocusTrapZone","forwardRef","props","ref","root","useRef","firstBumper","lastBumper","mergedRootRef","id","undefined","doc","divProps","internalState","previouslyFocusedElementOutsideTrapZone","previouslyFocusedElementInTrapZone","disposeFocusHandler","disposeClickHandler","hasFocus","unmodalize","className","children","disabled","_a","disableFirstFocus","_b","currentDisabledValue","elementToFocusOnDismiss","_c","forceFocusInsideTrap","focusPreviouslyFocusedInnerElement","firstFocusableSelector","firstFocusableTarget","ignoreExternalFocusing","_d","isClickableOutsideFocusTrap","onFocus","onBlur","onFocusCapture","onBlurCapture","enableAriaHiddenSiblings","bumperProps","style","pointerEvents","position","tabIndex","useCallback","current","focusSelector","firstFocusableChild","querySelector","firstChild","onBumperFocus","isFirstBumper","currentBumper","nextFocusable","onRootBlurCapture","ev","relatedTarget","activeElement","onRootFocusCapture","target","currentTarget","returnFocusToInitiator","focusStack","filter","value","body","forceFocusInTrap","length","focusedElement","preventDefault","stopPropagation","forceClickInTrap","clickedElement","updateEventHandlers","window","useEffect","parentRoot","newForceFocusInsideTrap","newDisabled","push","ariaLabelledBy","displayName"],"sources":["/home/npr/Downloads/Final FrontEnd (2)/node_modules/@fluentui/react/lib/components/src/components/FocusTrapZone/FocusTrapZone.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  elementContains,\n  getNativeProps,\n  divProperties,\n  getFirstTabbable,\n  getLastTabbable,\n  getNextElement,\n  focusAsync,\n  modalize,\n  on,\n} from '../../Utilities';\nimport { useId, useConst, useMergedRefs, useUnmount } from '@fluentui/react-hooks';\nimport { useDocument } from '../../WindowProvider';\nimport type { IRefObject } from '../../Utilities';\nimport type { IFocusTrapZoneProps, IFocusTrapZone } from './FocusTrapZone.types';\n\ninterface IFocusTrapZoneInternalState {\n  disposeFocusHandler: (() => void) | undefined;\n  disposeClickHandler: (() => void) | undefined;\n  previouslyFocusedElementOutsideTrapZone: HTMLElement | undefined;\n  previouslyFocusedElementInTrapZone: HTMLElement | undefined;\n  hasFocus: boolean;\n  unmodalize: (() => void) | undefined;\n}\n\nconst COMPONENT_NAME = 'FocusTrapZone';\n\nconst useComponentRef = (\n  componentRef: IRefObject<IFocusTrapZone> | undefined,\n  previouslyFocusedElement: HTMLElement | undefined,\n  focus: () => void,\n) => {\n  React.useImperativeHandle(\n    componentRef,\n    () => ({\n      get previouslyFocusedElement() {\n        return previouslyFocusedElement;\n      },\n      focus,\n    }),\n    [previouslyFocusedElement, focus],\n  );\n};\n\nexport const FocusTrapZone: React.FunctionComponent<IFocusTrapZoneProps> & {\n  focusStack: string[];\n} = React.forwardRef<HTMLElement, IFocusTrapZoneProps>((props, ref) => {\n  const root = React.useRef<HTMLDivElement>(null);\n  const firstBumper = React.useRef<HTMLDivElement>(null);\n  const lastBumper = React.useRef<HTMLDivElement>(null);\n  const mergedRootRef = useMergedRefs(root, ref) as React.Ref<HTMLDivElement>;\n  const id = useId(undefined, props.id);\n  const doc = useDocument();\n  const divProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(props, divProperties);\n\n  const internalState = useConst<IFocusTrapZoneInternalState>(() => ({\n    previouslyFocusedElementOutsideTrapZone: undefined,\n    previouslyFocusedElementInTrapZone: undefined,\n    disposeFocusHandler: undefined,\n    disposeClickHandler: undefined,\n    hasFocus: false,\n    unmodalize: undefined,\n  }));\n\n  const {\n    ariaLabelledBy,\n    className,\n    children,\n    componentRef,\n    disabled,\n    disableFirstFocus = false,\n    disabled: currentDisabledValue = false,\n    elementToFocusOnDismiss,\n    forceFocusInsideTrap = true,\n    focusPreviouslyFocusedInnerElement,\n    // eslint-disable-next-line deprecation/deprecation\n    firstFocusableSelector,\n    firstFocusableTarget,\n    ignoreExternalFocusing,\n    isClickableOutsideFocusTrap = false,\n    onFocus,\n    onBlur,\n    onFocusCapture,\n    onBlurCapture,\n    enableAriaHiddenSiblings,\n  } = props;\n\n  const bumperProps = {\n    'aria-hidden': true,\n    style: {\n      pointerEvents: 'none',\n      position: 'fixed', // 'fixed' prevents browsers from scrolling to bumpers when viewport does not contain them\n    },\n    tabIndex: disabled ? -1 : 0, // make bumpers tabbable only when enabled\n    'data-is-visible': true,\n    'data-is-focus-trap-zone-bumper': true,\n  } as React.HTMLAttributes<HTMLDivElement>;\n\n  const focus = React.useCallback(() => {\n    if (\n      focusPreviouslyFocusedInnerElement &&\n      internalState.previouslyFocusedElementInTrapZone &&\n      elementContains(root.current, internalState.previouslyFocusedElementInTrapZone)\n    ) {\n      // focus on the last item that had focus in the zone before we left the zone\n      focusAsync(internalState.previouslyFocusedElementInTrapZone);\n      return;\n    }\n\n    const focusSelector =\n      typeof firstFocusableSelector === 'string'\n        ? firstFocusableSelector\n        : firstFocusableSelector && firstFocusableSelector();\n\n    let firstFocusableChild: HTMLElement | null = null;\n\n    if (root.current) {\n      if (typeof firstFocusableTarget === 'string') {\n        firstFocusableChild = root.current.querySelector(firstFocusableTarget);\n      } else if (firstFocusableTarget) {\n        firstFocusableChild = firstFocusableTarget(root.current);\n      } else if (focusSelector) {\n        firstFocusableChild = root.current.querySelector('.' + focusSelector);\n      }\n\n      // Fall back to first element if query selector did not match any elements.\n      if (!firstFocusableChild) {\n        firstFocusableChild = getNextElement(\n          root.current,\n          root.current.firstChild as HTMLElement,\n          false,\n          false,\n          false,\n          true,\n        );\n      }\n    }\n    if (firstFocusableChild) {\n      focusAsync(firstFocusableChild);\n    }\n  }, [firstFocusableSelector, firstFocusableTarget, focusPreviouslyFocusedInnerElement, internalState]);\n\n  const onBumperFocus = React.useCallback(\n    (isFirstBumper: boolean) => {\n      if (disabled) {\n        return;\n      }\n\n      const currentBumper = (isFirstBumper === internalState.hasFocus\n        ? lastBumper.current\n        : firstBumper.current) as HTMLElement;\n\n      if (root.current) {\n        const nextFocusable =\n          isFirstBumper === internalState.hasFocus\n            ? getLastTabbable(root.current, currentBumper, true, false)\n            : getFirstTabbable(root.current, currentBumper, true, false);\n\n        if (nextFocusable) {\n          if (nextFocusable === firstBumper.current || nextFocusable === lastBumper.current) {\n            // This can happen when FTZ contains no tabbable elements.\n            // focus will take care of finding a focusable element in FTZ.\n            focus();\n          } else {\n            nextFocusable.focus();\n          }\n        }\n      }\n    },\n    [disabled, focus, internalState],\n  );\n\n  const onRootBlurCapture = React.useCallback(\n    (ev: React.FocusEvent<HTMLDivElement>) => {\n      onBlurCapture?.(ev);\n      let relatedTarget = ev.relatedTarget;\n      if (ev.relatedTarget === null) {\n        // In IE11, due to lack of support, event.relatedTarget is always\n        // null making every onBlur call to be \"outside\" of the root\n        // even when it's not. Using document.activeElement is another way\n        // for us to be able to get what the relatedTarget without relying\n        // on the event\n        relatedTarget = doc!.activeElement as Element;\n      }\n      if (!elementContains(root.current, relatedTarget as HTMLElement)) {\n        internalState.hasFocus = false;\n      }\n    },\n    [doc, internalState, onBlurCapture],\n  );\n\n  const onRootFocusCapture = React.useCallback(\n    (ev: React.FocusEvent<HTMLDivElement>) => {\n      onFocusCapture?.(ev);\n\n      if (ev.target === firstBumper.current) {\n        onBumperFocus(true);\n      } else if (ev.target === lastBumper.current) {\n        onBumperFocus(false);\n      }\n\n      internalState.hasFocus = true;\n\n      if (ev.target !== ev.currentTarget && !(ev.target === firstBumper.current || ev.target === lastBumper.current)) {\n        // every time focus changes within the trap zone, remember the focused element so that\n        // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))\n        internalState.previouslyFocusedElementInTrapZone = ev.target as HTMLElement;\n      }\n    },\n    [onFocusCapture, internalState, onBumperFocus],\n  );\n\n  const returnFocusToInitiator = React.useCallback((): void => {\n    FocusTrapZone.focusStack = FocusTrapZone.focusStack.filter((value: any) => {\n      return id !== value;\n    });\n\n    if (doc) {\n      const activeElement = doc.activeElement as HTMLElement;\n      if (\n        !ignoreExternalFocusing &&\n        internalState.previouslyFocusedElementOutsideTrapZone &&\n        typeof internalState.previouslyFocusedElementOutsideTrapZone.focus === 'function' &&\n        (elementContains(root.current, activeElement) || activeElement === doc.body)\n      ) {\n        if (\n          !(\n            internalState.previouslyFocusedElementOutsideTrapZone === firstBumper.current ||\n            internalState.previouslyFocusedElementOutsideTrapZone === lastBumper.current\n          )\n        ) {\n          focusAsync(internalState.previouslyFocusedElementOutsideTrapZone);\n        }\n      }\n    }\n  }, [doc, id, ignoreExternalFocusing, internalState]);\n\n  const forceFocusInTrap = React.useCallback(\n    (ev: FocusEvent): void => {\n      if (disabled) {\n        return;\n      }\n      if (FocusTrapZone.focusStack.length && id === FocusTrapZone.focusStack[FocusTrapZone.focusStack.length - 1]) {\n        const focusedElement = ev.target as HTMLElement;\n        if (!elementContains(root.current, focusedElement)) {\n          focus();\n          internalState.hasFocus = true; // set focus here since we stop event propagation\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    },\n    [disabled, id, focus, internalState],\n  );\n\n  const forceClickInTrap = React.useCallback(\n    (ev: MouseEvent): void => {\n      if (disabled) {\n        return;\n      }\n      if (FocusTrapZone.focusStack.length && id === FocusTrapZone.focusStack[FocusTrapZone.focusStack.length - 1]) {\n        const clickedElement = ev.target as HTMLElement;\n        if (clickedElement && !elementContains(root.current, clickedElement)) {\n          focus();\n          internalState.hasFocus = true; // set focus here since we stop event propagation\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    },\n    [disabled, id, focus, internalState],\n  );\n\n  const updateEventHandlers = React.useCallback((): void => {\n    if (forceFocusInsideTrap && !internalState.disposeFocusHandler) {\n      internalState.disposeFocusHandler = on(window, 'focus', forceFocusInTrap, true);\n    } else if (!forceFocusInsideTrap && internalState.disposeFocusHandler) {\n      internalState.disposeFocusHandler();\n      internalState.disposeFocusHandler = undefined;\n    }\n\n    if (!isClickableOutsideFocusTrap && !internalState.disposeClickHandler) {\n      internalState.disposeClickHandler = on(window, 'click', forceClickInTrap, true);\n    } else if (isClickableOutsideFocusTrap && internalState.disposeClickHandler) {\n      internalState.disposeClickHandler();\n      internalState.disposeClickHandler = undefined;\n    }\n  }, [forceClickInTrap, forceFocusInTrap, forceFocusInsideTrap, isClickableOutsideFocusTrap, internalState]);\n\n  // Updates eventHandlers and cleans up focusStack when the component unmounts.\n  React.useEffect(() => {\n    const parentRoot = root.current;\n    updateEventHandlers();\n    return () => {\n      // don't handle return focus unless forceFocusInsideTrap is true or focus is still within FocusTrapZone\n      if (!disabled || forceFocusInsideTrap || !elementContains(parentRoot, doc?.activeElement as HTMLElement)) {\n        returnFocusToInitiator();\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- Should only run on mount.\n  }, [updateEventHandlers]);\n\n  // Updates focusStack and the previouslyFocusedElementOutsideTrapZone on prop change.\n  React.useEffect(() => {\n    const newForceFocusInsideTrap = forceFocusInsideTrap !== undefined ? forceFocusInsideTrap : true;\n    const newDisabled = disabled !== undefined ? disabled : false;\n\n    // Transition from forceFocusInsideTrap / FTZ disabled to enabled.\n    if (!newDisabled || newForceFocusInsideTrap) {\n      if (currentDisabledValue) {\n        return;\n      }\n\n      FocusTrapZone.focusStack.push(id);\n\n      internalState.previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss\n        ? elementToFocusOnDismiss\n        : (doc!.activeElement as HTMLElement);\n      if (!disableFirstFocus && !elementContains(root.current, internalState.previouslyFocusedElementOutsideTrapZone)) {\n        focus();\n      }\n      if (!internalState.unmodalize && root.current && enableAriaHiddenSiblings) {\n        internalState.unmodalize = modalize(root.current);\n      }\n    } else if (!newForceFocusInsideTrap || newDisabled) {\n      // Transition from forceFocusInsideTrap / FTZ enabled to disabled.\n      returnFocusToInitiator();\n      if (internalState.unmodalize) {\n        internalState.unmodalize();\n      }\n    }\n\n    if (elementToFocusOnDismiss && internalState.previouslyFocusedElementOutsideTrapZone !== elementToFocusOnDismiss) {\n      internalState.previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss;\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [elementToFocusOnDismiss, forceFocusInsideTrap, disabled]);\n\n  // Cleanup lifecyle method for internalState.\n  useUnmount(() => {\n    // Dispose of event handlers so their closures can be garbage-collected\n    if (internalState.disposeClickHandler) {\n      internalState.disposeClickHandler();\n      internalState.disposeClickHandler = undefined;\n    }\n    if (internalState.disposeFocusHandler) {\n      internalState.disposeFocusHandler();\n      internalState.disposeFocusHandler = undefined;\n    }\n    if (internalState.unmodalize) {\n      internalState.unmodalize();\n    }\n    // Dispose of element references so the DOM Nodes can be garbage-collected\n    delete internalState.previouslyFocusedElementInTrapZone;\n    delete internalState.previouslyFocusedElementOutsideTrapZone;\n  });\n\n  useComponentRef(componentRef, internalState.previouslyFocusedElementInTrapZone, focus);\n\n  return (\n    <div\n      {...divProps}\n      className={className}\n      ref={mergedRootRef}\n      aria-labelledby={ariaLabelledBy}\n      onFocusCapture={onRootFocusCapture}\n      onFocus={onFocus}\n      onBlur={onBlur}\n      onBlurCapture={onRootBlurCapture}\n    >\n      <div {...bumperProps} ref={firstBumper} />\n      {children}\n      <div {...bumperProps} ref={lastBumper} />\n    </div>\n  );\n}) as any;\n\nFocusTrapZone.displayName = COMPONENT_NAME;\nFocusTrapZone.focusStack = [];\n"]},"metadata":{},"sourceType":"module"}